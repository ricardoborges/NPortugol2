//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.4
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.4 E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g 2012-10-29 16:27:14

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019

using System.Collections;

using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;


using Antlr.Runtime.Tree;
using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;

namespace NPortugol2.Compiler
{
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.4")]
[System.CLSCompliant(false)]
public partial class NPortugolParser : Antlr.Runtime.Parser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "AR", "ARG", "ASGN", "ASM", "CALL", "CHAR", "DEC", "ESC_SEQ", "EXP", "EXPONENT", "FLOAT", "FUNC", "HEX_DIGIT", "ID", "ILIST", "INDEX", "INIT", "INT", "JMP", "LEXP", "LOOP", "MCALL", "NEWLINE", "OCTAL_ESC", "PARAM", "PCALL", "RET", "SJMP", "SLIST", "STRING", "TYPE", "UNICODE_ESC", "VAR", "WS", "'!='", "'#'", "'%'", "'('", "')'", "'*'", "'+'", "','", "'-'", "'.'", "'..'", "'/'", "'<'", "'<='", "'='", "'=='", "'>'", "'>='", "'['", "']'", "'ate'", "'dec'", "'e'", "'enquanto'", "'entao'", "'fim'", "'funcao'", "'ou'", "'para'", "'repita'", "'retorne'", "'se'", "'senao'", "'variavel'", "'{'", "'}'"
	};
	public const int EOF=-1;
	public const int T__38=38;
	public const int T__39=39;
	public const int T__40=40;
	public const int T__41=41;
	public const int T__42=42;
	public const int T__43=43;
	public const int T__44=44;
	public const int T__45=45;
	public const int T__46=46;
	public const int T__47=47;
	public const int T__48=48;
	public const int T__49=49;
	public const int T__50=50;
	public const int T__51=51;
	public const int T__52=52;
	public const int T__53=53;
	public const int T__54=54;
	public const int T__55=55;
	public const int T__56=56;
	public const int T__57=57;
	public const int T__58=58;
	public const int T__59=59;
	public const int T__60=60;
	public const int T__61=61;
	public const int T__62=62;
	public const int T__63=63;
	public const int T__64=64;
	public const int T__65=65;
	public const int T__66=66;
	public const int T__67=67;
	public const int T__68=68;
	public const int T__69=69;
	public const int T__70=70;
	public const int T__71=71;
	public const int T__72=72;
	public const int T__73=73;
	public const int AR=4;
	public const int ARG=5;
	public const int ASGN=6;
	public const int ASM=7;
	public const int CALL=8;
	public const int CHAR=9;
	public const int DEC=10;
	public const int ESC_SEQ=11;
	public const int EXP=12;
	public const int EXPONENT=13;
	public const int FLOAT=14;
	public const int FUNC=15;
	public const int HEX_DIGIT=16;
	public const int ID=17;
	public const int ILIST=18;
	public const int INDEX=19;
	public const int INIT=20;
	public const int INT=21;
	public const int JMP=22;
	public const int LEXP=23;
	public const int LOOP=24;
	public const int MCALL=25;
	public const int NEWLINE=26;
	public const int OCTAL_ESC=27;
	public const int PARAM=28;
	public const int PCALL=29;
	public const int RET=30;
	public const int SJMP=31;
	public const int SLIST=32;
	public const int STRING=33;
	public const int TYPE=34;
	public const int UNICODE_ESC=35;
	public const int VAR=36;
	public const int WS=37;

	public NPortugolParser(ITokenStream input)
		: this(input, new RecognizerSharedState())
	{
	}
	public NPortugolParser(ITokenStream input, RecognizerSharedState state)
		: base(input, state)
	{
		ITreeAdaptor treeAdaptor = default(ITreeAdaptor);
		CreateTreeAdaptor(ref treeAdaptor);
		TreeAdaptor = treeAdaptor ?? new CommonTreeAdaptor();
		OnCreated();
	}
	// Implement this function in your helper file to use a custom tree adaptor
	partial void CreateTreeAdaptor(ref ITreeAdaptor adaptor);

	private ITreeAdaptor adaptor;

	public ITreeAdaptor TreeAdaptor
	{
		get
		{
			return adaptor;
		}

		set
		{
			this.adaptor = value;
		}
	}

	public override string[] TokenNames { get { return NPortugolParser.tokenNames; } }
	public override string GrammarFileName { get { return "E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g"; } }



		Stack<string> paraphrases = new Stack<string>();
		
	        public string GetErrorMessage(RecognitionException e)
	        {
	            string msg = "Erro na linha {0} posição {1}: '{2}'";
		    msg = string.Format(msg, e.Line, e.CharPositionInLine, e.Token.Text);
	            if (paraphrases.Count > 0){
	                string paraphrase = (string)paraphrases.Pop();
	                msg = msg + " " + paraphrase;
	            }
	            return msg;
	        }
		protected void mismatch(IIntStream input, int ttype, BitSet follow)	{
			throw new MismatchedTokenException(ttype, input);
		}
		public void recoverFromMismatchedSet(IIntStream input,RecognitionException e, BitSet follow) {
			throw e;
		}

		public List<string> Functions = new List<string>();
		public List<string> Symbols = new List<string>();	
		public bool IsDefinedID(string id){    return Symbols.Contains(id);}
		public bool IsDefined(string name) { return Functions.Contains(name); }
		public void DefineID(IList<IToken> ids){ foreach(var id in ids) { Symbols.Add(id.Text); }}
		public void DefineFunction(string name){ Functions.Add(name);}	


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	#region Rules
	partial void EnterRule_script();
	partial void LeaveRule_script();

	// $ANTLR start "script"
	// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:73:8: public script : ( declare_function )* ;
	[GrammarRule("script")]
	public AstParserRuleReturnScope<object, IToken> script()
	{
		EnterRule_script();
		EnterRule("script", 1);
		TraceIn("script", 1);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> declare_function1 = default(AstParserRuleReturnScope<object, IToken>);

		try { DebugEnterRule(GrammarFileName, "script");
		DebugLocation(73, 34);
		try
		{
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:73:15: ( ( declare_function )* )
			DebugEnterAlt(1);
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:73:17: ( declare_function )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(73, 17);
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:73:17: ( declare_function )*
			try { DebugEnterSubRule(1);
			while (true)
			{
				int alt1=2;
				try { DebugEnterDecision(1, false);
				int LA1_0 = input.LA(1);

				if ((LA1_0==64))
				{
					alt1 = 1;
				}


				} finally { DebugExitDecision(1); }
				switch ( alt1 )
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:73:17: declare_function
					{
					DebugLocation(73, 17);
					PushFollow(Follow._declare_function_in_script148);
					declare_function1=declare_function();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, declare_function1.Tree);

					}
					break;

				default:
					goto loop1;
				}
			}

			loop1:
				;

			} finally { DebugExitSubRule(1); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

			catch (RecognitionException e) {
				throw e;
			}

		finally
		{
			TraceOut("script", 1);
			LeaveRule("script", 1);
			LeaveRule_script();
		}
		DebugLocation(73, 34);
		} finally { DebugExitRule(GrammarFileName, "script"); }
		return retval;

	}
	// $ANTLR end "script"

	partial void EnterRule_declare_function();
	partial void LeaveRule_declare_function();

	// $ANTLR start "declare_function"
	// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:75:1: declare_function : 'funcao' (t= TYPE )? i= ID '(' ( function_param_list )* ')' ( statement )* 'fim' -> ^( FUNC ( TYPE )? ID ( function_param_list )* ^( SLIST ( statement )* ) ) ;
	[GrammarRule("declare_function")]
	private AstParserRuleReturnScope<object, IToken> declare_function()
	{
		EnterRule_declare_function();
		EnterRule("declare_function", 2);
		TraceIn("declare_function", 2);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken t = default(IToken);
		IToken i = default(IToken);
		IToken string_literal2 = default(IToken);
		IToken char_literal3 = default(IToken);
		IToken char_literal5 = default(IToken);
		IToken string_literal7 = default(IToken);
		AstParserRuleReturnScope<object, IToken> function_param_list4 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> statement6 = default(AstParserRuleReturnScope<object, IToken>);

		object t_tree = default(object);
		object i_tree = default(object);
		object string_literal2_tree = default(object);
		object char_literal3_tree = default(object);
		object char_literal5_tree = default(object);
		object string_literal7_tree = default(object);
		RewriteRuleITokenStream stream_42=new RewriteRuleITokenStream(adaptor,"token 42");
		RewriteRuleITokenStream stream_41=new RewriteRuleITokenStream(adaptor,"token 41");
		RewriteRuleITokenStream stream_64=new RewriteRuleITokenStream(adaptor,"token 64");
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleITokenStream stream_63=new RewriteRuleITokenStream(adaptor,"token 63");
		RewriteRuleITokenStream stream_TYPE=new RewriteRuleITokenStream(adaptor,"token TYPE");
		RewriteRuleSubtreeStream stream_statement=new RewriteRuleSubtreeStream(adaptor,"rule statement");
		RewriteRuleSubtreeStream stream_function_param_list=new RewriteRuleSubtreeStream(adaptor,"rule function_param_list");
		try { DebugEnterRule(GrammarFileName, "declare_function");
		DebugLocation(75, 1);
		try
		{
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:76:2: ( 'funcao' (t= TYPE )? i= ID '(' ( function_param_list )* ')' ( statement )* 'fim' -> ^( FUNC ( TYPE )? ID ( function_param_list )* ^( SLIST ( statement )* ) ) )
			DebugEnterAlt(1);
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:76:4: 'funcao' (t= TYPE )? i= ID '(' ( function_param_list )* ')' ( statement )* 'fim'
			{
			DebugLocation(76, 4);
			string_literal2=(IToken)Match(input,64,Follow._64_in_declare_function159); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_64.Add(string_literal2);

			DebugLocation(76, 14);
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:76:14: (t= TYPE )?
			int alt2=2;
			try { DebugEnterSubRule(2);
			try { DebugEnterDecision(2, false);
			int LA2_0 = input.LA(1);

			if ((LA2_0==TYPE))
			{
				alt2 = 1;
			}
			} finally { DebugExitDecision(2); }
			switch (alt2)
			{
			case 1:
				DebugEnterAlt(1);
				// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:76:14: t= TYPE
				{
				DebugLocation(76, 14);
				t=(IToken)Match(input,TYPE,Follow._TYPE_in_declare_function163); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_TYPE.Add(t);


				}
				break;

			}
			} finally { DebugExitSubRule(2); }

			DebugLocation(76, 22);
			i=(IToken)Match(input,ID,Follow._ID_in_declare_function168); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ID.Add(i);

			DebugLocation(76, 26);
			char_literal3=(IToken)Match(input,41,Follow._41_in_declare_function170); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_41.Add(char_literal3);

			DebugLocation(76, 30);
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:76:30: ( function_param_list )*
			try { DebugEnterSubRule(3);
			while (true)
			{
				int alt3=2;
				try { DebugEnterDecision(3, false);
				int LA3_0 = input.LA(1);

				if ((LA3_0==TYPE))
				{
					alt3 = 1;
				}


				} finally { DebugExitDecision(3); }
				switch ( alt3 )
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:76:30: function_param_list
					{
					DebugLocation(76, 30);
					PushFollow(Follow._function_param_list_in_declare_function172);
					function_param_list4=function_param_list();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_function_param_list.Add(function_param_list4.Tree);

					}
					break;

				default:
					goto loop3;
				}
			}

			loop3:
				;

			} finally { DebugExitSubRule(3); }

			DebugLocation(76, 51);
			char_literal5=(IToken)Match(input,42,Follow._42_in_declare_function175); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_42.Add(char_literal5);

			DebugLocation(76, 55);
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:76:55: ( statement )*
			try { DebugEnterSubRule(4);
			while (true)
			{
				int alt4=2;
				try { DebugEnterDecision(4, false);
				int LA4_0 = input.LA(1);

				if ((LA4_0==ID||LA4_0==39||LA4_0==61||(LA4_0>=66 && LA4_0<=69)||LA4_0==71))
				{
					alt4 = 1;
				}


				} finally { DebugExitDecision(4); }
				switch ( alt4 )
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:76:55: statement
					{
					DebugLocation(76, 55);
					PushFollow(Follow._statement_in_declare_function177);
					statement6=statement();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_statement.Add(statement6.Tree);

					}
					break;

				default:
					goto loop4;
				}
			}

			loop4:
				;

			} finally { DebugExitSubRule(4); }

			DebugLocation(76, 66);
			string_literal7=(IToken)Match(input,63,Follow._63_in_declare_function180); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_63.Add(string_literal7);

			DebugLocation(77, 3);
			if (state.backtracking == 0)
			{
				DefineFunction((i!=null?i.Text:null));
			}


			{
			// AST REWRITE
			// elements: function_param_list, statement, TYPE, ID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 78:3: -> ^( FUNC ( TYPE )? ID ( function_param_list )* ^( SLIST ( statement )* ) )
			{
				DebugLocation(78, 6);
				// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:78:6: ^( FUNC ( TYPE )? ID ( function_param_list )* ^( SLIST ( statement )* ) )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(78, 8);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(FUNC, "FUNC"), root_1);

				DebugLocation(78, 13);
				// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:78:13: ( TYPE )?
				if (stream_TYPE.HasNext)
				{
					DebugLocation(78, 13);
					adaptor.AddChild(root_1, stream_TYPE.NextNode());

				}
				stream_TYPE.Reset();
				DebugLocation(78, 19);
				adaptor.AddChild(root_1, stream_ID.NextNode());
				DebugLocation(78, 22);
				// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:78:22: ( function_param_list )*
				while ( stream_function_param_list.HasNext )
				{
					DebugLocation(78, 22);
					adaptor.AddChild(root_1, stream_function_param_list.NextTree());

				}
				stream_function_param_list.Reset();
				DebugLocation(78, 43);
				// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:78:43: ^( SLIST ( statement )* )
				{
				object root_2 = (object)adaptor.Nil();
				DebugLocation(78, 45);
				root_2 = (object)adaptor.BecomeRoot((object)adaptor.Create(SLIST, "SLIST"), root_2);

				DebugLocation(78, 51);
				// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:78:51: ( statement )*
				while ( stream_statement.HasNext )
				{
					DebugLocation(78, 51);
					adaptor.AddChild(root_2, stream_statement.NextTree());

				}
				stream_statement.Reset();

				adaptor.AddChild(root_1, root_2);
				}

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

			catch (RecognitionException e) {
				throw e;
			}

		finally
		{
			TraceOut("declare_function", 2);
			LeaveRule("declare_function", 2);
			LeaveRule_declare_function();
		}
		DebugLocation(79, 1);
		} finally { DebugExitRule(GrammarFileName, "declare_function"); }
		return retval;

	}
	// $ANTLR end "declare_function"

	partial void EnterRule_statement();
	partial void LeaveRule_statement();

	// $ANTLR start "statement"
	// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:81:1: statement : ( declare_local | if_stat | for_stat | while_stat | repeat_stat | function_call | assign_var | return_stat | asm_code );
	[GrammarRule("statement")]
	private AstParserRuleReturnScope<object, IToken> statement()
	{
		EnterRule_statement();
		EnterRule("statement", 3);
		TraceIn("statement", 3);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> declare_local8 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> if_stat9 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> for_stat10 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> while_stat11 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> repeat_stat12 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> function_call13 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> assign_var14 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> return_stat15 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> asm_code16 = default(AstParserRuleReturnScope<object, IToken>);

		 paraphrases.Push("na sentença"); 
		try { DebugEnterRule(GrammarFileName, "statement");
		DebugLocation(81, 1);
		try
		{
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:83:2: ( declare_local | if_stat | for_stat | while_stat | repeat_stat | function_call | assign_var | return_stat | asm_code )
			int alt5=9;
			try { DebugEnterDecision(5, false);
			switch (input.LA(1))
			{
			case 71:
				{
				alt5 = 1;
				}
				break;
			case 69:
				{
				alt5 = 2;
				}
				break;
			case 66:
				{
				alt5 = 3;
				}
				break;
			case 61:
				{
				alt5 = 4;
				}
				break;
			case 67:
				{
				alt5 = 5;
				}
				break;
			case ID:
				{
				int LA5_6 = input.LA(2);

				if ((LA5_6==41))
				{
					alt5 = 6;
				}
				else if ((LA5_6==52||LA5_6==56))
				{
					alt5 = 7;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 5, 6, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case 68:
				{
				alt5 = 8;
				}
				break;
			case 39:
				{
				alt5 = 9;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 5, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(5); }
			switch (alt5)
			{
			case 1:
				DebugEnterAlt(1);
				// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:83:4: declare_local
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(83, 4);
				PushFollow(Follow._declare_local_in_statement230);
				declare_local8=declare_local();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, declare_local8.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:84:4: if_stat
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(84, 4);
				PushFollow(Follow._if_stat_in_statement236);
				if_stat9=if_stat();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, if_stat9.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:85:4: for_stat
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(85, 4);
				PushFollow(Follow._for_stat_in_statement242);
				for_stat10=for_stat();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, for_stat10.Tree);

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:86:4: while_stat
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(86, 4);
				PushFollow(Follow._while_stat_in_statement247);
				while_stat11=while_stat();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, while_stat11.Tree);

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:87:4: repeat_stat
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(87, 4);
				PushFollow(Follow._repeat_stat_in_statement252);
				repeat_stat12=repeat_stat();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, repeat_stat12.Tree);

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:88:4: function_call
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(88, 4);
				PushFollow(Follow._function_call_in_statement258);
				function_call13=function_call();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, function_call13.Tree);

				}
				break;
			case 7:
				DebugEnterAlt(7);
				// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:89:4: assign_var
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(89, 4);
				PushFollow(Follow._assign_var_in_statement264);
				assign_var14=assign_var();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, assign_var14.Tree);

				}
				break;
			case 8:
				DebugEnterAlt(8);
				// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:90:4: return_stat
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(90, 4);
				PushFollow(Follow._return_stat_in_statement270);
				return_stat15=return_stat();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, return_stat15.Tree);

				}
				break;
			case 9:
				DebugEnterAlt(9);
				// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:91:4: asm_code
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(91, 4);
				PushFollow(Follow._asm_code_in_statement275);
				asm_code16=asm_code();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, asm_code16.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
			if (state.backtracking == 0)
			{
				 paraphrases.Pop(); 
			}
		}

			catch (RecognitionException e) {
				throw e;
			}

		finally
		{
			TraceOut("statement", 3);
			LeaveRule("statement", 3);
			LeaveRule_statement();
		}
		DebugLocation(92, 1);
		} finally { DebugExitRule(GrammarFileName, "statement"); }
		return retval;

	}
	// $ANTLR end "statement"

	partial void EnterRule_function_param_list();
	partial void LeaveRule_function_param_list();

	// $ANTLR start "function_param_list"
	// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:94:1: function_param_list : param ( ',' param )* -> ^( PARAM ( param )* ) ;
	[GrammarRule("function_param_list")]
	private AstParserRuleReturnScope<object, IToken> function_param_list()
	{
		EnterRule_function_param_list();
		EnterRule("function_param_list", 4);
		TraceIn("function_param_list", 4);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken char_literal18 = default(IToken);
		AstParserRuleReturnScope<object, IToken> param17 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> param19 = default(AstParserRuleReturnScope<object, IToken>);

		object char_literal18_tree = default(object);
		RewriteRuleITokenStream stream_45=new RewriteRuleITokenStream(adaptor,"token 45");
		RewriteRuleSubtreeStream stream_param=new RewriteRuleSubtreeStream(adaptor,"rule param");
		 paraphrases.Push("na lista de parâmetros"); 
		try { DebugEnterRule(GrammarFileName, "function_param_list");
		DebugLocation(94, 1);
		try
		{
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:95:2: ( param ( ',' param )* -> ^( PARAM ( param )* ) )
			DebugEnterAlt(1);
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:95:4: param ( ',' param )*
			{
			DebugLocation(95, 4);
			PushFollow(Follow._param_in_function_param_list303);
			param17=param();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_param.Add(param17.Tree);
			DebugLocation(95, 10);
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:95:10: ( ',' param )*
			try { DebugEnterSubRule(6);
			while (true)
			{
				int alt6=2;
				try { DebugEnterDecision(6, false);
				int LA6_0 = input.LA(1);

				if ((LA6_0==45))
				{
					alt6 = 1;
				}


				} finally { DebugExitDecision(6); }
				switch ( alt6 )
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:95:11: ',' param
					{
					DebugLocation(95, 11);
					char_literal18=(IToken)Match(input,45,Follow._45_in_function_param_list306); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_45.Add(char_literal18);

					DebugLocation(95, 15);
					PushFollow(Follow._param_in_function_param_list308);
					param19=param();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_param.Add(param19.Tree);

					}
					break;

				default:
					goto loop6;
				}
			}

			loop6:
				;

			} finally { DebugExitSubRule(6); }



			{
			// AST REWRITE
			// elements: param
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 95:23: -> ^( PARAM ( param )* )
			{
				DebugLocation(95, 26);
				// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:95:26: ^( PARAM ( param )* )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(95, 28);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(PARAM, "PARAM"), root_1);

				DebugLocation(95, 34);
				// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:95:34: ( param )*
				while ( stream_param.HasNext )
				{
					DebugLocation(95, 34);
					adaptor.AddChild(root_1, stream_param.NextTree());

				}
				stream_param.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
			if (state.backtracking == 0)
			{
				 paraphrases.Pop(); 
			}
		}

			catch (RecognitionException e) {
				throw e;
			}

		finally
		{
			TraceOut("function_param_list", 4);
			LeaveRule("function_param_list", 4);
			LeaveRule_function_param_list();
		}
		DebugLocation(96, 1);
		} finally { DebugExitRule(GrammarFileName, "function_param_list"); }
		return retval;

	}
	// $ANTLR end "function_param_list"

	partial void EnterRule_param();
	partial void LeaveRule_param();

	// $ANTLR start "param"
	// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:98:1: param : TYPE ID -> ^( TYPE ID ) ;
	[GrammarRule("param")]
	private AstParserRuleReturnScope<object, IToken> param()
	{
		EnterRule_param();
		EnterRule("param", 5);
		TraceIn("param", 5);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken TYPE20 = default(IToken);
		IToken ID21 = default(IToken);

		object TYPE20_tree = default(object);
		object ID21_tree = default(object);
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleITokenStream stream_TYPE=new RewriteRuleITokenStream(adaptor,"token TYPE");
		try { DebugEnterRule(GrammarFileName, "param");
		DebugLocation(98, 29);
		try
		{
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:98:7: ( TYPE ID -> ^( TYPE ID ) )
			DebugEnterAlt(1);
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:98:9: TYPE ID
			{
			DebugLocation(98, 9);
			TYPE20=(IToken)Match(input,TYPE,Follow._TYPE_in_param331); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_TYPE.Add(TYPE20);

			DebugLocation(98, 14);
			ID21=(IToken)Match(input,ID,Follow._ID_in_param333); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ID.Add(ID21);



			{
			// AST REWRITE
			// elements: ID, TYPE
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 98:17: -> ^( TYPE ID )
			{
				DebugLocation(98, 20);
				// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:98:20: ^( TYPE ID )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(98, 22);
				root_1 = (object)adaptor.BecomeRoot(stream_TYPE.NextNode(), root_1);

				DebugLocation(98, 27);
				adaptor.AddChild(root_1, stream_ID.NextNode());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

			catch (RecognitionException e) {
				throw e;
			}

		finally
		{
			TraceOut("param", 5);
			LeaveRule("param", 5);
			LeaveRule_param();
		}
		DebugLocation(98, 29);
		} finally { DebugExitRule(GrammarFileName, "param"); }
		return retval;

	}
	// $ANTLR end "param"

	partial void EnterRule_declare_local();
	partial void LeaveRule_declare_local();

	// $ANTLR start "declare_local"
	// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:100:1: declare_local : 'variavel' local_var ( ',' more_var )* -> ^( VAR local_var ( more_var )* ) ;
	[GrammarRule("declare_local")]
	private AstParserRuleReturnScope<object, IToken> declare_local()
	{
		EnterRule_declare_local();
		EnterRule("declare_local", 6);
		TraceIn("declare_local", 6);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken string_literal22 = default(IToken);
		IToken char_literal24 = default(IToken);
		AstParserRuleReturnScope<object, IToken> local_var23 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> more_var25 = default(AstParserRuleReturnScope<object, IToken>);

		object string_literal22_tree = default(object);
		object char_literal24_tree = default(object);
		RewriteRuleITokenStream stream_45=new RewriteRuleITokenStream(adaptor,"token 45");
		RewriteRuleITokenStream stream_71=new RewriteRuleITokenStream(adaptor,"token 71");
		RewriteRuleSubtreeStream stream_local_var=new RewriteRuleSubtreeStream(adaptor,"rule local_var");
		RewriteRuleSubtreeStream stream_more_var=new RewriteRuleSubtreeStream(adaptor,"rule more_var");
		 paraphrases.Push("na definição de variável"); 
		try { DebugEnterRule(GrammarFileName, "declare_local");
		DebugLocation(100, 1);
		try
		{
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:101:2: ( 'variavel' local_var ( ',' more_var )* -> ^( VAR local_var ( more_var )* ) )
			DebugEnterAlt(1);
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:101:4: 'variavel' local_var ( ',' more_var )*
			{
			DebugLocation(101, 4);
			string_literal22=(IToken)Match(input,71,Follow._71_in_declare_local373); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_71.Add(string_literal22);

			DebugLocation(101, 15);
			PushFollow(Follow._local_var_in_declare_local375);
			local_var23=local_var();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_local_var.Add(local_var23.Tree);
			DebugLocation(101, 25);
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:101:25: ( ',' more_var )*
			try { DebugEnterSubRule(7);
			while (true)
			{
				int alt7=2;
				try { DebugEnterDecision(7, false);
				int LA7_0 = input.LA(1);

				if ((LA7_0==45))
				{
					alt7 = 1;
				}


				} finally { DebugExitDecision(7); }
				switch ( alt7 )
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:101:26: ',' more_var
					{
					DebugLocation(101, 26);
					char_literal24=(IToken)Match(input,45,Follow._45_in_declare_local378); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_45.Add(char_literal24);

					DebugLocation(101, 30);
					PushFollow(Follow._more_var_in_declare_local380);
					more_var25=more_var();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_more_var.Add(more_var25.Tree);

					}
					break;

				default:
					goto loop7;
				}
			}

			loop7:
				;

			} finally { DebugExitSubRule(7); }



			{
			// AST REWRITE
			// elements: more_var, local_var
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 102:2: -> ^( VAR local_var ( more_var )* )
			{
				DebugLocation(102, 5);
				// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:102:5: ^( VAR local_var ( more_var )* )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(102, 7);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(VAR, "VAR"), root_1);

				DebugLocation(102, 11);
				adaptor.AddChild(root_1, stream_local_var.NextTree());
				DebugLocation(102, 21);
				// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:102:21: ( more_var )*
				while ( stream_more_var.HasNext )
				{
					DebugLocation(102, 21);
					adaptor.AddChild(root_1, stream_more_var.NextTree());

				}
				stream_more_var.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
			if (state.backtracking == 0)
			{
				 paraphrases.Pop(); 
			}
		}

			catch (RecognitionException e) {
				throw e;
			}

		finally
		{
			TraceOut("declare_local", 6);
			LeaveRule("declare_local", 6);
			LeaveRule_declare_local();
		}
		DebugLocation(103, 1);
		} finally { DebugExitRule(GrammarFileName, "declare_local"); }
		return retval;

	}
	// $ANTLR end "declare_local"

	partial void EnterRule_local_var();
	partial void LeaveRule_local_var();

	// $ANTLR start "local_var"
	// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:105:1: local_var : TYPE ID ( '=' atom )? -> ^( TYPE ID ( atom )? ) ;
	[GrammarRule("local_var")]
	private AstParserRuleReturnScope<object, IToken> local_var()
	{
		EnterRule_local_var();
		EnterRule("local_var", 7);
		TraceIn("local_var", 7);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken TYPE26 = default(IToken);
		IToken ID27 = default(IToken);
		IToken char_literal28 = default(IToken);
		AstParserRuleReturnScope<object, IToken> atom29 = default(AstParserRuleReturnScope<object, IToken>);

		object TYPE26_tree = default(object);
		object ID27_tree = default(object);
		object char_literal28_tree = default(object);
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleITokenStream stream_52=new RewriteRuleITokenStream(adaptor,"token 52");
		RewriteRuleITokenStream stream_TYPE=new RewriteRuleITokenStream(adaptor,"token TYPE");
		RewriteRuleSubtreeStream stream_atom=new RewriteRuleSubtreeStream(adaptor,"rule atom");
		try { DebugEnterRule(GrammarFileName, "local_var");
		DebugLocation(105, 1);
		try
		{
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:105:10: ( TYPE ID ( '=' atom )? -> ^( TYPE ID ( atom )? ) )
			DebugEnterAlt(1);
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:106:2: TYPE ID ( '=' atom )?
			{
			DebugLocation(106, 2);
			TYPE26=(IToken)Match(input,TYPE,Follow._TYPE_in_local_var409); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_TYPE.Add(TYPE26);

			DebugLocation(106, 7);
			ID27=(IToken)Match(input,ID,Follow._ID_in_local_var411); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ID.Add(ID27);

			DebugLocation(106, 10);
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:106:10: ( '=' atom )?
			int alt8=2;
			try { DebugEnterSubRule(8);
			try { DebugEnterDecision(8, false);
			int LA8_0 = input.LA(1);

			if ((LA8_0==52))
			{
				alt8 = 1;
			}
			} finally { DebugExitDecision(8); }
			switch (alt8)
			{
			case 1:
				DebugEnterAlt(1);
				// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:106:11: '=' atom
				{
				DebugLocation(106, 11);
				char_literal28=(IToken)Match(input,52,Follow._52_in_local_var414); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_52.Add(char_literal28);

				DebugLocation(106, 15);
				PushFollow(Follow._atom_in_local_var416);
				atom29=atom();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_atom.Add(atom29.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(8); }



			{
			// AST REWRITE
			// elements: atom, TYPE, ID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 106:22: -> ^( TYPE ID ( atom )? )
			{
				DebugLocation(106, 25);
				// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:106:25: ^( TYPE ID ( atom )? )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(106, 27);
				root_1 = (object)adaptor.BecomeRoot(stream_TYPE.NextNode(), root_1);

				DebugLocation(106, 32);
				adaptor.AddChild(root_1, stream_ID.NextNode());
				DebugLocation(106, 35);
				// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:106:35: ( atom )?
				if (stream_atom.HasNext)
				{
					DebugLocation(106, 35);
					adaptor.AddChild(root_1, stream_atom.NextTree());

				}
				stream_atom.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

			catch (RecognitionException e) {
				throw e;
			}

		finally
		{
			TraceOut("local_var", 7);
			LeaveRule("local_var", 7);
			LeaveRule_local_var();
		}
		DebugLocation(107, 1);
		} finally { DebugExitRule(GrammarFileName, "local_var"); }
		return retval;

	}
	// $ANTLR end "local_var"

	partial void EnterRule_more_var();
	partial void LeaveRule_more_var();

	// $ANTLR start "more_var"
	// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:109:1: more_var : ID ( '=' atom )? -> ^( ID ( atom )? ) ;
	[GrammarRule("more_var")]
	private AstParserRuleReturnScope<object, IToken> more_var()
	{
		EnterRule_more_var();
		EnterRule("more_var", 8);
		TraceIn("more_var", 8);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken ID30 = default(IToken);
		IToken char_literal31 = default(IToken);
		AstParserRuleReturnScope<object, IToken> atom32 = default(AstParserRuleReturnScope<object, IToken>);

		object ID30_tree = default(object);
		object char_literal31_tree = default(object);
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleITokenStream stream_52=new RewriteRuleITokenStream(adaptor,"token 52");
		RewriteRuleSubtreeStream stream_atom=new RewriteRuleSubtreeStream(adaptor,"rule atom");
		try { DebugEnterRule(GrammarFileName, "more_var");
		DebugLocation(109, 1);
		try
		{
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:110:2: ( ID ( '=' atom )? -> ^( ID ( atom )? ) )
			DebugEnterAlt(1);
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:111:2: ID ( '=' atom )?
			{
			DebugLocation(111, 2);
			ID30=(IToken)Match(input,ID,Follow._ID_in_more_var446); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ID.Add(ID30);

			DebugLocation(111, 5);
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:111:5: ( '=' atom )?
			int alt9=2;
			try { DebugEnterSubRule(9);
			try { DebugEnterDecision(9, false);
			int LA9_0 = input.LA(1);

			if ((LA9_0==52))
			{
				alt9 = 1;
			}
			} finally { DebugExitDecision(9); }
			switch (alt9)
			{
			case 1:
				DebugEnterAlt(1);
				// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:111:6: '=' atom
				{
				DebugLocation(111, 6);
				char_literal31=(IToken)Match(input,52,Follow._52_in_more_var449); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_52.Add(char_literal31);

				DebugLocation(111, 10);
				PushFollow(Follow._atom_in_more_var451);
				atom32=atom();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_atom.Add(atom32.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(9); }



			{
			// AST REWRITE
			// elements: ID, atom
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 111:17: -> ^( ID ( atom )? )
			{
				DebugLocation(111, 20);
				// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:111:20: ^( ID ( atom )? )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(111, 22);
				root_1 = (object)adaptor.BecomeRoot(stream_ID.NextNode(), root_1);

				DebugLocation(111, 25);
				// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:111:25: ( atom )?
				if (stream_atom.HasNext)
				{
					DebugLocation(111, 25);
					adaptor.AddChild(root_1, stream_atom.NextTree());

				}
				stream_atom.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

			catch (RecognitionException e) {
				throw e;
			}

		finally
		{
			TraceOut("more_var", 8);
			LeaveRule("more_var", 8);
			LeaveRule_more_var();
		}
		DebugLocation(112, 1);
		} finally { DebugExitRule(GrammarFileName, "more_var"); }
		return retval;

	}
	// $ANTLR end "more_var"

	partial void EnterRule_if_stat();
	partial void LeaveRule_if_stat();

	// $ANTLR start "if_stat"
	// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:114:1: if_stat : 'se' p= logic_expression 'entao' (s1+= statement )* (s2= senao_stat -> ^( SJMP ^( LEXP $p) ^( SLIST $s1 $s2) ) | 'fim' -> ^( JMP ^( LEXP $p) ^( SLIST ( $s1)* ) ) ) ;
	[GrammarRule("if_stat")]
	private AstParserRuleReturnScope<object, IToken> if_stat()
	{
		EnterRule_if_stat();
		EnterRule("if_stat", 9);
		TraceIn("if_stat", 9);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken string_literal33 = default(IToken);
		IToken string_literal34 = default(IToken);
		IToken string_literal35 = default(IToken);
		List<object> list_s1 = null;
		AstParserRuleReturnScope<object, IToken> p = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> s2 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> s1 = default(AstParserRuleReturnScope<object, IToken>);
		object string_literal33_tree = default(object);
		object string_literal34_tree = default(object);
		object string_literal35_tree = default(object);
		RewriteRuleITokenStream stream_69=new RewriteRuleITokenStream(adaptor,"token 69");
		RewriteRuleITokenStream stream_62=new RewriteRuleITokenStream(adaptor,"token 62");
		RewriteRuleITokenStream stream_63=new RewriteRuleITokenStream(adaptor,"token 63");
		RewriteRuleSubtreeStream stream_statement=new RewriteRuleSubtreeStream(adaptor,"rule statement");
		RewriteRuleSubtreeStream stream_logic_expression=new RewriteRuleSubtreeStream(adaptor,"rule logic_expression");
		RewriteRuleSubtreeStream stream_senao_stat=new RewriteRuleSubtreeStream(adaptor,"rule senao_stat");
		 paraphrases.Push("se"); 
		try { DebugEnterRule(GrammarFileName, "if_stat");
		DebugLocation(114, 1);
		try
		{
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:116:2: ( 'se' p= logic_expression 'entao' (s1+= statement )* (s2= senao_stat -> ^( SJMP ^( LEXP $p) ^( SLIST $s1 $s2) ) | 'fim' -> ^( JMP ^( LEXP $p) ^( SLIST ( $s1)* ) ) ) )
			DebugEnterAlt(1);
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:116:4: 'se' p= logic_expression 'entao' (s1+= statement )* (s2= senao_stat -> ^( SJMP ^( LEXP $p) ^( SLIST $s1 $s2) ) | 'fim' -> ^( JMP ^( LEXP $p) ^( SLIST ( $s1)* ) ) )
			{
			DebugLocation(116, 4);
			string_literal33=(IToken)Match(input,69,Follow._69_in_if_stat488); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_69.Add(string_literal33);

			DebugLocation(116, 10);
			PushFollow(Follow._logic_expression_in_if_stat492);
			p=logic_expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_logic_expression.Add(p.Tree);
			DebugLocation(116, 28);
			string_literal34=(IToken)Match(input,62,Follow._62_in_if_stat494); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_62.Add(string_literal34);

			DebugLocation(116, 38);
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:116:38: (s1+= statement )*
			try { DebugEnterSubRule(10);
			while (true)
			{
				int alt10=2;
				try { DebugEnterDecision(10, false);
				int LA10_0 = input.LA(1);

				if ((LA10_0==ID||LA10_0==39||LA10_0==61||(LA10_0>=66 && LA10_0<=69)||LA10_0==71))
				{
					alt10 = 1;
				}


				} finally { DebugExitDecision(10); }
				switch ( alt10 )
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:116:38: s1+= statement
					{
					DebugLocation(116, 38);
					PushFollow(Follow._statement_in_if_stat498);
					s1=statement();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_statement.Add(s1.Tree);
					if (list_s1==null) list_s1=new List<object>();
					list_s1.Add(s1.Tree);


					}
					break;

				default:
					goto loop10;
				}
			}

			loop10:
				;

			} finally { DebugExitSubRule(10); }

			DebugLocation(117, 2);
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:117:2: (s2= senao_stat -> ^( SJMP ^( LEXP $p) ^( SLIST $s1 $s2) ) | 'fim' -> ^( JMP ^( LEXP $p) ^( SLIST ( $s1)* ) ) )
			int alt11=2;
			try { DebugEnterSubRule(11);
			try { DebugEnterDecision(11, false);
			int LA11_0 = input.LA(1);

			if ((LA11_0==70))
			{
				alt11 = 1;
			}
			else if ((LA11_0==63))
			{
				alt11 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 11, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(11); }
			switch (alt11)
			{
			case 1:
				DebugEnterAlt(1);
				// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:117:4: s2= senao_stat
				{
				DebugLocation(117, 6);
				PushFollow(Follow._senao_stat_in_if_stat506);
				s2=senao_stat();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_senao_stat.Add(s2.Tree);


				{
				// AST REWRITE
				// elements: s2, p, s1
				// token labels: 
				// rule labels: retval, s2, p
				// token list labels: 
				// rule list labels: s1
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
				RewriteRuleSubtreeStream stream_s2=new RewriteRuleSubtreeStream(adaptor,"rule s2",s2!=null?s2.Tree:null);
				RewriteRuleSubtreeStream stream_p=new RewriteRuleSubtreeStream(adaptor,"rule p",p!=null?p.Tree:null);
				RewriteRuleSubtreeStream stream_s1=new RewriteRuleSubtreeStream(adaptor,"token s1",list_s1);
				root_0 = (object)adaptor.Nil();
				// 117:18: -> ^( SJMP ^( LEXP $p) ^( SLIST $s1 $s2) )
				{
					DebugLocation(117, 21);
					// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:117:21: ^( SJMP ^( LEXP $p) ^( SLIST $s1 $s2) )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(117, 23);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(SJMP, "SJMP"), root_1);

					DebugLocation(117, 28);
					// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:117:28: ^( LEXP $p)
					{
					object root_2 = (object)adaptor.Nil();
					DebugLocation(117, 30);
					root_2 = (object)adaptor.BecomeRoot((object)adaptor.Create(LEXP, "LEXP"), root_2);

					DebugLocation(117, 36);
					adaptor.AddChild(root_2, stream_p.NextTree());

					adaptor.AddChild(root_1, root_2);
					}
					DebugLocation(117, 39);
					// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:117:39: ^( SLIST $s1 $s2)
					{
					object root_2 = (object)adaptor.Nil();
					DebugLocation(117, 41);
					root_2 = (object)adaptor.BecomeRoot((object)adaptor.Create(SLIST, "SLIST"), root_2);

					DebugLocation(117, 48);
					adaptor.AddChild(root_2, stream_s1.NextTree());
					DebugLocation(117, 52);
					adaptor.AddChild(root_2, stream_s2.NextTree());

					adaptor.AddChild(root_1, root_2);
					}

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:118:4: 'fim'
				{
				DebugLocation(118, 4);
				string_literal35=(IToken)Match(input,63,Follow._63_in_if_stat534); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_63.Add(string_literal35);



				{
				// AST REWRITE
				// elements: s1, p
				// token labels: 
				// rule labels: retval, p
				// token list labels: 
				// rule list labels: s1
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
				RewriteRuleSubtreeStream stream_p=new RewriteRuleSubtreeStream(adaptor,"rule p",p!=null?p.Tree:null);
				RewriteRuleSubtreeStream stream_s1=new RewriteRuleSubtreeStream(adaptor,"token s1",list_s1);
				root_0 = (object)adaptor.Nil();
				// 118:10: -> ^( JMP ^( LEXP $p) ^( SLIST ( $s1)* ) )
				{
					DebugLocation(118, 13);
					// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:118:13: ^( JMP ^( LEXP $p) ^( SLIST ( $s1)* ) )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(118, 15);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(JMP, "JMP"), root_1);

					DebugLocation(118, 19);
					// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:118:19: ^( LEXP $p)
					{
					object root_2 = (object)adaptor.Nil();
					DebugLocation(118, 21);
					root_2 = (object)adaptor.BecomeRoot((object)adaptor.Create(LEXP, "LEXP"), root_2);

					DebugLocation(118, 27);
					adaptor.AddChild(root_2, stream_p.NextTree());

					adaptor.AddChild(root_1, root_2);
					}
					DebugLocation(118, 30);
					// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:118:30: ^( SLIST ( $s1)* )
					{
					object root_2 = (object)adaptor.Nil();
					DebugLocation(118, 32);
					root_2 = (object)adaptor.BecomeRoot((object)adaptor.Create(SLIST, "SLIST"), root_2);

					DebugLocation(118, 39);
					// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:118:39: ( $s1)*
					while ( stream_s1.HasNext )
					{
						DebugLocation(118, 39);
						adaptor.AddChild(root_2, stream_s1.NextTree());

					}
					stream_s1.Reset();

					adaptor.AddChild(root_1, root_2);
					}

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			} finally { DebugExitSubRule(11); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
			if (state.backtracking == 0)
			{
				 paraphrases.Pop(); 
			}
		}

			catch (RecognitionException e) {
				throw e;
			}

		finally
		{
			TraceOut("if_stat", 9);
			LeaveRule("if_stat", 9);
			LeaveRule_if_stat();
		}
		DebugLocation(120, 1);
		} finally { DebugExitRule(GrammarFileName, "if_stat"); }
		return retval;

	}
	// $ANTLR end "if_stat"

	partial void EnterRule_senao_stat();
	partial void LeaveRule_senao_stat();

	// $ANTLR start "senao_stat"
	// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:122:1: senao_stat : 'senao' (s2+= statement )* 'fim' -> ^( SLIST ( statement )* ) ;
	[GrammarRule("senao_stat")]
	private AstParserRuleReturnScope<object, IToken> senao_stat()
	{
		EnterRule_senao_stat();
		EnterRule("senao_stat", 10);
		TraceIn("senao_stat", 10);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken string_literal36 = default(IToken);
		IToken string_literal37 = default(IToken);
		List<object> list_s2 = null;
		AstParserRuleReturnScope<object, IToken> s2 = default(AstParserRuleReturnScope<object, IToken>);
		object string_literal36_tree = default(object);
		object string_literal37_tree = default(object);
		RewriteRuleITokenStream stream_70=new RewriteRuleITokenStream(adaptor,"token 70");
		RewriteRuleITokenStream stream_63=new RewriteRuleITokenStream(adaptor,"token 63");
		RewriteRuleSubtreeStream stream_statement=new RewriteRuleSubtreeStream(adaptor,"rule statement");
		try { DebugEnterRule(GrammarFileName, "senao_stat");
		DebugLocation(122, 1);
		try
		{
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:123:2: ( 'senao' (s2+= statement )* 'fim' -> ^( SLIST ( statement )* ) )
			DebugEnterAlt(1);
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:123:4: 'senao' (s2+= statement )* 'fim'
			{
			DebugLocation(123, 4);
			string_literal36=(IToken)Match(input,70,Follow._70_in_senao_stat570); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_70.Add(string_literal36);

			DebugLocation(123, 14);
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:123:14: (s2+= statement )*
			try { DebugEnterSubRule(12);
			while (true)
			{
				int alt12=2;
				try { DebugEnterDecision(12, false);
				int LA12_0 = input.LA(1);

				if ((LA12_0==ID||LA12_0==39||LA12_0==61||(LA12_0>=66 && LA12_0<=69)||LA12_0==71))
				{
					alt12 = 1;
				}


				} finally { DebugExitDecision(12); }
				switch ( alt12 )
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:123:14: s2+= statement
					{
					DebugLocation(123, 14);
					PushFollow(Follow._statement_in_senao_stat574);
					s2=statement();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_statement.Add(s2.Tree);
					if (list_s2==null) list_s2=new List<object>();
					list_s2.Add(s2.Tree);


					}
					break;

				default:
					goto loop12;
				}
			}

			loop12:
				;

			} finally { DebugExitSubRule(12); }

			DebugLocation(123, 27);
			string_literal37=(IToken)Match(input,63,Follow._63_in_senao_stat577); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_63.Add(string_literal37);



			{
			// AST REWRITE
			// elements: statement
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 123:33: -> ^( SLIST ( statement )* )
			{
				DebugLocation(123, 36);
				// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:123:36: ^( SLIST ( statement )* )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(123, 38);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(SLIST, "SLIST"), root_1);

				DebugLocation(123, 44);
				// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:123:44: ( statement )*
				while ( stream_statement.HasNext )
				{
					DebugLocation(123, 44);
					adaptor.AddChild(root_1, stream_statement.NextTree());

				}
				stream_statement.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

			catch (RecognitionException e) {
				throw e;
			}

		finally
		{
			TraceOut("senao_stat", 10);
			LeaveRule("senao_stat", 10);
			LeaveRule_senao_stat();
		}
		DebugLocation(124, 1);
		} finally { DebugExitRule(GrammarFileName, "senao_stat"); }
		return retval;

	}
	// $ANTLR end "senao_stat"

	partial void EnterRule_for_stat();
	partial void LeaveRule_for_stat();

	// $ANTLR start "for_stat"
	// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:126:1: for_stat : 'para' assign_var 'ate' index ( 'dec' ( statement )* 'fim' -> ^( LOOP DEC assign_var index ^( SLIST ( statement )* ) ) | ( statement )* 'fim' -> ^( LOOP assign_var index ^( SLIST ( statement )* ) ) ) ;
	[GrammarRule("for_stat")]
	private AstParserRuleReturnScope<object, IToken> for_stat()
	{
		EnterRule_for_stat();
		EnterRule("for_stat", 11);
		TraceIn("for_stat", 11);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken string_literal38 = default(IToken);
		IToken string_literal40 = default(IToken);
		IToken string_literal42 = default(IToken);
		IToken string_literal44 = default(IToken);
		IToken string_literal46 = default(IToken);
		AstParserRuleReturnScope<object, IToken> assign_var39 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> index41 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> statement43 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> statement45 = default(AstParserRuleReturnScope<object, IToken>);

		object string_literal38_tree = default(object);
		object string_literal40_tree = default(object);
		object string_literal42_tree = default(object);
		object string_literal44_tree = default(object);
		object string_literal46_tree = default(object);
		RewriteRuleITokenStream stream_66=new RewriteRuleITokenStream(adaptor,"token 66");
		RewriteRuleITokenStream stream_59=new RewriteRuleITokenStream(adaptor,"token 59");
		RewriteRuleITokenStream stream_58=new RewriteRuleITokenStream(adaptor,"token 58");
		RewriteRuleITokenStream stream_63=new RewriteRuleITokenStream(adaptor,"token 63");
		RewriteRuleSubtreeStream stream_statement=new RewriteRuleSubtreeStream(adaptor,"rule statement");
		RewriteRuleSubtreeStream stream_index=new RewriteRuleSubtreeStream(adaptor,"rule index");
		RewriteRuleSubtreeStream stream_assign_var=new RewriteRuleSubtreeStream(adaptor,"rule assign_var");
		try { DebugEnterRule(GrammarFileName, "for_stat");
		DebugLocation(126, 1);
		try
		{
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:126:9: ( 'para' assign_var 'ate' index ( 'dec' ( statement )* 'fim' -> ^( LOOP DEC assign_var index ^( SLIST ( statement )* ) ) | ( statement )* 'fim' -> ^( LOOP assign_var index ^( SLIST ( statement )* ) ) ) )
			DebugEnterAlt(1);
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:126:11: 'para' assign_var 'ate' index ( 'dec' ( statement )* 'fim' -> ^( LOOP DEC assign_var index ^( SLIST ( statement )* ) ) | ( statement )* 'fim' -> ^( LOOP assign_var index ^( SLIST ( statement )* ) ) )
			{
			DebugLocation(126, 11);
			string_literal38=(IToken)Match(input,66,Follow._66_in_for_stat597); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_66.Add(string_literal38);

			DebugLocation(126, 18);
			PushFollow(Follow._assign_var_in_for_stat599);
			assign_var39=assign_var();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_assign_var.Add(assign_var39.Tree);
			DebugLocation(126, 29);
			string_literal40=(IToken)Match(input,58,Follow._58_in_for_stat601); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_58.Add(string_literal40);

			DebugLocation(126, 35);
			PushFollow(Follow._index_in_for_stat603);
			index41=index();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_index.Add(index41.Tree);
			DebugLocation(128, 3);
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:128:3: ( 'dec' ( statement )* 'fim' -> ^( LOOP DEC assign_var index ^( SLIST ( statement )* ) ) | ( statement )* 'fim' -> ^( LOOP assign_var index ^( SLIST ( statement )* ) ) )
			int alt15=2;
			try { DebugEnterSubRule(15);
			try { DebugEnterDecision(15, false);
			int LA15_0 = input.LA(1);

			if ((LA15_0==59))
			{
				alt15 = 1;
			}
			else if ((LA15_0==ID||LA15_0==39||LA15_0==61||LA15_0==63||(LA15_0>=66 && LA15_0<=69)||LA15_0==71))
			{
				alt15 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 15, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(15); }
			switch (alt15)
			{
			case 1:
				DebugEnterAlt(1);
				// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:128:5: 'dec' ( statement )* 'fim'
				{
				DebugLocation(128, 5);
				string_literal42=(IToken)Match(input,59,Follow._59_in_for_stat611); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_59.Add(string_literal42);

				DebugLocation(128, 11);
				// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:128:11: ( statement )*
				try { DebugEnterSubRule(13);
				while (true)
				{
					int alt13=2;
					try { DebugEnterDecision(13, false);
					int LA13_0 = input.LA(1);

					if ((LA13_0==ID||LA13_0==39||LA13_0==61||(LA13_0>=66 && LA13_0<=69)||LA13_0==71))
					{
						alt13 = 1;
					}


					} finally { DebugExitDecision(13); }
					switch ( alt13 )
					{
					case 1:
						DebugEnterAlt(1);
						// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:128:11: statement
						{
						DebugLocation(128, 11);
						PushFollow(Follow._statement_in_for_stat613);
						statement43=statement();
						PopFollow();
						if (state.failed) return retval;
						if (state.backtracking == 0) stream_statement.Add(statement43.Tree);

						}
						break;

					default:
						goto loop13;
					}
				}

				loop13:
					;

				} finally { DebugExitSubRule(13); }

				DebugLocation(128, 22);
				string_literal44=(IToken)Match(input,63,Follow._63_in_for_stat616); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_63.Add(string_literal44);



				{
				// AST REWRITE
				// elements: assign_var, statement, index
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 128:28: -> ^( LOOP DEC assign_var index ^( SLIST ( statement )* ) )
				{
					DebugLocation(128, 31);
					// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:128:31: ^( LOOP DEC assign_var index ^( SLIST ( statement )* ) )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(128, 33);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(LOOP, "LOOP"), root_1);

					DebugLocation(128, 38);
					adaptor.AddChild(root_1, (object)adaptor.Create(DEC, "DEC"));
					DebugLocation(128, 42);
					adaptor.AddChild(root_1, stream_assign_var.NextTree());
					DebugLocation(128, 53);
					adaptor.AddChild(root_1, stream_index.NextTree());
					DebugLocation(128, 59);
					// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:128:59: ^( SLIST ( statement )* )
					{
					object root_2 = (object)adaptor.Nil();
					DebugLocation(128, 61);
					root_2 = (object)adaptor.BecomeRoot((object)adaptor.Create(SLIST, "SLIST"), root_2);

					DebugLocation(128, 67);
					// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:128:67: ( statement )*
					while ( stream_statement.HasNext )
					{
						DebugLocation(128, 67);
						adaptor.AddChild(root_2, stream_statement.NextTree());

					}
					stream_statement.Reset();

					adaptor.AddChild(root_1, root_2);
					}

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:129:5: ( statement )* 'fim'
				{
				DebugLocation(129, 5);
				// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:129:5: ( statement )*
				try { DebugEnterSubRule(14);
				while (true)
				{
					int alt14=2;
					try { DebugEnterDecision(14, false);
					int LA14_0 = input.LA(1);

					if ((LA14_0==ID||LA14_0==39||LA14_0==61||(LA14_0>=66 && LA14_0<=69)||LA14_0==71))
					{
						alt14 = 1;
					}


					} finally { DebugExitDecision(14); }
					switch ( alt14 )
					{
					case 1:
						DebugEnterAlt(1);
						// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:129:5: statement
						{
						DebugLocation(129, 5);
						PushFollow(Follow._statement_in_for_stat641);
						statement45=statement();
						PopFollow();
						if (state.failed) return retval;
						if (state.backtracking == 0) stream_statement.Add(statement45.Tree);

						}
						break;

					default:
						goto loop14;
					}
				}

				loop14:
					;

				} finally { DebugExitSubRule(14); }

				DebugLocation(129, 16);
				string_literal46=(IToken)Match(input,63,Follow._63_in_for_stat644); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_63.Add(string_literal46);



				{
				// AST REWRITE
				// elements: statement, index, assign_var
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 129:22: -> ^( LOOP assign_var index ^( SLIST ( statement )* ) )
				{
					DebugLocation(129, 25);
					// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:129:25: ^( LOOP assign_var index ^( SLIST ( statement )* ) )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(129, 27);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(LOOP, "LOOP"), root_1);

					DebugLocation(129, 32);
					adaptor.AddChild(root_1, stream_assign_var.NextTree());
					DebugLocation(129, 43);
					adaptor.AddChild(root_1, stream_index.NextTree());
					DebugLocation(129, 49);
					// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:129:49: ^( SLIST ( statement )* )
					{
					object root_2 = (object)adaptor.Nil();
					DebugLocation(129, 51);
					root_2 = (object)adaptor.BecomeRoot((object)adaptor.Create(SLIST, "SLIST"), root_2);

					DebugLocation(129, 57);
					// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:129:57: ( statement )*
					while ( stream_statement.HasNext )
					{
						DebugLocation(129, 57);
						adaptor.AddChild(root_2, stream_statement.NextTree());

					}
					stream_statement.Reset();

					adaptor.AddChild(root_1, root_2);
					}

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			} finally { DebugExitSubRule(15); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

			catch (RecognitionException e) {
				throw e;
			}

		finally
		{
			TraceOut("for_stat", 11);
			LeaveRule("for_stat", 11);
			LeaveRule_for_stat();
		}
		DebugLocation(131, 1);
		} finally { DebugExitRule(GrammarFileName, "for_stat"); }
		return retval;

	}
	// $ANTLR end "for_stat"

	partial void EnterRule_while_stat();
	partial void LeaveRule_while_stat();

	// $ANTLR start "while_stat"
	// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:133:1: while_stat : 'enquanto' logic_expression ( statement )* 'fim' -> ^( LOOP ^( LEXP logic_expression ) ^( SLIST ( statement )* ) ) ;
	[GrammarRule("while_stat")]
	private AstParserRuleReturnScope<object, IToken> while_stat()
	{
		EnterRule_while_stat();
		EnterRule("while_stat", 12);
		TraceIn("while_stat", 12);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken string_literal47 = default(IToken);
		IToken string_literal50 = default(IToken);
		AstParserRuleReturnScope<object, IToken> logic_expression48 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> statement49 = default(AstParserRuleReturnScope<object, IToken>);

		object string_literal47_tree = default(object);
		object string_literal50_tree = default(object);
		RewriteRuleITokenStream stream_63=new RewriteRuleITokenStream(adaptor,"token 63");
		RewriteRuleITokenStream stream_61=new RewriteRuleITokenStream(adaptor,"token 61");
		RewriteRuleSubtreeStream stream_statement=new RewriteRuleSubtreeStream(adaptor,"rule statement");
		RewriteRuleSubtreeStream stream_logic_expression=new RewriteRuleSubtreeStream(adaptor,"rule logic_expression");
		try { DebugEnterRule(GrammarFileName, "while_stat");
		DebugLocation(133, 1);
		try
		{
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:134:2: ( 'enquanto' logic_expression ( statement )* 'fim' -> ^( LOOP ^( LEXP logic_expression ) ^( SLIST ( statement )* ) ) )
			DebugEnterAlt(1);
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:134:4: 'enquanto' logic_expression ( statement )* 'fim'
			{
			DebugLocation(134, 4);
			string_literal47=(IToken)Match(input,61,Follow._61_in_while_stat677); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_61.Add(string_literal47);

			DebugLocation(134, 15);
			PushFollow(Follow._logic_expression_in_while_stat679);
			logic_expression48=logic_expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_logic_expression.Add(logic_expression48.Tree);
			DebugLocation(134, 32);
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:134:32: ( statement )*
			try { DebugEnterSubRule(16);
			while (true)
			{
				int alt16=2;
				try { DebugEnterDecision(16, false);
				int LA16_0 = input.LA(1);

				if ((LA16_0==ID||LA16_0==39||LA16_0==61||(LA16_0>=66 && LA16_0<=69)||LA16_0==71))
				{
					alt16 = 1;
				}


				} finally { DebugExitDecision(16); }
				switch ( alt16 )
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:134:32: statement
					{
					DebugLocation(134, 32);
					PushFollow(Follow._statement_in_while_stat681);
					statement49=statement();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_statement.Add(statement49.Tree);

					}
					break;

				default:
					goto loop16;
				}
			}

			loop16:
				;

			} finally { DebugExitSubRule(16); }

			DebugLocation(134, 43);
			string_literal50=(IToken)Match(input,63,Follow._63_in_while_stat684); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_63.Add(string_literal50);



			{
			// AST REWRITE
			// elements: statement, logic_expression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 135:3: -> ^( LOOP ^( LEXP logic_expression ) ^( SLIST ( statement )* ) )
			{
				DebugLocation(135, 6);
				// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:135:6: ^( LOOP ^( LEXP logic_expression ) ^( SLIST ( statement )* ) )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(135, 8);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(LOOP, "LOOP"), root_1);

				DebugLocation(135, 13);
				// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:135:13: ^( LEXP logic_expression )
				{
				object root_2 = (object)adaptor.Nil();
				DebugLocation(135, 15);
				root_2 = (object)adaptor.BecomeRoot((object)adaptor.Create(LEXP, "LEXP"), root_2);

				DebugLocation(135, 20);
				adaptor.AddChild(root_2, stream_logic_expression.NextTree());

				adaptor.AddChild(root_1, root_2);
				}
				DebugLocation(135, 38);
				// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:135:38: ^( SLIST ( statement )* )
				{
				object root_2 = (object)adaptor.Nil();
				DebugLocation(135, 40);
				root_2 = (object)adaptor.BecomeRoot((object)adaptor.Create(SLIST, "SLIST"), root_2);

				DebugLocation(135, 46);
				// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:135:46: ( statement )*
				while ( stream_statement.HasNext )
				{
					DebugLocation(135, 46);
					adaptor.AddChild(root_2, stream_statement.NextTree());

				}
				stream_statement.Reset();

				adaptor.AddChild(root_1, root_2);
				}

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

			catch (RecognitionException e) {
				throw e;
			}

		finally
		{
			TraceOut("while_stat", 12);
			LeaveRule("while_stat", 12);
			LeaveRule_while_stat();
		}
		DebugLocation(136, 1);
		} finally { DebugExitRule(GrammarFileName, "while_stat"); }
		return retval;

	}
	// $ANTLR end "while_stat"

	partial void EnterRule_repeat_stat();
	partial void LeaveRule_repeat_stat();

	// $ANTLR start "repeat_stat"
	// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:138:1: repeat_stat : 'repita' ( statement )* 'ate' logic_expression -> ^( LOOP ^( SLIST ( statement )* ) ^( LEXP logic_expression ) ) ;
	[GrammarRule("repeat_stat")]
	private AstParserRuleReturnScope<object, IToken> repeat_stat()
	{
		EnterRule_repeat_stat();
		EnterRule("repeat_stat", 13);
		TraceIn("repeat_stat", 13);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken string_literal51 = default(IToken);
		IToken string_literal53 = default(IToken);
		AstParserRuleReturnScope<object, IToken> statement52 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> logic_expression54 = default(AstParserRuleReturnScope<object, IToken>);

		object string_literal51_tree = default(object);
		object string_literal53_tree = default(object);
		RewriteRuleITokenStream stream_67=new RewriteRuleITokenStream(adaptor,"token 67");
		RewriteRuleITokenStream stream_58=new RewriteRuleITokenStream(adaptor,"token 58");
		RewriteRuleSubtreeStream stream_statement=new RewriteRuleSubtreeStream(adaptor,"rule statement");
		RewriteRuleSubtreeStream stream_logic_expression=new RewriteRuleSubtreeStream(adaptor,"rule logic_expression");
		try { DebugEnterRule(GrammarFileName, "repeat_stat");
		DebugLocation(138, 1);
		try
		{
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:138:13: ( 'repita' ( statement )* 'ate' logic_expression -> ^( LOOP ^( SLIST ( statement )* ) ^( LEXP logic_expression ) ) )
			DebugEnterAlt(1);
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:138:15: 'repita' ( statement )* 'ate' logic_expression
			{
			DebugLocation(138, 15);
			string_literal51=(IToken)Match(input,67,Follow._67_in_repeat_stat716); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_67.Add(string_literal51);

			DebugLocation(138, 24);
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:138:24: ( statement )*
			try { DebugEnterSubRule(17);
			while (true)
			{
				int alt17=2;
				try { DebugEnterDecision(17, false);
				int LA17_0 = input.LA(1);

				if ((LA17_0==ID||LA17_0==39||LA17_0==61||(LA17_0>=66 && LA17_0<=69)||LA17_0==71))
				{
					alt17 = 1;
				}


				} finally { DebugExitDecision(17); }
				switch ( alt17 )
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:138:24: statement
					{
					DebugLocation(138, 24);
					PushFollow(Follow._statement_in_repeat_stat718);
					statement52=statement();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_statement.Add(statement52.Tree);

					}
					break;

				default:
					goto loop17;
				}
			}

			loop17:
				;

			} finally { DebugExitSubRule(17); }

			DebugLocation(138, 35);
			string_literal53=(IToken)Match(input,58,Follow._58_in_repeat_stat721); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_58.Add(string_literal53);

			DebugLocation(138, 41);
			PushFollow(Follow._logic_expression_in_repeat_stat723);
			logic_expression54=logic_expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_logic_expression.Add(logic_expression54.Tree);


			{
			// AST REWRITE
			// elements: logic_expression, statement
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 139:3: -> ^( LOOP ^( SLIST ( statement )* ) ^( LEXP logic_expression ) )
			{
				DebugLocation(139, 6);
				// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:139:6: ^( LOOP ^( SLIST ( statement )* ) ^( LEXP logic_expression ) )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(139, 8);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(LOOP, "LOOP"), root_1);

				DebugLocation(139, 13);
				// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:139:13: ^( SLIST ( statement )* )
				{
				object root_2 = (object)adaptor.Nil();
				DebugLocation(139, 15);
				root_2 = (object)adaptor.BecomeRoot((object)adaptor.Create(SLIST, "SLIST"), root_2);

				DebugLocation(139, 21);
				// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:139:21: ( statement )*
				while ( stream_statement.HasNext )
				{
					DebugLocation(139, 21);
					adaptor.AddChild(root_2, stream_statement.NextTree());

				}
				stream_statement.Reset();

				adaptor.AddChild(root_1, root_2);
				}
				DebugLocation(139, 33);
				// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:139:33: ^( LEXP logic_expression )
				{
				object root_2 = (object)adaptor.Nil();
				DebugLocation(139, 35);
				root_2 = (object)adaptor.BecomeRoot((object)adaptor.Create(LEXP, "LEXP"), root_2);

				DebugLocation(139, 40);
				adaptor.AddChild(root_2, stream_logic_expression.NextTree());

				adaptor.AddChild(root_1, root_2);
				}

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

			catch (RecognitionException e) {
				throw e;
			}

		finally
		{
			TraceOut("repeat_stat", 13);
			LeaveRule("repeat_stat", 13);
			LeaveRule_repeat_stat();
		}
		DebugLocation(140, 1);
		} finally { DebugExitRule(GrammarFileName, "repeat_stat"); }
		return retval;

	}
	// $ANTLR end "repeat_stat"

	partial void EnterRule_function_call();
	partial void LeaveRule_function_call();

	// $ANTLR start "function_call"
	// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:142:1: function_call : ID '(' ( function_arg_list )* ')' -> ^( CALL ID ( function_arg_list )* ) ;
	[GrammarRule("function_call")]
	private AstParserRuleReturnScope<object, IToken> function_call()
	{
		EnterRule_function_call();
		EnterRule("function_call", 14);
		TraceIn("function_call", 14);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken ID55 = default(IToken);
		IToken char_literal56 = default(IToken);
		IToken char_literal58 = default(IToken);
		AstParserRuleReturnScope<object, IToken> function_arg_list57 = default(AstParserRuleReturnScope<object, IToken>);

		object ID55_tree = default(object);
		object char_literal56_tree = default(object);
		object char_literal58_tree = default(object);
		RewriteRuleITokenStream stream_42=new RewriteRuleITokenStream(adaptor,"token 42");
		RewriteRuleITokenStream stream_41=new RewriteRuleITokenStream(adaptor,"token 41");
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleSubtreeStream stream_function_arg_list=new RewriteRuleSubtreeStream(adaptor,"rule function_arg_list");
		 paraphrases.Push("na chamada de função"); 
		try { DebugEnterRule(GrammarFileName, "function_call");
		DebugLocation(142, 1);
		try
		{
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:143:2: ( ID '(' ( function_arg_list )* ')' -> ^( CALL ID ( function_arg_list )* ) )
			DebugEnterAlt(1);
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:143:4: ID '(' ( function_arg_list )* ')'
			{
			DebugLocation(143, 4);
			ID55=(IToken)Match(input,ID,Follow._ID_in_function_call771); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ID.Add(ID55);

			DebugLocation(143, 7);
			char_literal56=(IToken)Match(input,41,Follow._41_in_function_call773); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_41.Add(char_literal56);

			DebugLocation(143, 11);
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:143:11: ( function_arg_list )*
			try { DebugEnterSubRule(18);
			while (true)
			{
				int alt18=2;
				try { DebugEnterDecision(18, false);
				int LA18_0 = input.LA(1);

				if ((LA18_0==FLOAT||LA18_0==ID||LA18_0==INT||LA18_0==STRING||LA18_0==41))
				{
					alt18 = 1;
				}


				} finally { DebugExitDecision(18); }
				switch ( alt18 )
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:143:11: function_arg_list
					{
					DebugLocation(143, 11);
					PushFollow(Follow._function_arg_list_in_function_call775);
					function_arg_list57=function_arg_list();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_function_arg_list.Add(function_arg_list57.Tree);

					}
					break;

				default:
					goto loop18;
				}
			}

			loop18:
				;

			} finally { DebugExitSubRule(18); }

			DebugLocation(143, 30);
			char_literal58=(IToken)Match(input,42,Follow._42_in_function_call778); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_42.Add(char_literal58);



			{
			// AST REWRITE
			// elements: function_arg_list, ID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 143:34: -> ^( CALL ID ( function_arg_list )* )
			{
				DebugLocation(143, 37);
				// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:143:37: ^( CALL ID ( function_arg_list )* )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(143, 39);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(CALL, "CALL"), root_1);

				DebugLocation(143, 44);
				adaptor.AddChild(root_1, stream_ID.NextNode());
				DebugLocation(143, 47);
				// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:143:47: ( function_arg_list )*
				while ( stream_function_arg_list.HasNext )
				{
					DebugLocation(143, 47);
					adaptor.AddChild(root_1, stream_function_arg_list.NextTree());

				}
				stream_function_arg_list.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
			if (state.backtracking == 0)
			{
				 paraphrases.Pop(); 
			}
		}

			catch (RecognitionException e) {
				throw e;
			}

		finally
		{
			TraceOut("function_call", 14);
			LeaveRule("function_call", 14);
			LeaveRule_function_call();
		}
		DebugLocation(144, 1);
		} finally { DebugExitRule(GrammarFileName, "function_call"); }
		return retval;

	}
	// $ANTLR end "function_call"

	partial void EnterRule_property_call();
	partial void LeaveRule_property_call();

	// $ANTLR start "property_call"
	// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:146:1: property_call : o= ID '.' p= ID -> ^( PCALL $o $p) ;
	[GrammarRule("property_call")]
	private AstParserRuleReturnScope<object, IToken> property_call()
	{
		EnterRule_property_call();
		EnterRule("property_call", 15);
		TraceIn("property_call", 15);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken o = default(IToken);
		IToken p = default(IToken);
		IToken char_literal59 = default(IToken);

		object o_tree = default(object);
		object p_tree = default(object);
		object char_literal59_tree = default(object);
		RewriteRuleITokenStream stream_47=new RewriteRuleITokenStream(adaptor,"token 47");
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		 paraphrases.Push("na chamada de propriedade"); 
		try { DebugEnterRule(GrammarFileName, "property_call");
		DebugLocation(146, 1);
		try
		{
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:147:2: (o= ID '.' p= ID -> ^( PCALL $o $p) )
			DebugEnterAlt(1);
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:147:4: o= ID '.' p= ID
			{
			DebugLocation(147, 5);
			o=(IToken)Match(input,ID,Follow._ID_in_property_call819); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ID.Add(o);

			DebugLocation(147, 8);
			char_literal59=(IToken)Match(input,47,Follow._47_in_property_call820); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_47.Add(char_literal59);

			DebugLocation(147, 12);
			p=(IToken)Match(input,ID,Follow._ID_in_property_call823); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ID.Add(p);



			{
			// AST REWRITE
			// elements: p, o
			// token labels: p, o
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleITokenStream stream_p=new RewriteRuleITokenStream(adaptor,"token p",p);
			RewriteRuleITokenStream stream_o=new RewriteRuleITokenStream(adaptor,"token o",o);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 147:17: -> ^( PCALL $o $p)
			{
				DebugLocation(147, 20);
				// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:147:20: ^( PCALL $o $p)
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(147, 22);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(PCALL, "PCALL"), root_1);

				DebugLocation(147, 29);
				adaptor.AddChild(root_1, stream_o.NextNode());
				DebugLocation(147, 32);
				adaptor.AddChild(root_1, stream_p.NextNode());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
			if (state.backtracking == 0)
			{
				 paraphrases.Pop(); 
			}
		}

			catch (RecognitionException e) {
				throw e;
			}

		finally
		{
			TraceOut("property_call", 15);
			LeaveRule("property_call", 15);
			LeaveRule_property_call();
		}
		DebugLocation(148, 1);
		} finally { DebugExitRule(GrammarFileName, "property_call"); }
		return retval;

	}
	// $ANTLR end "property_call"

	partial void EnterRule_method_call();
	partial void LeaveRule_method_call();

	// $ANTLR start "method_call"
	// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:150:1: method_call : o= ID '.' p= ID '(' ( function_arg_list )* ')' -> ^( MCALL $o $p ( function_arg_list )* ) ;
	[GrammarRule("method_call")]
	private AstParserRuleReturnScope<object, IToken> method_call()
	{
		EnterRule_method_call();
		EnterRule("method_call", 16);
		TraceIn("method_call", 16);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken o = default(IToken);
		IToken p = default(IToken);
		IToken char_literal60 = default(IToken);
		IToken char_literal61 = default(IToken);
		IToken char_literal63 = default(IToken);
		AstParserRuleReturnScope<object, IToken> function_arg_list62 = default(AstParserRuleReturnScope<object, IToken>);

		object o_tree = default(object);
		object p_tree = default(object);
		object char_literal60_tree = default(object);
		object char_literal61_tree = default(object);
		object char_literal63_tree = default(object);
		RewriteRuleITokenStream stream_42=new RewriteRuleITokenStream(adaptor,"token 42");
		RewriteRuleITokenStream stream_47=new RewriteRuleITokenStream(adaptor,"token 47");
		RewriteRuleITokenStream stream_41=new RewriteRuleITokenStream(adaptor,"token 41");
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleSubtreeStream stream_function_arg_list=new RewriteRuleSubtreeStream(adaptor,"rule function_arg_list");
		 paraphrases.Push("na chamada de propriedade"); 
		try { DebugEnterRule(GrammarFileName, "method_call");
		DebugLocation(150, 1);
		try
		{
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:151:2: (o= ID '.' p= ID '(' ( function_arg_list )* ')' -> ^( MCALL $o $p ( function_arg_list )* ) )
			DebugEnterAlt(1);
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:151:4: o= ID '.' p= ID '(' ( function_arg_list )* ')'
			{
			DebugLocation(151, 5);
			o=(IToken)Match(input,ID,Follow._ID_in_method_call867); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ID.Add(o);

			DebugLocation(151, 8);
			char_literal60=(IToken)Match(input,47,Follow._47_in_method_call868); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_47.Add(char_literal60);

			DebugLocation(151, 12);
			p=(IToken)Match(input,ID,Follow._ID_in_method_call871); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ID.Add(p);

			DebugLocation(151, 16);
			char_literal61=(IToken)Match(input,41,Follow._41_in_method_call873); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_41.Add(char_literal61);

			DebugLocation(151, 20);
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:151:20: ( function_arg_list )*
			try { DebugEnterSubRule(19);
			while (true)
			{
				int alt19=2;
				try { DebugEnterDecision(19, false);
				int LA19_0 = input.LA(1);

				if ((LA19_0==FLOAT||LA19_0==ID||LA19_0==INT||LA19_0==STRING||LA19_0==41))
				{
					alt19 = 1;
				}


				} finally { DebugExitDecision(19); }
				switch ( alt19 )
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:151:20: function_arg_list
					{
					DebugLocation(151, 20);
					PushFollow(Follow._function_arg_list_in_method_call875);
					function_arg_list62=function_arg_list();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_function_arg_list.Add(function_arg_list62.Tree);

					}
					break;

				default:
					goto loop19;
				}
			}

			loop19:
				;

			} finally { DebugExitSubRule(19); }

			DebugLocation(151, 39);
			char_literal63=(IToken)Match(input,42,Follow._42_in_method_call878); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_42.Add(char_literal63);



			{
			// AST REWRITE
			// elements: o, p, function_arg_list
			// token labels: p, o
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleITokenStream stream_p=new RewriteRuleITokenStream(adaptor,"token p",p);
			RewriteRuleITokenStream stream_o=new RewriteRuleITokenStream(adaptor,"token o",o);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 151:43: -> ^( MCALL $o $p ( function_arg_list )* )
			{
				DebugLocation(151, 46);
				// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:151:46: ^( MCALL $o $p ( function_arg_list )* )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(151, 48);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(MCALL, "MCALL"), root_1);

				DebugLocation(151, 55);
				adaptor.AddChild(root_1, stream_o.NextNode());
				DebugLocation(151, 58);
				adaptor.AddChild(root_1, stream_p.NextNode());
				DebugLocation(151, 60);
				// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:151:60: ( function_arg_list )*
				while ( stream_function_arg_list.HasNext )
				{
					DebugLocation(151, 60);
					adaptor.AddChild(root_1, stream_function_arg_list.NextTree());

				}
				stream_function_arg_list.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
			if (state.backtracking == 0)
			{
				 paraphrases.Pop(); 
			}
		}

			catch (RecognitionException e) {
				throw e;
			}

		finally
		{
			TraceOut("method_call", 16);
			LeaveRule("method_call", 16);
			LeaveRule_method_call();
		}
		DebugLocation(152, 1);
		} finally { DebugExitRule(GrammarFileName, "method_call"); }
		return retval;

	}
	// $ANTLR end "method_call"

	partial void EnterRule_function_arg_list();
	partial void LeaveRule_function_arg_list();

	// $ANTLR start "function_arg_list"
	// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:154:1: function_arg_list : plus_expression ( ',' plus_expression )* -> ^( ARG ( plus_expression )* ) ;
	[GrammarRule("function_arg_list")]
	private AstParserRuleReturnScope<object, IToken> function_arg_list()
	{
		EnterRule_function_arg_list();
		EnterRule("function_arg_list", 17);
		TraceIn("function_arg_list", 17);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken char_literal65 = default(IToken);
		AstParserRuleReturnScope<object, IToken> plus_expression64 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> plus_expression66 = default(AstParserRuleReturnScope<object, IToken>);

		object char_literal65_tree = default(object);
		RewriteRuleITokenStream stream_45=new RewriteRuleITokenStream(adaptor,"token 45");
		RewriteRuleSubtreeStream stream_plus_expression=new RewriteRuleSubtreeStream(adaptor,"rule plus_expression");
		 paraphrases.Push("nos argumentos da função"); 
		try { DebugEnterRule(GrammarFileName, "function_arg_list");
		DebugLocation(154, 1);
		try
		{
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:156:2: ( plus_expression ( ',' plus_expression )* -> ^( ARG ( plus_expression )* ) )
			DebugEnterAlt(1);
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:156:4: plus_expression ( ',' plus_expression )*
			{
			DebugLocation(156, 4);
			PushFollow(Follow._plus_expression_in_function_arg_list923);
			plus_expression64=plus_expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_plus_expression.Add(plus_expression64.Tree);
			DebugLocation(156, 20);
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:156:20: ( ',' plus_expression )*
			try { DebugEnterSubRule(20);
			while (true)
			{
				int alt20=2;
				try { DebugEnterDecision(20, false);
				int LA20_0 = input.LA(1);

				if ((LA20_0==45))
				{
					alt20 = 1;
				}


				} finally { DebugExitDecision(20); }
				switch ( alt20 )
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:156:21: ',' plus_expression
					{
					DebugLocation(156, 21);
					char_literal65=(IToken)Match(input,45,Follow._45_in_function_arg_list926); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_45.Add(char_literal65);

					DebugLocation(156, 25);
					PushFollow(Follow._plus_expression_in_function_arg_list928);
					plus_expression66=plus_expression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_plus_expression.Add(plus_expression66.Tree);

					}
					break;

				default:
					goto loop20;
				}
			}

			loop20:
				;

			} finally { DebugExitSubRule(20); }



			{
			// AST REWRITE
			// elements: plus_expression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 156:43: -> ^( ARG ( plus_expression )* )
			{
				DebugLocation(156, 46);
				// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:156:46: ^( ARG ( plus_expression )* )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(156, 48);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(ARG, "ARG"), root_1);

				DebugLocation(156, 52);
				// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:156:52: ( plus_expression )*
				while ( stream_plus_expression.HasNext )
				{
					DebugLocation(156, 52);
					adaptor.AddChild(root_1, stream_plus_expression.NextTree());

				}
				stream_plus_expression.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
			if (state.backtracking == 0)
			{
				 paraphrases.Pop(); 
			}
		}

			catch (RecognitionException e) {
				throw e;
			}

		finally
		{
			TraceOut("function_arg_list", 17);
			LeaveRule("function_arg_list", 17);
			LeaveRule_function_arg_list();
		}
		DebugLocation(157, 1);
		} finally { DebugExitRule(GrammarFileName, "function_arg_list"); }
		return retval;

	}
	// $ANTLR end "function_arg_list"

	partial void EnterRule_assign_var();
	partial void LeaveRule_assign_var();

	// $ANTLR start "assign_var"
	// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:159:1: assign_var : ( ID '=' '[' INT '..' INT ']' -> ^( ASGN ID INT INT ) | ID '=' '{' INT ( ',' INT )* '}' -> ^( ASGN ID ^( ILIST ( INT )* ) ) | ID '[' index ']' '=' assign_expression -> ^( ASGN ^( AR index ) ID assign_expression ) | ID '=' assign_expression -> ^( ASGN ID assign_expression ) );
	[GrammarRule("assign_var")]
	private AstParserRuleReturnScope<object, IToken> assign_var()
	{
		EnterRule_assign_var();
		EnterRule("assign_var", 18);
		TraceIn("assign_var", 18);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken ID67 = default(IToken);
		IToken char_literal68 = default(IToken);
		IToken char_literal69 = default(IToken);
		IToken INT70 = default(IToken);
		IToken string_literal71 = default(IToken);
		IToken INT72 = default(IToken);
		IToken char_literal73 = default(IToken);
		IToken ID74 = default(IToken);
		IToken char_literal75 = default(IToken);
		IToken char_literal76 = default(IToken);
		IToken INT77 = default(IToken);
		IToken char_literal78 = default(IToken);
		IToken INT79 = default(IToken);
		IToken char_literal80 = default(IToken);
		IToken ID81 = default(IToken);
		IToken char_literal82 = default(IToken);
		IToken char_literal84 = default(IToken);
		IToken char_literal85 = default(IToken);
		IToken ID87 = default(IToken);
		IToken char_literal88 = default(IToken);
		AstParserRuleReturnScope<object, IToken> index83 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> assign_expression86 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> assign_expression89 = default(AstParserRuleReturnScope<object, IToken>);

		object ID67_tree = default(object);
		object char_literal68_tree = default(object);
		object char_literal69_tree = default(object);
		object INT70_tree = default(object);
		object string_literal71_tree = default(object);
		object INT72_tree = default(object);
		object char_literal73_tree = default(object);
		object ID74_tree = default(object);
		object char_literal75_tree = default(object);
		object char_literal76_tree = default(object);
		object INT77_tree = default(object);
		object char_literal78_tree = default(object);
		object INT79_tree = default(object);
		object char_literal80_tree = default(object);
		object ID81_tree = default(object);
		object char_literal82_tree = default(object);
		object char_literal84_tree = default(object);
		object char_literal85_tree = default(object);
		object ID87_tree = default(object);
		object char_literal88_tree = default(object);
		RewriteRuleITokenStream stream_48=new RewriteRuleITokenStream(adaptor,"token 48");
		RewriteRuleITokenStream stream_45=new RewriteRuleITokenStream(adaptor,"token 45");
		RewriteRuleITokenStream stream_INT=new RewriteRuleITokenStream(adaptor,"token INT");
		RewriteRuleITokenStream stream_57=new RewriteRuleITokenStream(adaptor,"token 57");
		RewriteRuleITokenStream stream_56=new RewriteRuleITokenStream(adaptor,"token 56");
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleITokenStream stream_52=new RewriteRuleITokenStream(adaptor,"token 52");
		RewriteRuleITokenStream stream_72=new RewriteRuleITokenStream(adaptor,"token 72");
		RewriteRuleITokenStream stream_73=new RewriteRuleITokenStream(adaptor,"token 73");
		RewriteRuleSubtreeStream stream_assign_expression=new RewriteRuleSubtreeStream(adaptor,"rule assign_expression");
		RewriteRuleSubtreeStream stream_index=new RewriteRuleSubtreeStream(adaptor,"rule index");
		 paraphrases.Push("na atribuição de variável"); 
		try { DebugEnterRule(GrammarFileName, "assign_var");
		DebugLocation(159, 1);
		try
		{
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:160:2: ( ID '=' '[' INT '..' INT ']' -> ^( ASGN ID INT INT ) | ID '=' '{' INT ( ',' INT )* '}' -> ^( ASGN ID ^( ILIST ( INT )* ) ) | ID '[' index ']' '=' assign_expression -> ^( ASGN ^( AR index ) ID assign_expression ) | ID '=' assign_expression -> ^( ASGN ID assign_expression ) )
			int alt22=4;
			try { DebugEnterDecision(22, false);
			int LA22_0 = input.LA(1);

			if ((LA22_0==ID))
			{
				int LA22_1 = input.LA(2);

				if ((LA22_1==52))
				{
					int LA22_2 = input.LA(3);

					if ((EvaluatePredicate(synpred28_NPortugol_fragment)))
					{
						alt22 = 1;
					}
					else if ((EvaluatePredicate(synpred30_NPortugol_fragment)))
					{
						alt22 = 2;
					}
					else if ((true))
					{
						alt22 = 4;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 22, 2, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}
				else if ((LA22_1==56))
				{
					alt22 = 3;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 22, 1, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 22, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(22); }
			switch (alt22)
			{
			case 1:
				DebugEnterAlt(1);
				// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:161:9: ID '=' '[' INT '..' INT ']'
				{
				DebugLocation(161, 9);
				ID67=(IToken)Match(input,ID,Follow._ID_in_assign_var980); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_ID.Add(ID67);

				DebugLocation(161, 12);
				char_literal68=(IToken)Match(input,52,Follow._52_in_assign_var982); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_52.Add(char_literal68);

				DebugLocation(161, 16);
				char_literal69=(IToken)Match(input,56,Follow._56_in_assign_var984); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_56.Add(char_literal69);

				DebugLocation(161, 20);
				INT70=(IToken)Match(input,INT,Follow._INT_in_assign_var986); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_INT.Add(INT70);

				DebugLocation(161, 24);
				string_literal71=(IToken)Match(input,48,Follow._48_in_assign_var988); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_48.Add(string_literal71);

				DebugLocation(161, 29);
				INT72=(IToken)Match(input,INT,Follow._INT_in_assign_var990); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_INT.Add(INT72);

				DebugLocation(161, 33);
				char_literal73=(IToken)Match(input,57,Follow._57_in_assign_var992); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_57.Add(char_literal73);



				{
				// AST REWRITE
				// elements: INT, ID, INT
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 161:37: -> ^( ASGN ID INT INT )
				{
					DebugLocation(161, 40);
					// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:161:40: ^( ASGN ID INT INT )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(161, 42);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(ASGN, "ASGN"), root_1);

					DebugLocation(161, 47);
					adaptor.AddChild(root_1, stream_ID.NextNode());
					DebugLocation(161, 50);
					adaptor.AddChild(root_1, stream_INT.NextNode());
					DebugLocation(161, 54);
					adaptor.AddChild(root_1, stream_INT.NextNode());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:162:10: ID '=' '{' INT ( ',' INT )* '}'
				{
				DebugLocation(162, 10);
				ID74=(IToken)Match(input,ID,Follow._ID_in_assign_var1015); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_ID.Add(ID74);

				DebugLocation(162, 13);
				char_literal75=(IToken)Match(input,52,Follow._52_in_assign_var1017); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_52.Add(char_literal75);

				DebugLocation(162, 17);
				char_literal76=(IToken)Match(input,72,Follow._72_in_assign_var1019); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_72.Add(char_literal76);

				DebugLocation(162, 21);
				INT77=(IToken)Match(input,INT,Follow._INT_in_assign_var1021); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_INT.Add(INT77);

				DebugLocation(162, 25);
				// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:162:25: ( ',' INT )*
				try { DebugEnterSubRule(21);
				while (true)
				{
					int alt21=2;
					try { DebugEnterDecision(21, false);
					int LA21_0 = input.LA(1);

					if ((LA21_0==45))
					{
						alt21 = 1;
					}


					} finally { DebugExitDecision(21); }
					switch ( alt21 )
					{
					case 1:
						DebugEnterAlt(1);
						// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:162:26: ',' INT
						{
						DebugLocation(162, 26);
						char_literal78=(IToken)Match(input,45,Follow._45_in_assign_var1024); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_45.Add(char_literal78);

						DebugLocation(162, 30);
						INT79=(IToken)Match(input,INT,Follow._INT_in_assign_var1026); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_INT.Add(INT79);


						}
						break;

					default:
						goto loop21;
					}
				}

				loop21:
					;

				} finally { DebugExitSubRule(21); }

				DebugLocation(162, 36);
				char_literal80=(IToken)Match(input,73,Follow._73_in_assign_var1030); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_73.Add(char_literal80);



				{
				// AST REWRITE
				// elements: ID, INT
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 162:40: -> ^( ASGN ID ^( ILIST ( INT )* ) )
				{
					DebugLocation(162, 43);
					// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:162:43: ^( ASGN ID ^( ILIST ( INT )* ) )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(162, 45);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(ASGN, "ASGN"), root_1);

					DebugLocation(162, 50);
					adaptor.AddChild(root_1, stream_ID.NextNode());
					DebugLocation(162, 53);
					// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:162:53: ^( ILIST ( INT )* )
					{
					object root_2 = (object)adaptor.Nil();
					DebugLocation(162, 55);
					root_2 = (object)adaptor.BecomeRoot((object)adaptor.Create(ILIST, "ILIST"), root_2);

					DebugLocation(162, 61);
					// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:162:61: ( INT )*
					while ( stream_INT.HasNext )
					{
						DebugLocation(162, 61);
						adaptor.AddChild(root_2, stream_INT.NextNode());

					}
					stream_INT.Reset();

					adaptor.AddChild(root_1, root_2);
					}

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:163:4: ID '[' index ']' '=' assign_expression
				{
				DebugLocation(163, 4);
				ID81=(IToken)Match(input,ID,Follow._ID_in_assign_var1050); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_ID.Add(ID81);

				DebugLocation(163, 7);
				char_literal82=(IToken)Match(input,56,Follow._56_in_assign_var1052); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_56.Add(char_literal82);

				DebugLocation(163, 11);
				PushFollow(Follow._index_in_assign_var1054);
				index83=index();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_index.Add(index83.Tree);
				DebugLocation(163, 17);
				char_literal84=(IToken)Match(input,57,Follow._57_in_assign_var1056); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_57.Add(char_literal84);

				DebugLocation(163, 21);
				char_literal85=(IToken)Match(input,52,Follow._52_in_assign_var1058); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_52.Add(char_literal85);

				DebugLocation(163, 25);
				PushFollow(Follow._assign_expression_in_assign_var1060);
				assign_expression86=assign_expression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_assign_expression.Add(assign_expression86.Tree);


				{
				// AST REWRITE
				// elements: assign_expression, index, ID
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 163:44: -> ^( ASGN ^( AR index ) ID assign_expression )
				{
					DebugLocation(163, 47);
					// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:163:47: ^( ASGN ^( AR index ) ID assign_expression )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(163, 49);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(ASGN, "ASGN"), root_1);

					DebugLocation(163, 54);
					// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:163:54: ^( AR index )
					{
					object root_2 = (object)adaptor.Nil();
					DebugLocation(163, 56);
					root_2 = (object)adaptor.BecomeRoot((object)adaptor.Create(AR, "AR"), root_2);

					DebugLocation(163, 59);
					adaptor.AddChild(root_2, stream_index.NextTree());

					adaptor.AddChild(root_1, root_2);
					}
					DebugLocation(163, 66);
					adaptor.AddChild(root_1, stream_ID.NextNode());
					DebugLocation(163, 69);
					adaptor.AddChild(root_1, stream_assign_expression.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:164:11: ID '=' assign_expression
				{
				DebugLocation(164, 11);
				ID87=(IToken)Match(input,ID,Follow._ID_in_assign_var1089); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_ID.Add(ID87);

				DebugLocation(164, 14);
				char_literal88=(IToken)Match(input,52,Follow._52_in_assign_var1091); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_52.Add(char_literal88);

				DebugLocation(164, 18);
				PushFollow(Follow._assign_expression_in_assign_var1093);
				assign_expression89=assign_expression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_assign_expression.Add(assign_expression89.Tree);


				{
				// AST REWRITE
				// elements: assign_expression, ID
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 164:37: -> ^( ASGN ID assign_expression )
				{
					DebugLocation(164, 40);
					// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:164:40: ^( ASGN ID assign_expression )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(164, 42);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(ASGN, "ASGN"), root_1);

					DebugLocation(164, 47);
					adaptor.AddChild(root_1, stream_ID.NextNode());
					DebugLocation(164, 50);
					adaptor.AddChild(root_1, stream_assign_expression.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
			if (state.backtracking == 0)
			{
				 paraphrases.Pop(); 
			}
		}

			catch (RecognitionException e) {
				throw e;
			}

		finally
		{
			TraceOut("assign_var", 18);
			LeaveRule("assign_var", 18);
			LeaveRule_assign_var();
		}
		DebugLocation(165, 1);
		} finally { DebugExitRule(GrammarFileName, "assign_var"); }
		return retval;

	}
	// $ANTLR end "assign_var"

	partial void EnterRule_return_stat();
	partial void LeaveRule_return_stat();

	// $ANTLR start "return_stat"
	// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:167:1: return_stat : 'retorne' assign_expression -> ^( RET assign_expression ) ;
	[GrammarRule("return_stat")]
	private AstParserRuleReturnScope<object, IToken> return_stat()
	{
		EnterRule_return_stat();
		EnterRule("return_stat", 19);
		TraceIn("return_stat", 19);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken string_literal90 = default(IToken);
		AstParserRuleReturnScope<object, IToken> assign_expression91 = default(AstParserRuleReturnScope<object, IToken>);

		object string_literal90_tree = default(object);
		RewriteRuleITokenStream stream_68=new RewriteRuleITokenStream(adaptor,"token 68");
		RewriteRuleSubtreeStream stream_assign_expression=new RewriteRuleSubtreeStream(adaptor,"rule assign_expression");
		try { DebugEnterRule(GrammarFileName, "return_stat");
		DebugLocation(167, 1);
		try
		{
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:168:2: ( 'retorne' assign_expression -> ^( RET assign_expression ) )
			DebugEnterAlt(1);
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:168:4: 'retorne' assign_expression
			{
			DebugLocation(168, 4);
			string_literal90=(IToken)Match(input,68,Follow._68_in_return_stat1116); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_68.Add(string_literal90);

			DebugLocation(168, 14);
			PushFollow(Follow._assign_expression_in_return_stat1118);
			assign_expression91=assign_expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_assign_expression.Add(assign_expression91.Tree);


			{
			// AST REWRITE
			// elements: assign_expression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 168:33: -> ^( RET assign_expression )
			{
				DebugLocation(168, 36);
				// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:168:36: ^( RET assign_expression )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(168, 38);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(RET, "RET"), root_1);

				DebugLocation(168, 42);
				adaptor.AddChild(root_1, stream_assign_expression.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

			catch (RecognitionException e) {
				throw e;
			}

		finally
		{
			TraceOut("return_stat", 19);
			LeaveRule("return_stat", 19);
			LeaveRule_return_stat();
		}
		DebugLocation(169, 1);
		} finally { DebugExitRule(GrammarFileName, "return_stat"); }
		return retval;

	}
	// $ANTLR end "return_stat"

	partial void EnterRule_asm_code();
	partial void LeaveRule_asm_code();

	// $ANTLR start "asm_code"
	// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:172:1: asm_code : '#' ( STRING )* '#' -> ^( ASM ( STRING )* ) ;
	[GrammarRule("asm_code")]
	private AstParserRuleReturnScope<object, IToken> asm_code()
	{
		EnterRule_asm_code();
		EnterRule("asm_code", 20);
		TraceIn("asm_code", 20);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken char_literal92 = default(IToken);
		IToken STRING93 = default(IToken);
		IToken char_literal94 = default(IToken);

		object char_literal92_tree = default(object);
		object STRING93_tree = default(object);
		object char_literal94_tree = default(object);
		RewriteRuleITokenStream stream_39=new RewriteRuleITokenStream(adaptor,"token 39");
		RewriteRuleITokenStream stream_STRING=new RewriteRuleITokenStream(adaptor,"token STRING");
		try { DebugEnterRule(GrammarFileName, "asm_code");
		DebugLocation(172, 8);
		try
		{
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:172:9: ( '#' ( STRING )* '#' -> ^( ASM ( STRING )* ) )
			DebugEnterAlt(1);
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:172:11: '#' ( STRING )* '#'
			{
			DebugLocation(172, 11);
			char_literal92=(IToken)Match(input,39,Follow._39_in_asm_code1137); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_39.Add(char_literal92);

			DebugLocation(172, 15);
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:172:15: ( STRING )*
			try { DebugEnterSubRule(23);
			while (true)
			{
				int alt23=2;
				try { DebugEnterDecision(23, false);
				int LA23_0 = input.LA(1);

				if ((LA23_0==STRING))
				{
					alt23 = 1;
				}


				} finally { DebugExitDecision(23); }
				switch ( alt23 )
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:172:15: STRING
					{
					DebugLocation(172, 15);
					STRING93=(IToken)Match(input,STRING,Follow._STRING_in_asm_code1139); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_STRING.Add(STRING93);


					}
					break;

				default:
					goto loop23;
				}
			}

			loop23:
				;

			} finally { DebugExitSubRule(23); }

			DebugLocation(172, 23);
			char_literal94=(IToken)Match(input,39,Follow._39_in_asm_code1142); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_39.Add(char_literal94);



			{
			// AST REWRITE
			// elements: STRING
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 172:27: -> ^( ASM ( STRING )* )
			{
				DebugLocation(172, 30);
				// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:172:30: ^( ASM ( STRING )* )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(172, 32);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(ASM, "ASM"), root_1);

				DebugLocation(172, 36);
				// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:172:36: ( STRING )*
				while ( stream_STRING.HasNext )
				{
					DebugLocation(172, 36);
					adaptor.AddChild(root_1, stream_STRING.NextNode());

				}
				stream_STRING.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

			catch (RecognitionException e) {
				throw e;
			}

		finally
		{
			TraceOut("asm_code", 20);
			LeaveRule("asm_code", 20);
			LeaveRule_asm_code();
		}
		DebugLocation(173, 8);
		} finally { DebugExitRule(GrammarFileName, "asm_code"); }
		return retval;

	}
	// $ANTLR end "asm_code"

	partial void EnterRule_logic_expression();
	partial void LeaveRule_logic_expression();

	// $ANTLR start "logic_expression"
	// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:179:1: logic_expression : ( plus_expression ) ( binop ^ plus_expression )* ;
	[GrammarRule("logic_expression")]
	private AstParserRuleReturnScope<object, IToken> logic_expression()
	{
		EnterRule_logic_expression();
		EnterRule("logic_expression", 21);
		TraceIn("logic_expression", 21);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> plus_expression95 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> binop96 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> plus_expression97 = default(AstParserRuleReturnScope<object, IToken>);

		try { DebugEnterRule(GrammarFileName, "logic_expression");
		DebugLocation(179, 1);
		try
		{
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:180:2: ( ( plus_expression ) ( binop ^ plus_expression )* )
			DebugEnterAlt(1);
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:180:4: ( plus_expression ) ( binop ^ plus_expression )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(180, 4);
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:180:4: ( plus_expression )
			DebugEnterAlt(1);
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:180:5: plus_expression
			{
			DebugLocation(180, 5);
			PushFollow(Follow._plus_expression_in_logic_expression1174);
			plus_expression95=plus_expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, plus_expression95.Tree);

			}

			DebugLocation(180, 22);
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:180:22: ( binop ^ plus_expression )*
			try { DebugEnterSubRule(24);
			while (true)
			{
				int alt24=2;
				try { DebugEnterDecision(24, false);
				int LA24_0 = input.LA(1);

				if ((LA24_0==38||(LA24_0>=50 && LA24_0<=51)||(LA24_0>=53 && LA24_0<=55)||LA24_0==60||LA24_0==65))
				{
					alt24 = 1;
				}


				} finally { DebugExitDecision(24); }
				switch ( alt24 )
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:180:23: binop ^ plus_expression
					{
					DebugLocation(180, 28);
					PushFollow(Follow._binop_in_logic_expression1178);
					binop96=binop();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) root_0 = (object)adaptor.BecomeRoot(binop96.Tree, root_0);
					DebugLocation(180, 30);
					PushFollow(Follow._plus_expression_in_logic_expression1181);
					plus_expression97=plus_expression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, plus_expression97.Tree);

					}
					break;

				default:
					goto loop24;
				}
			}

			loop24:
				;

			} finally { DebugExitSubRule(24); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

			catch (RecognitionException e) {
				throw e;
			}

		finally
		{
			TraceOut("logic_expression", 21);
			LeaveRule("logic_expression", 21);
			LeaveRule_logic_expression();
		}
		DebugLocation(181, 1);
		} finally { DebugExitRule(GrammarFileName, "logic_expression"); }
		return retval;

	}
	// $ANTLR end "logic_expression"

	partial void EnterRule_binop();
	partial void LeaveRule_binop();

	// $ANTLR start "binop"
	// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:183:1: binop : ( '<' | '>' | '<=' | '>=' | '==' | '!=' | 'e' | 'ou' );
	[GrammarRule("binop")]
	private AstParserRuleReturnScope<object, IToken> binop()
	{
		EnterRule_binop();
		EnterRule("binop", 22);
		TraceIn("binop", 22);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken set98 = default(IToken);

		object set98_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "binop");
		DebugLocation(183, 59);
		try
		{
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:183:7: ( '<' | '>' | '<=' | '>=' | '==' | '!=' | 'e' | 'ou' )
			DebugEnterAlt(1);
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(183, 7);

			set98=(IToken)input.LT(1);
			if (input.LA(1)==38||(input.LA(1)>=50 && input.LA(1)<=51)||(input.LA(1)>=53 && input.LA(1)<=55)||input.LA(1)==60||input.LA(1)==65)
			{
				input.Consume();
				if (state.backtracking == 0) adaptor.AddChild(root_0, (object)adaptor.Create(set98));
				state.errorRecovery=false;state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

			catch (RecognitionException e) {
				throw e;
			}

		finally
		{
			TraceOut("binop", 22);
			LeaveRule("binop", 22);
			LeaveRule_binop();
		}
		DebugLocation(183, 59);
		} finally { DebugExitRule(GrammarFileName, "binop"); }
		return retval;

	}
	// $ANTLR end "binop"

	partial void EnterRule_assign_expression();
	partial void LeaveRule_assign_expression();

	// $ANTLR start "assign_expression"
	// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:186:1: assign_expression options {k=3; } : plus_expression ;
	[GrammarRule("assign_expression")]
	private AstParserRuleReturnScope<object, IToken> assign_expression()
	{
		EnterRule_assign_expression();
		EnterRule("assign_expression", 23);
		TraceIn("assign_expression", 23);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> plus_expression99 = default(AstParserRuleReturnScope<object, IToken>);

		try { DebugEnterRule(GrammarFileName, "assign_expression");
		DebugLocation(186, 19);
		try
		{
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:188:2: ( plus_expression )
			DebugEnterAlt(1);
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:188:5: plus_expression
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(188, 5);
			PushFollow(Follow._plus_expression_in_assign_expression1242);
			plus_expression99=plus_expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, plus_expression99.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

			catch (RecognitionException e) {
				throw e;
			}

		finally
		{
			TraceOut("assign_expression", 23);
			LeaveRule("assign_expression", 23);
			LeaveRule_assign_expression();
		}
		DebugLocation(188, 19);
		} finally { DebugExitRule(GrammarFileName, "assign_expression"); }
		return retval;

	}
	// $ANTLR end "assign_expression"

	partial void EnterRule_plus_expression();
	partial void LeaveRule_plus_expression();

	// $ANTLR start "plus_expression"
	// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:190:1: plus_expression : ( mul_expression ) ( '+' ^ mul_expression | '-' ^ mul_expression )* ;
	[GrammarRule("plus_expression")]
	private AstParserRuleReturnScope<object, IToken> plus_expression()
	{
		EnterRule_plus_expression();
		EnterRule("plus_expression", 24);
		TraceIn("plus_expression", 24);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken char_literal101 = default(IToken);
		IToken char_literal103 = default(IToken);
		AstParserRuleReturnScope<object, IToken> mul_expression100 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> mul_expression102 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> mul_expression104 = default(AstParserRuleReturnScope<object, IToken>);

		object char_literal101_tree = default(object);
		object char_literal103_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "plus_expression");
		DebugLocation(190, 1);
		try
		{
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:191:2: ( ( mul_expression ) ( '+' ^ mul_expression | '-' ^ mul_expression )* )
			DebugEnterAlt(1);
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:191:4: ( mul_expression ) ( '+' ^ mul_expression | '-' ^ mul_expression )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(191, 4);
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:191:4: ( mul_expression )
			DebugEnterAlt(1);
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:191:5: mul_expression
			{
			DebugLocation(191, 5);
			PushFollow(Follow._mul_expression_in_plus_expression1252);
			mul_expression100=mul_expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, mul_expression100.Tree);

			}

			DebugLocation(191, 21);
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:191:21: ( '+' ^ mul_expression | '-' ^ mul_expression )*
			try { DebugEnterSubRule(25);
			while (true)
			{
				int alt25=3;
				try { DebugEnterDecision(25, false);
				int LA25_0 = input.LA(1);

				if ((LA25_0==44))
				{
					alt25 = 1;
				}
				else if ((LA25_0==46))
				{
					alt25 = 2;
				}


				} finally { DebugExitDecision(25); }
				switch ( alt25 )
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:191:22: '+' ^ mul_expression
					{
					DebugLocation(191, 25);
					char_literal101=(IToken)Match(input,44,Follow._44_in_plus_expression1256); if (state.failed) return retval;
					if (state.backtracking == 0) {
					char_literal101_tree = (object)adaptor.Create(char_literal101);
					root_0 = (object)adaptor.BecomeRoot(char_literal101_tree, root_0);
					}
					DebugLocation(191, 27);
					PushFollow(Follow._mul_expression_in_plus_expression1259);
					mul_expression102=mul_expression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, mul_expression102.Tree);

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:191:44: '-' ^ mul_expression
					{
					DebugLocation(191, 47);
					char_literal103=(IToken)Match(input,46,Follow._46_in_plus_expression1263); if (state.failed) return retval;
					if (state.backtracking == 0) {
					char_literal103_tree = (object)adaptor.Create(char_literal103);
					root_0 = (object)adaptor.BecomeRoot(char_literal103_tree, root_0);
					}
					DebugLocation(191, 49);
					PushFollow(Follow._mul_expression_in_plus_expression1266);
					mul_expression104=mul_expression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, mul_expression104.Tree);

					}
					break;

				default:
					goto loop25;
				}
			}

			loop25:
				;

			} finally { DebugExitSubRule(25); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

			catch (RecognitionException e) {
				throw e;
			}

		finally
		{
			TraceOut("plus_expression", 24);
			LeaveRule("plus_expression", 24);
			LeaveRule_plus_expression();
		}
		DebugLocation(192, 1);
		} finally { DebugExitRule(GrammarFileName, "plus_expression"); }
		return retval;

	}
	// $ANTLR end "plus_expression"

	partial void EnterRule_mul_expression();
	partial void LeaveRule_mul_expression();

	// $ANTLR start "mul_expression"
	// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:194:1: mul_expression : ( primary_ar_expression ) ( '/' ^ primary_ar_expression | '%' ^ primary_ar_expression | '*' ^ primary_ar_expression )* ;
	[GrammarRule("mul_expression")]
	private AstParserRuleReturnScope<object, IToken> mul_expression()
	{
		EnterRule_mul_expression();
		EnterRule("mul_expression", 25);
		TraceIn("mul_expression", 25);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken char_literal106 = default(IToken);
		IToken char_literal108 = default(IToken);
		IToken char_literal110 = default(IToken);
		AstParserRuleReturnScope<object, IToken> primary_ar_expression105 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> primary_ar_expression107 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> primary_ar_expression109 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> primary_ar_expression111 = default(AstParserRuleReturnScope<object, IToken>);

		object char_literal106_tree = default(object);
		object char_literal108_tree = default(object);
		object char_literal110_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "mul_expression");
		DebugLocation(194, 1);
		try
		{
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:195:2: ( ( primary_ar_expression ) ( '/' ^ primary_ar_expression | '%' ^ primary_ar_expression | '*' ^ primary_ar_expression )* )
			DebugEnterAlt(1);
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:195:4: ( primary_ar_expression ) ( '/' ^ primary_ar_expression | '%' ^ primary_ar_expression | '*' ^ primary_ar_expression )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(195, 4);
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:195:4: ( primary_ar_expression )
			DebugEnterAlt(1);
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:195:5: primary_ar_expression
			{
			DebugLocation(195, 5);
			PushFollow(Follow._primary_ar_expression_in_mul_expression1281);
			primary_ar_expression105=primary_ar_expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, primary_ar_expression105.Tree);

			}

			DebugLocation(195, 28);
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:195:28: ( '/' ^ primary_ar_expression | '%' ^ primary_ar_expression | '*' ^ primary_ar_expression )*
			try { DebugEnterSubRule(26);
			while (true)
			{
				int alt26=4;
				try { DebugEnterDecision(26, false);
				switch (input.LA(1))
				{
				case 49:
					{
					alt26 = 1;
					}
					break;
				case 40:
					{
					alt26 = 2;
					}
					break;
				case 43:
					{
					alt26 = 3;
					}
					break;
				}

				} finally { DebugExitDecision(26); }
				switch ( alt26 )
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:195:30: '/' ^ primary_ar_expression
					{
					DebugLocation(195, 33);
					char_literal106=(IToken)Match(input,49,Follow._49_in_mul_expression1286); if (state.failed) return retval;
					if (state.backtracking == 0) {
					char_literal106_tree = (object)adaptor.Create(char_literal106);
					root_0 = (object)adaptor.BecomeRoot(char_literal106_tree, root_0);
					}
					DebugLocation(195, 35);
					PushFollow(Follow._primary_ar_expression_in_mul_expression1289);
					primary_ar_expression107=primary_ar_expression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, primary_ar_expression107.Tree);

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:195:59: '%' ^ primary_ar_expression
					{
					DebugLocation(195, 62);
					char_literal108=(IToken)Match(input,40,Follow._40_in_mul_expression1293); if (state.failed) return retval;
					if (state.backtracking == 0) {
					char_literal108_tree = (object)adaptor.Create(char_literal108);
					root_0 = (object)adaptor.BecomeRoot(char_literal108_tree, root_0);
					}
					DebugLocation(195, 64);
					PushFollow(Follow._primary_ar_expression_in_mul_expression1296);
					primary_ar_expression109=primary_ar_expression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, primary_ar_expression109.Tree);

					}
					break;
				case 3:
					DebugEnterAlt(3);
					// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:195:88: '*' ^ primary_ar_expression
					{
					DebugLocation(195, 91);
					char_literal110=(IToken)Match(input,43,Follow._43_in_mul_expression1300); if (state.failed) return retval;
					if (state.backtracking == 0) {
					char_literal110_tree = (object)adaptor.Create(char_literal110);
					root_0 = (object)adaptor.BecomeRoot(char_literal110_tree, root_0);
					}
					DebugLocation(195, 93);
					PushFollow(Follow._primary_ar_expression_in_mul_expression1303);
					primary_ar_expression111=primary_ar_expression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, primary_ar_expression111.Tree);

					}
					break;

				default:
					goto loop26;
				}
			}

			loop26:
				;

			} finally { DebugExitSubRule(26); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

			catch (RecognitionException e) {
				throw e;
			}

		finally
		{
			TraceOut("mul_expression", 25);
			LeaveRule("mul_expression", 25);
			LeaveRule_mul_expression();
		}
		DebugLocation(196, 1);
		} finally { DebugExitRule(GrammarFileName, "mul_expression"); }
		return retval;

	}
	// $ANTLR end "mul_expression"

	partial void EnterRule_primary_ar_expression();
	partial void LeaveRule_primary_ar_expression();

	// $ANTLR start "primary_ar_expression"
	// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:198:1: primary_ar_expression : ({...}? => function_call | ID | ID '[' index ']' -> ^( INDEX index ) ID | method_call | property_call | constant | parenthesisExpression );
	[GrammarRule("primary_ar_expression")]
	private AstParserRuleReturnScope<object, IToken> primary_ar_expression()
	{
		EnterRule_primary_ar_expression();
		EnterRule("primary_ar_expression", 26);
		TraceIn("primary_ar_expression", 26);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken ID113 = default(IToken);
		IToken ID114 = default(IToken);
		IToken char_literal115 = default(IToken);
		IToken char_literal117 = default(IToken);
		AstParserRuleReturnScope<object, IToken> function_call112 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> index116 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> method_call118 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> property_call119 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> constant120 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> parenthesisExpression121 = default(AstParserRuleReturnScope<object, IToken>);

		object ID113_tree = default(object);
		object ID114_tree = default(object);
		object char_literal115_tree = default(object);
		object char_literal117_tree = default(object);
		RewriteRuleITokenStream stream_57=new RewriteRuleITokenStream(adaptor,"token 57");
		RewriteRuleITokenStream stream_56=new RewriteRuleITokenStream(adaptor,"token 56");
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleSubtreeStream stream_index=new RewriteRuleSubtreeStream(adaptor,"rule index");
		try { DebugEnterRule(GrammarFileName, "primary_ar_expression");
		DebugLocation(198, 1);
		try
		{
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:199:2: ({...}? => function_call | ID | ID '[' index ']' -> ^( INDEX index ) ID | method_call | property_call | constant | parenthesisExpression )
			int alt27=7;
			try { DebugEnterDecision(27, false);
			switch (input.LA(1))
			{
			case ID:
				{
				switch (input.LA(2))
				{
				case 41:
					{
					int LA27_4 = input.LA(3);

					if ((((( (!IsDefinedID(input.LT(1).Text)) && input.LT(2).Text =="(" )&&( (!IsDefinedID(input.LT(1).Text)) && input.LT(2).Text =="(" ))&&EvaluatePredicate(synpred46_NPortugol_fragment))))
					{
						alt27 = 1;
					}
					else if ((EvaluatePredicate(synpred47_NPortugol_fragment)))
					{
						alt27 = 2;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 27, 4, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					}
					break;
				case 56:
					{
					alt27 = 3;
					}
					break;
				case 47:
					{
					int LA27_6 = input.LA(3);

					if ((EvaluatePredicate(synpred49_NPortugol_fragment)))
					{
						alt27 = 4;
					}
					else if ((EvaluatePredicate(synpred50_NPortugol_fragment)))
					{
						alt27 = 5;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 27, 6, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					}
					break;
				case EOF:
				case FLOAT:
				case ID:
				case INT:
				case STRING:
				case 38:
				case 39:
				case 40:
				case 42:
				case 43:
				case 44:
				case 45:
				case 46:
				case 49:
				case 50:
				case 51:
				case 53:
				case 54:
				case 55:
				case 58:
				case 60:
				case 61:
				case 62:
				case 63:
				case 65:
				case 66:
				case 67:
				case 68:
				case 69:
				case 70:
				case 71:
					{
					alt27 = 2;
					}
					break;
				default:
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 27, 1, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}

				}
				break;
			case FLOAT:
			case INT:
			case STRING:
				{
				alt27 = 6;
				}
				break;
			case 41:
				{
				alt27 = 7;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 27, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(27); }
			switch (alt27)
			{
			case 1:
				DebugEnterAlt(1);
				// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:199:4: {...}? => function_call
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(199, 4);
				if (!(( (!IsDefinedID(input.LT(1).Text)) && input.LT(2).Text =="(" )))
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					throw new FailedPredicateException(input, "primary_ar_expression", " (!IsDefinedID(input.LT(1).Text)) && input.LT(2).Text ==\"(\" ");
				}
				DebugLocation(199, 71);
				PushFollow(Follow._function_call_in_primary_ar_expression1321);
				function_call112=function_call();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, function_call112.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:200:4: ID
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(200, 4);
				ID113=(IToken)Match(input,ID,Follow._ID_in_primary_ar_expression1326); if (state.failed) return retval;
				if (state.backtracking == 0) {
				ID113_tree = (object)adaptor.Create(ID113);
				adaptor.AddChild(root_0, ID113_tree);
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:201:4: ID '[' index ']'
				{
				DebugLocation(201, 4);
				ID114=(IToken)Match(input,ID,Follow._ID_in_primary_ar_expression1331); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_ID.Add(ID114);

				DebugLocation(201, 7);
				char_literal115=(IToken)Match(input,56,Follow._56_in_primary_ar_expression1333); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_56.Add(char_literal115);

				DebugLocation(201, 11);
				PushFollow(Follow._index_in_primary_ar_expression1335);
				index116=index();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_index.Add(index116.Tree);
				DebugLocation(201, 17);
				char_literal117=(IToken)Match(input,57,Follow._57_in_primary_ar_expression1337); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_57.Add(char_literal117);



				{
				// AST REWRITE
				// elements: index, ID
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 201:21: -> ^( INDEX index ) ID
				{
					DebugLocation(201, 24);
					// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:201:24: ^( INDEX index )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(201, 26);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(INDEX, "INDEX"), root_1);

					DebugLocation(201, 32);
					adaptor.AddChild(root_1, stream_index.NextTree());

					adaptor.AddChild(root_0, root_1);
					}
					DebugLocation(201, 39);
					adaptor.AddChild(root_0, stream_ID.NextNode());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:202:4: method_call
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(202, 4);
				PushFollow(Follow._method_call_in_primary_ar_expression1352);
				method_call118=method_call();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, method_call118.Tree);

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:203:4: property_call
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(203, 4);
				PushFollow(Follow._property_call_in_primary_ar_expression1358);
				property_call119=property_call();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, property_call119.Tree);

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:204:4: constant
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(204, 4);
				PushFollow(Follow._constant_in_primary_ar_expression1363);
				constant120=constant();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, constant120.Tree);

				}
				break;
			case 7:
				DebugEnterAlt(7);
				// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:205:4: parenthesisExpression
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(205, 4);
				PushFollow(Follow._parenthesisExpression_in_primary_ar_expression1368);
				parenthesisExpression121=parenthesisExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, parenthesisExpression121.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

			catch (RecognitionException e) {
				throw e;
			}

		finally
		{
			TraceOut("primary_ar_expression", 26);
			LeaveRule("primary_ar_expression", 26);
			LeaveRule_primary_ar_expression();
		}
		DebugLocation(206, 1);
		} finally { DebugExitRule(GrammarFileName, "primary_ar_expression"); }
		return retval;

	}
	// $ANTLR end "primary_ar_expression"

	partial void EnterRule_parenthesisExpression();
	partial void LeaveRule_parenthesisExpression();

	// $ANTLR start "parenthesisExpression"
	// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:208:1: parenthesisExpression : '(' plus_expression ')' -> plus_expression ;
	[GrammarRule("parenthesisExpression")]
	private AstParserRuleReturnScope<object, IToken> parenthesisExpression()
	{
		EnterRule_parenthesisExpression();
		EnterRule("parenthesisExpression", 27);
		TraceIn("parenthesisExpression", 27);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken char_literal122 = default(IToken);
		IToken char_literal124 = default(IToken);
		AstParserRuleReturnScope<object, IToken> plus_expression123 = default(AstParserRuleReturnScope<object, IToken>);

		object char_literal122_tree = default(object);
		object char_literal124_tree = default(object);
		RewriteRuleITokenStream stream_42=new RewriteRuleITokenStream(adaptor,"token 42");
		RewriteRuleITokenStream stream_41=new RewriteRuleITokenStream(adaptor,"token 41");
		RewriteRuleSubtreeStream stream_plus_expression=new RewriteRuleSubtreeStream(adaptor,"rule plus_expression");
		try { DebugEnterRule(GrammarFileName, "parenthesisExpression");
		DebugLocation(208, 1);
		try
		{
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:208:22: ( '(' plus_expression ')' -> plus_expression )
			DebugEnterAlt(1);
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:208:24: '(' plus_expression ')'
			{
			DebugLocation(208, 24);
			char_literal122=(IToken)Match(input,41,Follow._41_in_parenthesisExpression1383); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_41.Add(char_literal122);

			DebugLocation(208, 28);
			PushFollow(Follow._plus_expression_in_parenthesisExpression1385);
			plus_expression123=plus_expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_plus_expression.Add(plus_expression123.Tree);
			DebugLocation(208, 44);
			char_literal124=(IToken)Match(input,42,Follow._42_in_parenthesisExpression1387); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_42.Add(char_literal124);



			{
			// AST REWRITE
			// elements: plus_expression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 208:48: -> plus_expression
			{
				DebugLocation(208, 51);
				adaptor.AddChild(root_0, stream_plus_expression.NextTree());

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

			catch (RecognitionException e) {
				throw e;
			}

		finally
		{
			TraceOut("parenthesisExpression", 27);
			LeaveRule("parenthesisExpression", 27);
			LeaveRule_parenthesisExpression();
		}
		DebugLocation(209, 1);
		} finally { DebugExitRule(GrammarFileName, "parenthesisExpression"); }
		return retval;

	}
	// $ANTLR end "parenthesisExpression"

	partial void EnterRule_constant();
	partial void LeaveRule_constant();

	// $ANTLR start "constant"
	// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:211:1: constant : ( INT | FLOAT | STRING );
	[GrammarRule("constant")]
	private AstParserRuleReturnScope<object, IToken> constant()
	{
		EnterRule_constant();
		EnterRule("constant", 28);
		TraceIn("constant", 28);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken set125 = default(IToken);

		object set125_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "constant");
		DebugLocation(211, 30);
		try
		{
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:211:9: ( INT | FLOAT | STRING )
			DebugEnterAlt(1);
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(211, 9);

			set125=(IToken)input.LT(1);
			if (input.LA(1)==FLOAT||input.LA(1)==INT||input.LA(1)==STRING)
			{
				input.Consume();
				if (state.backtracking == 0) adaptor.AddChild(root_0, (object)adaptor.Create(set125));
				state.errorRecovery=false;state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

			catch (RecognitionException e) {
				throw e;
			}

		finally
		{
			TraceOut("constant", 28);
			LeaveRule("constant", 28);
			LeaveRule_constant();
		}
		DebugLocation(211, 30);
		} finally { DebugExitRule(GrammarFileName, "constant"); }
		return retval;

	}
	// $ANTLR end "constant"

	partial void EnterRule_atom();
	partial void LeaveRule_atom();

	// $ANTLR start "atom"
	// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:213:1: atom : ( constant | ID );
	[GrammarRule("atom")]
	private AstParserRuleReturnScope<object, IToken> atom()
	{
		EnterRule_atom();
		EnterRule("atom", 29);
		TraceIn("atom", 29);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken ID127 = default(IToken);
		AstParserRuleReturnScope<object, IToken> constant126 = default(AstParserRuleReturnScope<object, IToken>);

		object ID127_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "atom");
		DebugLocation(213, 20);
		try
		{
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:213:6: ( constant | ID )
			int alt28=2;
			try { DebugEnterDecision(28, false);
			int LA28_0 = input.LA(1);

			if ((LA28_0==FLOAT||LA28_0==INT||LA28_0==STRING))
			{
				alt28 = 1;
			}
			else if ((LA28_0==ID))
			{
				alt28 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 28, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(28); }
			switch (alt28)
			{
			case 1:
				DebugEnterAlt(1);
				// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:213:8: constant
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(213, 8);
				PushFollow(Follow._constant_in_atom1418);
				constant126=constant();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, constant126.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:213:19: ID
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(213, 19);
				ID127=(IToken)Match(input,ID,Follow._ID_in_atom1422); if (state.failed) return retval;
				if (state.backtracking == 0) {
				ID127_tree = (object)adaptor.Create(ID127);
				adaptor.AddChild(root_0, ID127_tree);
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

			catch (RecognitionException e) {
				throw e;
			}

		finally
		{
			TraceOut("atom", 29);
			LeaveRule("atom", 29);
			LeaveRule_atom();
		}
		DebugLocation(213, 20);
		} finally { DebugExitRule(GrammarFileName, "atom"); }
		return retval;

	}
	// $ANTLR end "atom"

	partial void EnterRule_index();
	partial void LeaveRule_index();

	// $ANTLR start "index"
	// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:215:1: index : ( INT | ID );
	[GrammarRule("index")]
	private AstParserRuleReturnScope<object, IToken> index()
	{
		EnterRule_index();
		EnterRule("index", 30);
		TraceIn("index", 30);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken set128 = default(IToken);

		object set128_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "index");
		DebugLocation(215, 16);
		try
		{
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:215:7: ( INT | ID )
			DebugEnterAlt(1);
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(215, 7);

			set128=(IToken)input.LT(1);
			if (input.LA(1)==ID||input.LA(1)==INT)
			{
				input.Consume();
				if (state.backtracking == 0) adaptor.AddChild(root_0, (object)adaptor.Create(set128));
				state.errorRecovery=false;state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

			catch (RecognitionException e) {
				throw e;
			}

		finally
		{
			TraceOut("index", 30);
			LeaveRule("index", 30);
			LeaveRule_index();
		}
		DebugLocation(215, 16);
		} finally { DebugExitRule(GrammarFileName, "index"); }
		return retval;

	}
	// $ANTLR end "index"

	partial void EnterRule_number();
	partial void LeaveRule_number();

	// $ANTLR start "number"
	// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:217:1: number : ( INT | FLOAT );
	[GrammarRule("number")]
	private AstParserRuleReturnScope<object, IToken> number()
	{
		EnterRule_number();
		EnterRule("number", 31);
		TraceIn("number", 31);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken set129 = default(IToken);

		object set129_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "number");
		DebugLocation(217, 20);
		try
		{
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:217:8: ( INT | FLOAT )
			DebugEnterAlt(1);
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(217, 8);

			set129=(IToken)input.LT(1);
			if (input.LA(1)==FLOAT||input.LA(1)==INT)
			{
				input.Consume();
				if (state.backtracking == 0) adaptor.AddChild(root_0, (object)adaptor.Create(set129));
				state.errorRecovery=false;state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

			catch (RecognitionException e) {
				throw e;
			}

		finally
		{
			TraceOut("number", 31);
			LeaveRule("number", 31);
			LeaveRule_number();
		}
		DebugLocation(217, 20);
		} finally { DebugExitRule(GrammarFileName, "number"); }
		return retval;

	}
	// $ANTLR end "number"

	partial void EnterRule_synpred25_NPortugol_fragment();
	partial void LeaveRule_synpred25_NPortugol_fragment();

	// $ANTLR start synpred25_NPortugol
	public void synpred25_NPortugol_fragment()
	{
		EnterRule_synpred25_NPortugol_fragment();
		EnterRule("synpred25_NPortugol_fragment", 56);
		TraceIn("synpred25_NPortugol_fragment", 56);
		try
		{
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:143:11: ( function_arg_list )
			DebugEnterAlt(1);
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:143:11: function_arg_list
			{
			DebugLocation(143, 11);
			PushFollow(Follow._function_arg_list_in_synpred25_NPortugol775);
			function_arg_list();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred25_NPortugol_fragment", 56);
			LeaveRule("synpred25_NPortugol_fragment", 56);
			LeaveRule_synpred25_NPortugol_fragment();
		}
	}
	// $ANTLR end synpred25_NPortugol

	partial void EnterRule_synpred26_NPortugol_fragment();
	partial void LeaveRule_synpred26_NPortugol_fragment();

	// $ANTLR start synpred26_NPortugol
	public void synpred26_NPortugol_fragment()
	{
		EnterRule_synpred26_NPortugol_fragment();
		EnterRule("synpred26_NPortugol_fragment", 57);
		TraceIn("synpred26_NPortugol_fragment", 57);
		try
		{
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:151:20: ( function_arg_list )
			DebugEnterAlt(1);
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:151:20: function_arg_list
			{
			DebugLocation(151, 20);
			PushFollow(Follow._function_arg_list_in_synpred26_NPortugol875);
			function_arg_list();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred26_NPortugol_fragment", 57);
			LeaveRule("synpred26_NPortugol_fragment", 57);
			LeaveRule_synpred26_NPortugol_fragment();
		}
	}
	// $ANTLR end synpred26_NPortugol

	partial void EnterRule_synpred28_NPortugol_fragment();
	partial void LeaveRule_synpred28_NPortugol_fragment();

	// $ANTLR start synpred28_NPortugol
	public void synpred28_NPortugol_fragment()
	{
		EnterRule_synpred28_NPortugol_fragment();
		EnterRule("synpred28_NPortugol_fragment", 59);
		TraceIn("synpred28_NPortugol_fragment", 59);
		try
		{
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:161:9: ( ID '=' '[' INT '..' INT ']' )
			DebugEnterAlt(1);
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:161:9: ID '=' '[' INT '..' INT ']'
			{
			DebugLocation(161, 9);
			Match(input,ID,Follow._ID_in_synpred28_NPortugol980); if (state.failed) return;
			DebugLocation(161, 12);
			Match(input,52,Follow._52_in_synpred28_NPortugol982); if (state.failed) return;
			DebugLocation(161, 16);
			Match(input,56,Follow._56_in_synpred28_NPortugol984); if (state.failed) return;
			DebugLocation(161, 20);
			Match(input,INT,Follow._INT_in_synpred28_NPortugol986); if (state.failed) return;
			DebugLocation(161, 24);
			Match(input,48,Follow._48_in_synpred28_NPortugol988); if (state.failed) return;
			DebugLocation(161, 29);
			Match(input,INT,Follow._INT_in_synpred28_NPortugol990); if (state.failed) return;
			DebugLocation(161, 33);
			Match(input,57,Follow._57_in_synpred28_NPortugol992); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred28_NPortugol_fragment", 59);
			LeaveRule("synpred28_NPortugol_fragment", 59);
			LeaveRule_synpred28_NPortugol_fragment();
		}
	}
	// $ANTLR end synpred28_NPortugol

	partial void EnterRule_synpred30_NPortugol_fragment();
	partial void LeaveRule_synpred30_NPortugol_fragment();

	// $ANTLR start synpred30_NPortugol
	public void synpred30_NPortugol_fragment()
	{
		EnterRule_synpred30_NPortugol_fragment();
		EnterRule("synpred30_NPortugol_fragment", 61);
		TraceIn("synpred30_NPortugol_fragment", 61);
		try
		{
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:162:10: ( ID '=' '{' INT ( ',' INT )* '}' )
			DebugEnterAlt(1);
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:162:10: ID '=' '{' INT ( ',' INT )* '}'
			{
			DebugLocation(162, 10);
			Match(input,ID,Follow._ID_in_synpred30_NPortugol1015); if (state.failed) return;
			DebugLocation(162, 13);
			Match(input,52,Follow._52_in_synpred30_NPortugol1017); if (state.failed) return;
			DebugLocation(162, 17);
			Match(input,72,Follow._72_in_synpred30_NPortugol1019); if (state.failed) return;
			DebugLocation(162, 21);
			Match(input,INT,Follow._INT_in_synpred30_NPortugol1021); if (state.failed) return;
			DebugLocation(162, 25);
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:162:25: ( ',' INT )*
			try { DebugEnterSubRule(30);
			while (true)
			{
				int alt30=2;
				try { DebugEnterDecision(30, false);
				int LA30_0 = input.LA(1);

				if ((LA30_0==45))
				{
					alt30 = 1;
				}


				} finally { DebugExitDecision(30); }
				switch ( alt30 )
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:162:26: ',' INT
					{
					DebugLocation(162, 26);
					Match(input,45,Follow._45_in_synpred30_NPortugol1024); if (state.failed) return;
					DebugLocation(162, 30);
					Match(input,INT,Follow._INT_in_synpred30_NPortugol1026); if (state.failed) return;

					}
					break;

				default:
					goto loop30;
				}
			}

			loop30:
				;

			} finally { DebugExitSubRule(30); }

			DebugLocation(162, 36);
			Match(input,73,Follow._73_in_synpred30_NPortugol1030); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred30_NPortugol_fragment", 61);
			LeaveRule("synpred30_NPortugol_fragment", 61);
			LeaveRule_synpred30_NPortugol_fragment();
		}
	}
	// $ANTLR end synpred30_NPortugol

	partial void EnterRule_synpred46_NPortugol_fragment();
	partial void LeaveRule_synpred46_NPortugol_fragment();

	// $ANTLR start synpred46_NPortugol
	public void synpred46_NPortugol_fragment()
	{
		EnterRule_synpred46_NPortugol_fragment();
		EnterRule("synpred46_NPortugol_fragment", 77);
		TraceIn("synpred46_NPortugol_fragment", 77);
		try
		{
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:199:4: ({...}? => function_call )
			DebugEnterAlt(1);
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:199:4: {...}? => function_call
			{
			DebugLocation(199, 4);
			if (!(( (!IsDefinedID(input.LT(1).Text)) && input.LT(2).Text =="(" )))
			{
				if (state.backtracking>0) {state.failed=true; return;}
				throw new FailedPredicateException(input, "synpred46_NPortugol", " (!IsDefinedID(input.LT(1).Text)) && input.LT(2).Text ==\"(\" ");
			}
			DebugLocation(199, 71);
			PushFollow(Follow._function_call_in_synpred46_NPortugol1321);
			function_call();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred46_NPortugol_fragment", 77);
			LeaveRule("synpred46_NPortugol_fragment", 77);
			LeaveRule_synpred46_NPortugol_fragment();
		}
	}
	// $ANTLR end synpred46_NPortugol

	partial void EnterRule_synpred47_NPortugol_fragment();
	partial void LeaveRule_synpred47_NPortugol_fragment();

	// $ANTLR start synpred47_NPortugol
	public void synpred47_NPortugol_fragment()
	{
		EnterRule_synpred47_NPortugol_fragment();
		EnterRule("synpred47_NPortugol_fragment", 78);
		TraceIn("synpred47_NPortugol_fragment", 78);
		try
		{
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:200:4: ( ID )
			DebugEnterAlt(1);
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:200:4: ID
			{
			DebugLocation(200, 4);
			Match(input,ID,Follow._ID_in_synpred47_NPortugol1326); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred47_NPortugol_fragment", 78);
			LeaveRule("synpred47_NPortugol_fragment", 78);
			LeaveRule_synpred47_NPortugol_fragment();
		}
	}
	// $ANTLR end synpred47_NPortugol

	partial void EnterRule_synpred49_NPortugol_fragment();
	partial void LeaveRule_synpred49_NPortugol_fragment();

	// $ANTLR start synpred49_NPortugol
	public void synpred49_NPortugol_fragment()
	{
		EnterRule_synpred49_NPortugol_fragment();
		EnterRule("synpred49_NPortugol_fragment", 80);
		TraceIn("synpred49_NPortugol_fragment", 80);
		try
		{
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:202:4: ( method_call )
			DebugEnterAlt(1);
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:202:4: method_call
			{
			DebugLocation(202, 4);
			PushFollow(Follow._method_call_in_synpred49_NPortugol1352);
			method_call();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred49_NPortugol_fragment", 80);
			LeaveRule("synpred49_NPortugol_fragment", 80);
			LeaveRule_synpred49_NPortugol_fragment();
		}
	}
	// $ANTLR end synpred49_NPortugol

	partial void EnterRule_synpred50_NPortugol_fragment();
	partial void LeaveRule_synpred50_NPortugol_fragment();

	// $ANTLR start synpred50_NPortugol
	public void synpred50_NPortugol_fragment()
	{
		EnterRule_synpred50_NPortugol_fragment();
		EnterRule("synpred50_NPortugol_fragment", 81);
		TraceIn("synpred50_NPortugol_fragment", 81);
		try
		{
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:203:4: ( property_call )
			DebugEnterAlt(1);
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:203:4: property_call
			{
			DebugLocation(203, 4);
			PushFollow(Follow._property_call_in_synpred50_NPortugol1358);
			property_call();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred50_NPortugol_fragment", 81);
			LeaveRule("synpred50_NPortugol_fragment", 81);
			LeaveRule_synpred50_NPortugol_fragment();
		}
	}
	// $ANTLR end synpred50_NPortugol
	#endregion Rules

	#region Synpreds
	private bool EvaluatePredicate(System.Action fragment)
	{
		bool success = false;
		state.backtracking++;
		try { DebugBeginBacktrack(state.backtracking);
		int start = input.Mark();
		try
		{
			fragment();
		}
		catch ( RecognitionException re )
		{
			System.Console.Error.WriteLine("impossible: "+re);
		}
		success = !state.failed;
		input.Rewind(start);
		} finally { DebugEndBacktrack(state.backtracking, success); }
		state.backtracking--;
		state.failed=false;
		return success;
	}
	#endregion Synpreds


	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _declare_function_in_script148 = new BitSet(new ulong[]{0x2UL,0x1UL});
		public static readonly BitSet _64_in_declare_function159 = new BitSet(new ulong[]{0x400020000UL});
		public static readonly BitSet _TYPE_in_declare_function163 = new BitSet(new ulong[]{0x20000UL});
		public static readonly BitSet _ID_in_declare_function168 = new BitSet(new ulong[]{0x20000000000UL});
		public static readonly BitSet _41_in_declare_function170 = new BitSet(new ulong[]{0x40400000000UL});
		public static readonly BitSet _function_param_list_in_declare_function172 = new BitSet(new ulong[]{0x40400000000UL});
		public static readonly BitSet _42_in_declare_function175 = new BitSet(new ulong[]{0xA000008000020000UL,0xBCUL});
		public static readonly BitSet _statement_in_declare_function177 = new BitSet(new ulong[]{0xA000008000020000UL,0xBCUL});
		public static readonly BitSet _63_in_declare_function180 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _declare_local_in_statement230 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _if_stat_in_statement236 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _for_stat_in_statement242 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _while_stat_in_statement247 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _repeat_stat_in_statement252 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _function_call_in_statement258 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _assign_var_in_statement264 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _return_stat_in_statement270 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _asm_code_in_statement275 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _param_in_function_param_list303 = new BitSet(new ulong[]{0x200000000002UL});
		public static readonly BitSet _45_in_function_param_list306 = new BitSet(new ulong[]{0x400000000UL});
		public static readonly BitSet _param_in_function_param_list308 = new BitSet(new ulong[]{0x200000000002UL});
		public static readonly BitSet _TYPE_in_param331 = new BitSet(new ulong[]{0x20000UL});
		public static readonly BitSet _ID_in_param333 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _71_in_declare_local373 = new BitSet(new ulong[]{0x400000000UL});
		public static readonly BitSet _local_var_in_declare_local375 = new BitSet(new ulong[]{0x200000000002UL});
		public static readonly BitSet _45_in_declare_local378 = new BitSet(new ulong[]{0x20000UL});
		public static readonly BitSet _more_var_in_declare_local380 = new BitSet(new ulong[]{0x200000000002UL});
		public static readonly BitSet _TYPE_in_local_var409 = new BitSet(new ulong[]{0x20000UL});
		public static readonly BitSet _ID_in_local_var411 = new BitSet(new ulong[]{0x10000000000002UL});
		public static readonly BitSet _52_in_local_var414 = new BitSet(new ulong[]{0x200224000UL});
		public static readonly BitSet _atom_in_local_var416 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_more_var446 = new BitSet(new ulong[]{0x10000000000002UL});
		public static readonly BitSet _52_in_more_var449 = new BitSet(new ulong[]{0x200224000UL});
		public static readonly BitSet _atom_in_more_var451 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _69_in_if_stat488 = new BitSet(new ulong[]{0x20200224000UL});
		public static readonly BitSet _logic_expression_in_if_stat492 = new BitSet(new ulong[]{0x4000000000000000UL});
		public static readonly BitSet _62_in_if_stat494 = new BitSet(new ulong[]{0xA000008000020000UL,0xFCUL});
		public static readonly BitSet _statement_in_if_stat498 = new BitSet(new ulong[]{0xA000008000020000UL,0xFCUL});
		public static readonly BitSet _senao_stat_in_if_stat506 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _63_in_if_stat534 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _70_in_senao_stat570 = new BitSet(new ulong[]{0xA000008000020000UL,0xBCUL});
		public static readonly BitSet _statement_in_senao_stat574 = new BitSet(new ulong[]{0xA000008000020000UL,0xBCUL});
		public static readonly BitSet _63_in_senao_stat577 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _66_in_for_stat597 = new BitSet(new ulong[]{0x20000UL});
		public static readonly BitSet _assign_var_in_for_stat599 = new BitSet(new ulong[]{0x400000000000000UL});
		public static readonly BitSet _58_in_for_stat601 = new BitSet(new ulong[]{0x220000UL});
		public static readonly BitSet _index_in_for_stat603 = new BitSet(new ulong[]{0xA800008000020000UL,0xBCUL});
		public static readonly BitSet _59_in_for_stat611 = new BitSet(new ulong[]{0xA000008000020000UL,0xBCUL});
		public static readonly BitSet _statement_in_for_stat613 = new BitSet(new ulong[]{0xA000008000020000UL,0xBCUL});
		public static readonly BitSet _63_in_for_stat616 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _statement_in_for_stat641 = new BitSet(new ulong[]{0xA000008000020000UL,0xBCUL});
		public static readonly BitSet _63_in_for_stat644 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _61_in_while_stat677 = new BitSet(new ulong[]{0x20200224000UL});
		public static readonly BitSet _logic_expression_in_while_stat679 = new BitSet(new ulong[]{0xA000008000020000UL,0xBCUL});
		public static readonly BitSet _statement_in_while_stat681 = new BitSet(new ulong[]{0xA000008000020000UL,0xBCUL});
		public static readonly BitSet _63_in_while_stat684 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _67_in_repeat_stat716 = new BitSet(new ulong[]{0x2400008000020000UL,0xBCUL});
		public static readonly BitSet _statement_in_repeat_stat718 = new BitSet(new ulong[]{0x2400008000020000UL,0xBCUL});
		public static readonly BitSet _58_in_repeat_stat721 = new BitSet(new ulong[]{0x20200224000UL});
		public static readonly BitSet _logic_expression_in_repeat_stat723 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_function_call771 = new BitSet(new ulong[]{0x20000000000UL});
		public static readonly BitSet _41_in_function_call773 = new BitSet(new ulong[]{0x60200224000UL});
		public static readonly BitSet _function_arg_list_in_function_call775 = new BitSet(new ulong[]{0x60200224000UL});
		public static readonly BitSet _42_in_function_call778 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_property_call819 = new BitSet(new ulong[]{0x800000000000UL});
		public static readonly BitSet _47_in_property_call820 = new BitSet(new ulong[]{0x20000UL});
		public static readonly BitSet _ID_in_property_call823 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_method_call867 = new BitSet(new ulong[]{0x800000000000UL});
		public static readonly BitSet _47_in_method_call868 = new BitSet(new ulong[]{0x20000UL});
		public static readonly BitSet _ID_in_method_call871 = new BitSet(new ulong[]{0x20000000000UL});
		public static readonly BitSet _41_in_method_call873 = new BitSet(new ulong[]{0x60200224000UL});
		public static readonly BitSet _function_arg_list_in_method_call875 = new BitSet(new ulong[]{0x60200224000UL});
		public static readonly BitSet _42_in_method_call878 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _plus_expression_in_function_arg_list923 = new BitSet(new ulong[]{0x200000000002UL});
		public static readonly BitSet _45_in_function_arg_list926 = new BitSet(new ulong[]{0x20200224000UL});
		public static readonly BitSet _plus_expression_in_function_arg_list928 = new BitSet(new ulong[]{0x200000000002UL});
		public static readonly BitSet _ID_in_assign_var980 = new BitSet(new ulong[]{0x10000000000000UL});
		public static readonly BitSet _52_in_assign_var982 = new BitSet(new ulong[]{0x100000000000000UL});
		public static readonly BitSet _56_in_assign_var984 = new BitSet(new ulong[]{0x200000UL});
		public static readonly BitSet _INT_in_assign_var986 = new BitSet(new ulong[]{0x1000000000000UL});
		public static readonly BitSet _48_in_assign_var988 = new BitSet(new ulong[]{0x200000UL});
		public static readonly BitSet _INT_in_assign_var990 = new BitSet(new ulong[]{0x200000000000000UL});
		public static readonly BitSet _57_in_assign_var992 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_assign_var1015 = new BitSet(new ulong[]{0x10000000000000UL});
		public static readonly BitSet _52_in_assign_var1017 = new BitSet(new ulong[]{0x0UL,0x100UL});
		public static readonly BitSet _72_in_assign_var1019 = new BitSet(new ulong[]{0x200000UL});
		public static readonly BitSet _INT_in_assign_var1021 = new BitSet(new ulong[]{0x200000000000UL,0x200UL});
		public static readonly BitSet _45_in_assign_var1024 = new BitSet(new ulong[]{0x200000UL});
		public static readonly BitSet _INT_in_assign_var1026 = new BitSet(new ulong[]{0x200000000000UL,0x200UL});
		public static readonly BitSet _73_in_assign_var1030 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_assign_var1050 = new BitSet(new ulong[]{0x100000000000000UL});
		public static readonly BitSet _56_in_assign_var1052 = new BitSet(new ulong[]{0x220000UL});
		public static readonly BitSet _index_in_assign_var1054 = new BitSet(new ulong[]{0x200000000000000UL});
		public static readonly BitSet _57_in_assign_var1056 = new BitSet(new ulong[]{0x10000000000000UL});
		public static readonly BitSet _52_in_assign_var1058 = new BitSet(new ulong[]{0x20200224000UL});
		public static readonly BitSet _assign_expression_in_assign_var1060 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_assign_var1089 = new BitSet(new ulong[]{0x10000000000000UL});
		public static readonly BitSet _52_in_assign_var1091 = new BitSet(new ulong[]{0x20200224000UL});
		public static readonly BitSet _assign_expression_in_assign_var1093 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _68_in_return_stat1116 = new BitSet(new ulong[]{0x20200224000UL});
		public static readonly BitSet _assign_expression_in_return_stat1118 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _39_in_asm_code1137 = new BitSet(new ulong[]{0x8200000000UL});
		public static readonly BitSet _STRING_in_asm_code1139 = new BitSet(new ulong[]{0x8200000000UL});
		public static readonly BitSet _39_in_asm_code1142 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _plus_expression_in_logic_expression1174 = new BitSet(new ulong[]{0x10EC004000000002UL,0x2UL});
		public static readonly BitSet _binop_in_logic_expression1178 = new BitSet(new ulong[]{0x20200224000UL});
		public static readonly BitSet _plus_expression_in_logic_expression1181 = new BitSet(new ulong[]{0x10EC004000000002UL,0x2UL});
		public static readonly BitSet _plus_expression_in_assign_expression1242 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _mul_expression_in_plus_expression1252 = new BitSet(new ulong[]{0x500000000002UL});
		public static readonly BitSet _44_in_plus_expression1256 = new BitSet(new ulong[]{0x20200224000UL});
		public static readonly BitSet _mul_expression_in_plus_expression1259 = new BitSet(new ulong[]{0x500000000002UL});
		public static readonly BitSet _46_in_plus_expression1263 = new BitSet(new ulong[]{0x20200224000UL});
		public static readonly BitSet _mul_expression_in_plus_expression1266 = new BitSet(new ulong[]{0x500000000002UL});
		public static readonly BitSet _primary_ar_expression_in_mul_expression1281 = new BitSet(new ulong[]{0x2090000000002UL});
		public static readonly BitSet _49_in_mul_expression1286 = new BitSet(new ulong[]{0x20200224000UL});
		public static readonly BitSet _primary_ar_expression_in_mul_expression1289 = new BitSet(new ulong[]{0x2090000000002UL});
		public static readonly BitSet _40_in_mul_expression1293 = new BitSet(new ulong[]{0x20200224000UL});
		public static readonly BitSet _primary_ar_expression_in_mul_expression1296 = new BitSet(new ulong[]{0x2090000000002UL});
		public static readonly BitSet _43_in_mul_expression1300 = new BitSet(new ulong[]{0x20200224000UL});
		public static readonly BitSet _primary_ar_expression_in_mul_expression1303 = new BitSet(new ulong[]{0x2090000000002UL});
		public static readonly BitSet _function_call_in_primary_ar_expression1321 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_primary_ar_expression1326 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_primary_ar_expression1331 = new BitSet(new ulong[]{0x100000000000000UL});
		public static readonly BitSet _56_in_primary_ar_expression1333 = new BitSet(new ulong[]{0x220000UL});
		public static readonly BitSet _index_in_primary_ar_expression1335 = new BitSet(new ulong[]{0x200000000000000UL});
		public static readonly BitSet _57_in_primary_ar_expression1337 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _method_call_in_primary_ar_expression1352 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _property_call_in_primary_ar_expression1358 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _constant_in_primary_ar_expression1363 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _parenthesisExpression_in_primary_ar_expression1368 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _41_in_parenthesisExpression1383 = new BitSet(new ulong[]{0x20200224000UL});
		public static readonly BitSet _plus_expression_in_parenthesisExpression1385 = new BitSet(new ulong[]{0x40000000000UL});
		public static readonly BitSet _42_in_parenthesisExpression1387 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _constant_in_atom1418 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_atom1422 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _function_arg_list_in_synpred25_NPortugol775 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _function_arg_list_in_synpred26_NPortugol875 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_synpred28_NPortugol980 = new BitSet(new ulong[]{0x10000000000000UL});
		public static readonly BitSet _52_in_synpred28_NPortugol982 = new BitSet(new ulong[]{0x100000000000000UL});
		public static readonly BitSet _56_in_synpred28_NPortugol984 = new BitSet(new ulong[]{0x200000UL});
		public static readonly BitSet _INT_in_synpred28_NPortugol986 = new BitSet(new ulong[]{0x1000000000000UL});
		public static readonly BitSet _48_in_synpred28_NPortugol988 = new BitSet(new ulong[]{0x200000UL});
		public static readonly BitSet _INT_in_synpred28_NPortugol990 = new BitSet(new ulong[]{0x200000000000000UL});
		public static readonly BitSet _57_in_synpred28_NPortugol992 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_synpred30_NPortugol1015 = new BitSet(new ulong[]{0x10000000000000UL});
		public static readonly BitSet _52_in_synpred30_NPortugol1017 = new BitSet(new ulong[]{0x0UL,0x100UL});
		public static readonly BitSet _72_in_synpred30_NPortugol1019 = new BitSet(new ulong[]{0x200000UL});
		public static readonly BitSet _INT_in_synpred30_NPortugol1021 = new BitSet(new ulong[]{0x200000000000UL,0x200UL});
		public static readonly BitSet _45_in_synpred30_NPortugol1024 = new BitSet(new ulong[]{0x200000UL});
		public static readonly BitSet _INT_in_synpred30_NPortugol1026 = new BitSet(new ulong[]{0x200000000000UL,0x200UL});
		public static readonly BitSet _73_in_synpred30_NPortugol1030 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _function_call_in_synpred46_NPortugol1321 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_synpred47_NPortugol1326 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _method_call_in_synpred49_NPortugol1352 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _property_call_in_synpred50_NPortugol1358 = new BitSet(new ulong[]{0x2UL});
	}
	#endregion Follow sets
}

} // namespace NPortugol2.Compiler
