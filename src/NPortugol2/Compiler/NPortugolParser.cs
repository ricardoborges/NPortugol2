//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.4
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.4 E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g 2012-10-15 14:18:52

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019

using System.Collections;

using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;


using Antlr.Runtime.Tree;
using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;

namespace NPortugol2.Compiler
{
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.4")]
[System.CLSCompliant(false)]
public partial class NPortugolParser : Antlr.Runtime.Parser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "AR", "ARG", "ASGN", "ASM", "CALL", "CHAR", "DEC", "ESC_SEQ", "EXP", "EXPONENT", "FLOAT", "FUNC", "HEX_DIGIT", "ID", "ILIST", "INDEX", "INIT", "INT", "JMP", "LEXP", "LOOP", "MCALL", "NEWLINE", "OCTAL_ESC", "PARAM", "PCALL", "RET", "SJMP", "SLIST", "STRING", "TYPE", "UNICODE_ESC", "VAR", "WS", "'!='", "'#'", "'%'", "'('", "')'", "'*'", "'+'", "','", "'-'", "'.'", "'..'", "'/'", "'<'", "'<='", "'='", "'=='", "'>'", "'>='", "'['", "']'", "'ate'", "'dec'", "'e'", "'enquanto'", "'entao'", "'fim'", "'funcao'", "'ou'", "'para'", "'repita'", "'retorne'", "'se'", "'senao'", "'variavel'", "'{'", "'}'"
	};
	public const int EOF=-1;
	public const int T__38=38;
	public const int T__39=39;
	public const int T__40=40;
	public const int T__41=41;
	public const int T__42=42;
	public const int T__43=43;
	public const int T__44=44;
	public const int T__45=45;
	public const int T__46=46;
	public const int T__47=47;
	public const int T__48=48;
	public const int T__49=49;
	public const int T__50=50;
	public const int T__51=51;
	public const int T__52=52;
	public const int T__53=53;
	public const int T__54=54;
	public const int T__55=55;
	public const int T__56=56;
	public const int T__57=57;
	public const int T__58=58;
	public const int T__59=59;
	public const int T__60=60;
	public const int T__61=61;
	public const int T__62=62;
	public const int T__63=63;
	public const int T__64=64;
	public const int T__65=65;
	public const int T__66=66;
	public const int T__67=67;
	public const int T__68=68;
	public const int T__69=69;
	public const int T__70=70;
	public const int T__71=71;
	public const int T__72=72;
	public const int T__73=73;
	public const int AR=4;
	public const int ARG=5;
	public const int ASGN=6;
	public const int ASM=7;
	public const int CALL=8;
	public const int CHAR=9;
	public const int DEC=10;
	public const int ESC_SEQ=11;
	public const int EXP=12;
	public const int EXPONENT=13;
	public const int FLOAT=14;
	public const int FUNC=15;
	public const int HEX_DIGIT=16;
	public const int ID=17;
	public const int ILIST=18;
	public const int INDEX=19;
	public const int INIT=20;
	public const int INT=21;
	public const int JMP=22;
	public const int LEXP=23;
	public const int LOOP=24;
	public const int MCALL=25;
	public const int NEWLINE=26;
	public const int OCTAL_ESC=27;
	public const int PARAM=28;
	public const int PCALL=29;
	public const int RET=30;
	public const int SJMP=31;
	public const int SLIST=32;
	public const int STRING=33;
	public const int TYPE=34;
	public const int UNICODE_ESC=35;
	public const int VAR=36;
	public const int WS=37;

	public NPortugolParser(ITokenStream input)
		: this(input, new RecognizerSharedState())
	{
	}
	public NPortugolParser(ITokenStream input, RecognizerSharedState state)
		: base(input, state)
	{
		ITreeAdaptor treeAdaptor = default(ITreeAdaptor);
		CreateTreeAdaptor(ref treeAdaptor);
		TreeAdaptor = treeAdaptor ?? new CommonTreeAdaptor();
		OnCreated();
	}
	// Implement this function in your helper file to use a custom tree adaptor
	partial void CreateTreeAdaptor(ref ITreeAdaptor adaptor);

	private ITreeAdaptor adaptor;

	public ITreeAdaptor TreeAdaptor
	{
		get
		{
			return adaptor;
		}

		set
		{
			this.adaptor = value;
		}
	}

	public override string[] TokenNames { get { return NPortugolParser.tokenNames; } }
	public override string GrammarFileName { get { return "E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g"; } }



		Stack<string> paraphrases = new Stack<string>();
		
	        public string GetErrorMessage(RecognitionException e)
	        {
	            string msg = "Erro na linha {0} posição {1}: '{2}'";
		    msg = string.Format(msg, e.Line, e.CharPositionInLine, e.Token.Text);
	            if (paraphrases.Count > 0){
	                string paraphrase = (string)paraphrases.Pop();
	                msg = msg + " " + paraphrase;
	            }
	            return msg;
	        }
		protected void mismatch(IIntStream input, int ttype, BitSet follow)	{
			throw new MismatchedTokenException(ttype, input);
		}
		public void recoverFromMismatchedSet(IIntStream input,RecognitionException e, BitSet follow) {
			throw e;
		}

		public List<string> Functions = new List<string>();
		public List<string> Symbols = new List<string>();	
		public bool IsDefinedID(string id){    return Symbols.Contains(id);}
		public bool IsDefined(string name) { return Functions.Contains(name); }
		public void DefineID(IList<IToken> ids){ foreach(var id in ids) { Symbols.Add(id.Text); }}
		public void DefineFunction(string name){ Functions.Add(name);}	


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	#region Rules
	partial void EnterRule_script();
	partial void LeaveRule_script();

	// $ANTLR start "script"
	// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:73:8: public script : ( declare_function )* ;
	[GrammarRule("script")]
	public AstParserRuleReturnScope<object, IToken> script()
	{
		EnterRule_script();
		EnterRule("script", 1);
		TraceIn("script", 1);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> declare_function1 = default(AstParserRuleReturnScope<object, IToken>);

		try { DebugEnterRule(GrammarFileName, "script");
		DebugLocation(73, 34);
		try
		{
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:73:15: ( ( declare_function )* )
			DebugEnterAlt(1);
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:73:17: ( declare_function )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(73, 17);
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:73:17: ( declare_function )*
			try { DebugEnterSubRule(1);
			while (true)
			{
				int alt1=2;
				try { DebugEnterDecision(1, false);
				int LA1_0 = input.LA(1);

				if ((LA1_0==64))
				{
					alt1 = 1;
				}


				} finally { DebugExitDecision(1); }
				switch ( alt1 )
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:73:17: declare_function
					{
					DebugLocation(73, 17);
					PushFollow(Follow._declare_function_in_script148);
					declare_function1=declare_function();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, declare_function1.Tree);

					}
					break;

				default:
					goto loop1;
				}
			}

			loop1:
				;

			} finally { DebugExitSubRule(1); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

			catch (RecognitionException e) {
				throw e;
			}

		finally
		{
			TraceOut("script", 1);
			LeaveRule("script", 1);
			LeaveRule_script();
		}
		DebugLocation(73, 34);
		} finally { DebugExitRule(GrammarFileName, "script"); }
		return retval;

	}
	// $ANTLR end "script"

	partial void EnterRule_declare_function();
	partial void LeaveRule_declare_function();

	// $ANTLR start "declare_function"
	// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:75:1: declare_function : 'funcao' (t= TYPE )? i= ID '(' ( function_param_list )* ')' ( statement )* 'fim' -> ^( FUNC ( TYPE )? ID ( function_param_list )* ^( SLIST ( statement )* ) ) ;
	[GrammarRule("declare_function")]
	private AstParserRuleReturnScope<object, IToken> declare_function()
	{
		EnterRule_declare_function();
		EnterRule("declare_function", 2);
		TraceIn("declare_function", 2);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken t = default(IToken);
		IToken i = default(IToken);
		IToken string_literal2 = default(IToken);
		IToken char_literal3 = default(IToken);
		IToken char_literal5 = default(IToken);
		IToken string_literal7 = default(IToken);
		AstParserRuleReturnScope<object, IToken> function_param_list4 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> statement6 = default(AstParserRuleReturnScope<object, IToken>);

		object t_tree = default(object);
		object i_tree = default(object);
		object string_literal2_tree = default(object);
		object char_literal3_tree = default(object);
		object char_literal5_tree = default(object);
		object string_literal7_tree = default(object);
		RewriteRuleITokenStream stream_42=new RewriteRuleITokenStream(adaptor,"token 42");
		RewriteRuleITokenStream stream_41=new RewriteRuleITokenStream(adaptor,"token 41");
		RewriteRuleITokenStream stream_64=new RewriteRuleITokenStream(adaptor,"token 64");
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleITokenStream stream_63=new RewriteRuleITokenStream(adaptor,"token 63");
		RewriteRuleITokenStream stream_TYPE=new RewriteRuleITokenStream(adaptor,"token TYPE");
		RewriteRuleSubtreeStream stream_statement=new RewriteRuleSubtreeStream(adaptor,"rule statement");
		RewriteRuleSubtreeStream stream_function_param_list=new RewriteRuleSubtreeStream(adaptor,"rule function_param_list");
		try { DebugEnterRule(GrammarFileName, "declare_function");
		DebugLocation(75, 1);
		try
		{
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:76:2: ( 'funcao' (t= TYPE )? i= ID '(' ( function_param_list )* ')' ( statement )* 'fim' -> ^( FUNC ( TYPE )? ID ( function_param_list )* ^( SLIST ( statement )* ) ) )
			DebugEnterAlt(1);
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:76:4: 'funcao' (t= TYPE )? i= ID '(' ( function_param_list )* ')' ( statement )* 'fim'
			{
			DebugLocation(76, 4);
			string_literal2=(IToken)Match(input,64,Follow._64_in_declare_function159); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_64.Add(string_literal2);

			DebugLocation(76, 14);
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:76:14: (t= TYPE )?
			int alt2=2;
			try { DebugEnterSubRule(2);
			try { DebugEnterDecision(2, false);
			int LA2_0 = input.LA(1);

			if ((LA2_0==TYPE))
			{
				alt2 = 1;
			}
			} finally { DebugExitDecision(2); }
			switch (alt2)
			{
			case 1:
				DebugEnterAlt(1);
				// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:76:14: t= TYPE
				{
				DebugLocation(76, 14);
				t=(IToken)Match(input,TYPE,Follow._TYPE_in_declare_function163); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_TYPE.Add(t);


				}
				break;

			}
			} finally { DebugExitSubRule(2); }

			DebugLocation(76, 22);
			i=(IToken)Match(input,ID,Follow._ID_in_declare_function168); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ID.Add(i);

			DebugLocation(76, 26);
			char_literal3=(IToken)Match(input,41,Follow._41_in_declare_function170); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_41.Add(char_literal3);

			DebugLocation(76, 30);
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:76:30: ( function_param_list )*
			try { DebugEnterSubRule(3);
			while (true)
			{
				int alt3=2;
				try { DebugEnterDecision(3, false);
				int LA3_0 = input.LA(1);

				if ((LA3_0==TYPE))
				{
					alt3 = 1;
				}


				} finally { DebugExitDecision(3); }
				switch ( alt3 )
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:76:30: function_param_list
					{
					DebugLocation(76, 30);
					PushFollow(Follow._function_param_list_in_declare_function172);
					function_param_list4=function_param_list();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_function_param_list.Add(function_param_list4.Tree);

					}
					break;

				default:
					goto loop3;
				}
			}

			loop3:
				;

			} finally { DebugExitSubRule(3); }

			DebugLocation(76, 51);
			char_literal5=(IToken)Match(input,42,Follow._42_in_declare_function175); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_42.Add(char_literal5);

			DebugLocation(76, 55);
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:76:55: ( statement )*
			try { DebugEnterSubRule(4);
			while (true)
			{
				int alt4=2;
				try { DebugEnterDecision(4, false);
				int LA4_0 = input.LA(1);

				if ((LA4_0==ID||LA4_0==39||LA4_0==61||(LA4_0>=66 && LA4_0<=69)||LA4_0==71))
				{
					alt4 = 1;
				}


				} finally { DebugExitDecision(4); }
				switch ( alt4 )
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:76:55: statement
					{
					DebugLocation(76, 55);
					PushFollow(Follow._statement_in_declare_function177);
					statement6=statement();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_statement.Add(statement6.Tree);

					}
					break;

				default:
					goto loop4;
				}
			}

			loop4:
				;

			} finally { DebugExitSubRule(4); }

			DebugLocation(76, 66);
			string_literal7=(IToken)Match(input,63,Follow._63_in_declare_function180); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_63.Add(string_literal7);

			DebugLocation(77, 3);
			if (state.backtracking == 0)
			{
				DefineFunction((i!=null?i.Text:null));
			}


			{
			// AST REWRITE
			// elements: ID, function_param_list, statement, TYPE
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 78:3: -> ^( FUNC ( TYPE )? ID ( function_param_list )* ^( SLIST ( statement )* ) )
			{
				DebugLocation(78, 6);
				// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:78:6: ^( FUNC ( TYPE )? ID ( function_param_list )* ^( SLIST ( statement )* ) )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(78, 8);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(FUNC, "FUNC"), root_1);

				DebugLocation(78, 13);
				// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:78:13: ( TYPE )?
				if (stream_TYPE.HasNext)
				{
					DebugLocation(78, 13);
					adaptor.AddChild(root_1, stream_TYPE.NextNode());

				}
				stream_TYPE.Reset();
				DebugLocation(78, 19);
				adaptor.AddChild(root_1, stream_ID.NextNode());
				DebugLocation(78, 22);
				// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:78:22: ( function_param_list )*
				while ( stream_function_param_list.HasNext )
				{
					DebugLocation(78, 22);
					adaptor.AddChild(root_1, stream_function_param_list.NextTree());

				}
				stream_function_param_list.Reset();
				DebugLocation(78, 43);
				// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:78:43: ^( SLIST ( statement )* )
				{
				object root_2 = (object)adaptor.Nil();
				DebugLocation(78, 45);
				root_2 = (object)adaptor.BecomeRoot((object)adaptor.Create(SLIST, "SLIST"), root_2);

				DebugLocation(78, 51);
				// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:78:51: ( statement )*
				while ( stream_statement.HasNext )
				{
					DebugLocation(78, 51);
					adaptor.AddChild(root_2, stream_statement.NextTree());

				}
				stream_statement.Reset();

				adaptor.AddChild(root_1, root_2);
				}

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

			catch (RecognitionException e) {
				throw e;
			}

		finally
		{
			TraceOut("declare_function", 2);
			LeaveRule("declare_function", 2);
			LeaveRule_declare_function();
		}
		DebugLocation(79, 1);
		} finally { DebugExitRule(GrammarFileName, "declare_function"); }
		return retval;

	}
	// $ANTLR end "declare_function"

	partial void EnterRule_statement();
	partial void LeaveRule_statement();

	// $ANTLR start "statement"
	// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:81:1: statement : ( declare_local | if_stat | for_stat | while_stat | repeat_stat | function_call | assign_var | return_stat | asm_code );
	[GrammarRule("statement")]
	private AstParserRuleReturnScope<object, IToken> statement()
	{
		EnterRule_statement();
		EnterRule("statement", 3);
		TraceIn("statement", 3);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> declare_local8 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> if_stat9 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> for_stat10 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> while_stat11 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> repeat_stat12 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> function_call13 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> assign_var14 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> return_stat15 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> asm_code16 = default(AstParserRuleReturnScope<object, IToken>);

		 paraphrases.Push("na sentença"); 
		try { DebugEnterRule(GrammarFileName, "statement");
		DebugLocation(81, 1);
		try
		{
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:83:2: ( declare_local | if_stat | for_stat | while_stat | repeat_stat | function_call | assign_var | return_stat | asm_code )
			int alt5=9;
			try { DebugEnterDecision(5, false);
			switch (input.LA(1))
			{
			case 71:
				{
				alt5 = 1;
				}
				break;
			case 69:
				{
				alt5 = 2;
				}
				break;
			case 66:
				{
				alt5 = 3;
				}
				break;
			case 61:
				{
				alt5 = 4;
				}
				break;
			case 67:
				{
				alt5 = 5;
				}
				break;
			case ID:
				{
				int LA5_6 = input.LA(2);

				if ((LA5_6==41))
				{
					alt5 = 6;
				}
				else if ((LA5_6==52||LA5_6==56))
				{
					alt5 = 7;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 5, 6, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case 68:
				{
				alt5 = 8;
				}
				break;
			case 39:
				{
				alt5 = 9;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 5, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(5); }
			switch (alt5)
			{
			case 1:
				DebugEnterAlt(1);
				// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:83:4: declare_local
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(83, 4);
				PushFollow(Follow._declare_local_in_statement230);
				declare_local8=declare_local();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, declare_local8.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:84:4: if_stat
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(84, 4);
				PushFollow(Follow._if_stat_in_statement236);
				if_stat9=if_stat();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, if_stat9.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:85:4: for_stat
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(85, 4);
				PushFollow(Follow._for_stat_in_statement242);
				for_stat10=for_stat();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, for_stat10.Tree);

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:86:4: while_stat
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(86, 4);
				PushFollow(Follow._while_stat_in_statement247);
				while_stat11=while_stat();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, while_stat11.Tree);

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:87:4: repeat_stat
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(87, 4);
				PushFollow(Follow._repeat_stat_in_statement252);
				repeat_stat12=repeat_stat();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, repeat_stat12.Tree);

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:88:4: function_call
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(88, 4);
				PushFollow(Follow._function_call_in_statement258);
				function_call13=function_call();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, function_call13.Tree);

				}
				break;
			case 7:
				DebugEnterAlt(7);
				// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:89:4: assign_var
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(89, 4);
				PushFollow(Follow._assign_var_in_statement264);
				assign_var14=assign_var();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, assign_var14.Tree);

				}
				break;
			case 8:
				DebugEnterAlt(8);
				// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:90:4: return_stat
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(90, 4);
				PushFollow(Follow._return_stat_in_statement270);
				return_stat15=return_stat();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, return_stat15.Tree);

				}
				break;
			case 9:
				DebugEnterAlt(9);
				// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:91:4: asm_code
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(91, 4);
				PushFollow(Follow._asm_code_in_statement275);
				asm_code16=asm_code();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, asm_code16.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
			if (state.backtracking == 0)
			{
				 paraphrases.Pop(); 
			}
		}

			catch (RecognitionException e) {
				throw e;
			}

		finally
		{
			TraceOut("statement", 3);
			LeaveRule("statement", 3);
			LeaveRule_statement();
		}
		DebugLocation(92, 1);
		} finally { DebugExitRule(GrammarFileName, "statement"); }
		return retval;

	}
	// $ANTLR end "statement"

	partial void EnterRule_function_param_list();
	partial void LeaveRule_function_param_list();

	// $ANTLR start "function_param_list"
	// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:94:1: function_param_list : param ( ',' param )* -> ^( PARAM ( param )* ) ;
	[GrammarRule("function_param_list")]
	private AstParserRuleReturnScope<object, IToken> function_param_list()
	{
		EnterRule_function_param_list();
		EnterRule("function_param_list", 4);
		TraceIn("function_param_list", 4);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken char_literal18 = default(IToken);
		AstParserRuleReturnScope<object, IToken> param17 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> param19 = default(AstParserRuleReturnScope<object, IToken>);

		object char_literal18_tree = default(object);
		RewriteRuleITokenStream stream_45=new RewriteRuleITokenStream(adaptor,"token 45");
		RewriteRuleSubtreeStream stream_param=new RewriteRuleSubtreeStream(adaptor,"rule param");
		 paraphrases.Push("na lista de parâmetros"); 
		try { DebugEnterRule(GrammarFileName, "function_param_list");
		DebugLocation(94, 1);
		try
		{
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:95:2: ( param ( ',' param )* -> ^( PARAM ( param )* ) )
			DebugEnterAlt(1);
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:95:4: param ( ',' param )*
			{
			DebugLocation(95, 4);
			PushFollow(Follow._param_in_function_param_list303);
			param17=param();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_param.Add(param17.Tree);
			DebugLocation(95, 10);
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:95:10: ( ',' param )*
			try { DebugEnterSubRule(6);
			while (true)
			{
				int alt6=2;
				try { DebugEnterDecision(6, false);
				int LA6_0 = input.LA(1);

				if ((LA6_0==45))
				{
					alt6 = 1;
				}


				} finally { DebugExitDecision(6); }
				switch ( alt6 )
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:95:11: ',' param
					{
					DebugLocation(95, 11);
					char_literal18=(IToken)Match(input,45,Follow._45_in_function_param_list306); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_45.Add(char_literal18);

					DebugLocation(95, 15);
					PushFollow(Follow._param_in_function_param_list308);
					param19=param();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_param.Add(param19.Tree);

					}
					break;

				default:
					goto loop6;
				}
			}

			loop6:
				;

			} finally { DebugExitSubRule(6); }



			{
			// AST REWRITE
			// elements: param
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 95:23: -> ^( PARAM ( param )* )
			{
				DebugLocation(95, 26);
				// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:95:26: ^( PARAM ( param )* )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(95, 28);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(PARAM, "PARAM"), root_1);

				DebugLocation(95, 34);
				// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:95:34: ( param )*
				while ( stream_param.HasNext )
				{
					DebugLocation(95, 34);
					adaptor.AddChild(root_1, stream_param.NextTree());

				}
				stream_param.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
			if (state.backtracking == 0)
			{
				 paraphrases.Pop(); 
			}
		}

			catch (RecognitionException e) {
				throw e;
			}

		finally
		{
			TraceOut("function_param_list", 4);
			LeaveRule("function_param_list", 4);
			LeaveRule_function_param_list();
		}
		DebugLocation(96, 1);
		} finally { DebugExitRule(GrammarFileName, "function_param_list"); }
		return retval;

	}
	// $ANTLR end "function_param_list"

	partial void EnterRule_param();
	partial void LeaveRule_param();

	// $ANTLR start "param"
	// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:98:1: param : TYPE ID -> ^( TYPE ID ) ;
	[GrammarRule("param")]
	private AstParserRuleReturnScope<object, IToken> param()
	{
		EnterRule_param();
		EnterRule("param", 5);
		TraceIn("param", 5);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken TYPE20 = default(IToken);
		IToken ID21 = default(IToken);

		object TYPE20_tree = default(object);
		object ID21_tree = default(object);
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleITokenStream stream_TYPE=new RewriteRuleITokenStream(adaptor,"token TYPE");
		try { DebugEnterRule(GrammarFileName, "param");
		DebugLocation(98, 29);
		try
		{
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:98:7: ( TYPE ID -> ^( TYPE ID ) )
			DebugEnterAlt(1);
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:98:9: TYPE ID
			{
			DebugLocation(98, 9);
			TYPE20=(IToken)Match(input,TYPE,Follow._TYPE_in_param331); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_TYPE.Add(TYPE20);

			DebugLocation(98, 14);
			ID21=(IToken)Match(input,ID,Follow._ID_in_param333); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ID.Add(ID21);



			{
			// AST REWRITE
			// elements: ID, TYPE
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 98:17: -> ^( TYPE ID )
			{
				DebugLocation(98, 20);
				// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:98:20: ^( TYPE ID )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(98, 22);
				root_1 = (object)adaptor.BecomeRoot(stream_TYPE.NextNode(), root_1);

				DebugLocation(98, 27);
				adaptor.AddChild(root_1, stream_ID.NextNode());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

			catch (RecognitionException e) {
				throw e;
			}

		finally
		{
			TraceOut("param", 5);
			LeaveRule("param", 5);
			LeaveRule_param();
		}
		DebugLocation(98, 29);
		} finally { DebugExitRule(GrammarFileName, "param"); }
		return retval;

	}
	// $ANTLR end "param"

	partial void EnterRule_declare_local();
	partial void LeaveRule_declare_local();

	// $ANTLR start "declare_local"
	// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:100:1: declare_local : 'variavel' local_var ( ',' ID )* -> ^( VAR local_var ( ID )* ) ;
	[GrammarRule("declare_local")]
	private AstParserRuleReturnScope<object, IToken> declare_local()
	{
		EnterRule_declare_local();
		EnterRule("declare_local", 6);
		TraceIn("declare_local", 6);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken string_literal22 = default(IToken);
		IToken char_literal24 = default(IToken);
		IToken ID25 = default(IToken);
		AstParserRuleReturnScope<object, IToken> local_var23 = default(AstParserRuleReturnScope<object, IToken>);

		object string_literal22_tree = default(object);
		object char_literal24_tree = default(object);
		object ID25_tree = default(object);
		RewriteRuleITokenStream stream_45=new RewriteRuleITokenStream(adaptor,"token 45");
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleITokenStream stream_71=new RewriteRuleITokenStream(adaptor,"token 71");
		RewriteRuleSubtreeStream stream_local_var=new RewriteRuleSubtreeStream(adaptor,"rule local_var");
		 paraphrases.Push("na definição de variável"); 
		try { DebugEnterRule(GrammarFileName, "declare_local");
		DebugLocation(100, 1);
		try
		{
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:101:2: ( 'variavel' local_var ( ',' ID )* -> ^( VAR local_var ( ID )* ) )
			DebugEnterAlt(1);
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:101:4: 'variavel' local_var ( ',' ID )*
			{
			DebugLocation(101, 4);
			string_literal22=(IToken)Match(input,71,Follow._71_in_declare_local373); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_71.Add(string_literal22);

			DebugLocation(101, 15);
			PushFollow(Follow._local_var_in_declare_local375);
			local_var23=local_var();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_local_var.Add(local_var23.Tree);
			DebugLocation(101, 25);
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:101:25: ( ',' ID )*
			try { DebugEnterSubRule(7);
			while (true)
			{
				int alt7=2;
				try { DebugEnterDecision(7, false);
				int LA7_0 = input.LA(1);

				if ((LA7_0==45))
				{
					alt7 = 1;
				}


				} finally { DebugExitDecision(7); }
				switch ( alt7 )
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:101:26: ',' ID
					{
					DebugLocation(101, 26);
					char_literal24=(IToken)Match(input,45,Follow._45_in_declare_local378); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_45.Add(char_literal24);

					DebugLocation(101, 30);
					ID25=(IToken)Match(input,ID,Follow._ID_in_declare_local380); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_ID.Add(ID25);


					}
					break;

				default:
					goto loop7;
				}
			}

			loop7:
				;

			} finally { DebugExitSubRule(7); }



			{
			// AST REWRITE
			// elements: ID, local_var
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 102:2: -> ^( VAR local_var ( ID )* )
			{
				DebugLocation(102, 5);
				// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:102:5: ^( VAR local_var ( ID )* )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(102, 7);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(VAR, "VAR"), root_1);

				DebugLocation(102, 11);
				adaptor.AddChild(root_1, stream_local_var.NextTree());
				DebugLocation(102, 21);
				// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:102:21: ( ID )*
				while ( stream_ID.HasNext )
				{
					DebugLocation(102, 21);
					adaptor.AddChild(root_1, stream_ID.NextNode());

				}
				stream_ID.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
			if (state.backtracking == 0)
			{
				 paraphrases.Pop(); 
			}
		}

			catch (RecognitionException e) {
				throw e;
			}

		finally
		{
			TraceOut("declare_local", 6);
			LeaveRule("declare_local", 6);
			LeaveRule_declare_local();
		}
		DebugLocation(103, 1);
		} finally { DebugExitRule(GrammarFileName, "declare_local"); }
		return retval;

	}
	// $ANTLR end "declare_local"

	partial void EnterRule_local_var();
	partial void LeaveRule_local_var();

	// $ANTLR start "local_var"
	// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:105:1: local_var : TYPE ID -> ^( TYPE ID ) ;
	[GrammarRule("local_var")]
	private AstParserRuleReturnScope<object, IToken> local_var()
	{
		EnterRule_local_var();
		EnterRule("local_var", 7);
		TraceIn("local_var", 7);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken TYPE26 = default(IToken);
		IToken ID27 = default(IToken);

		object TYPE26_tree = default(object);
		object ID27_tree = default(object);
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleITokenStream stream_TYPE=new RewriteRuleITokenStream(adaptor,"token TYPE");
		try { DebugEnterRule(GrammarFileName, "local_var");
		DebugLocation(105, 32);
		try
		{
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:105:10: ( TYPE ID -> ^( TYPE ID ) )
			DebugEnterAlt(1);
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:105:12: TYPE ID
			{
			DebugLocation(105, 12);
			TYPE26=(IToken)Match(input,TYPE,Follow._TYPE_in_local_var406); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_TYPE.Add(TYPE26);

			DebugLocation(105, 17);
			ID27=(IToken)Match(input,ID,Follow._ID_in_local_var408); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ID.Add(ID27);



			{
			// AST REWRITE
			// elements: TYPE, ID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 105:20: -> ^( TYPE ID )
			{
				DebugLocation(105, 23);
				// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:105:23: ^( TYPE ID )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(105, 25);
				root_1 = (object)adaptor.BecomeRoot(stream_TYPE.NextNode(), root_1);

				DebugLocation(105, 30);
				adaptor.AddChild(root_1, stream_ID.NextNode());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

			catch (RecognitionException e) {
				throw e;
			}

		finally
		{
			TraceOut("local_var", 7);
			LeaveRule("local_var", 7);
			LeaveRule_local_var();
		}
		DebugLocation(105, 32);
		} finally { DebugExitRule(GrammarFileName, "local_var"); }
		return retval;

	}
	// $ANTLR end "local_var"

	partial void EnterRule_if_stat();
	partial void LeaveRule_if_stat();

	// $ANTLR start "if_stat"
	// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:107:1: if_stat : 'se' p= logic_expression 'entao' (s1+= statement )* (s2= senao_stat -> ^( SJMP ^( LEXP $p) ^( SLIST $s1 $s2) ) | 'fim' -> ^( JMP ^( LEXP $p) ^( SLIST ( $s1)* ) ) ) ;
	[GrammarRule("if_stat")]
	private AstParserRuleReturnScope<object, IToken> if_stat()
	{
		EnterRule_if_stat();
		EnterRule("if_stat", 8);
		TraceIn("if_stat", 8);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken string_literal28 = default(IToken);
		IToken string_literal29 = default(IToken);
		IToken string_literal30 = default(IToken);
		List<object> list_s1 = null;
		AstParserRuleReturnScope<object, IToken> p = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> s2 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> s1 = default(AstParserRuleReturnScope<object, IToken>);
		object string_literal28_tree = default(object);
		object string_literal29_tree = default(object);
		object string_literal30_tree = default(object);
		RewriteRuleITokenStream stream_69=new RewriteRuleITokenStream(adaptor,"token 69");
		RewriteRuleITokenStream stream_62=new RewriteRuleITokenStream(adaptor,"token 62");
		RewriteRuleITokenStream stream_63=new RewriteRuleITokenStream(adaptor,"token 63");
		RewriteRuleSubtreeStream stream_statement=new RewriteRuleSubtreeStream(adaptor,"rule statement");
		RewriteRuleSubtreeStream stream_logic_expression=new RewriteRuleSubtreeStream(adaptor,"rule logic_expression");
		RewriteRuleSubtreeStream stream_senao_stat=new RewriteRuleSubtreeStream(adaptor,"rule senao_stat");
		 paraphrases.Push("se"); 
		try { DebugEnterRule(GrammarFileName, "if_stat");
		DebugLocation(107, 1);
		try
		{
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:109:2: ( 'se' p= logic_expression 'entao' (s1+= statement )* (s2= senao_stat -> ^( SJMP ^( LEXP $p) ^( SLIST $s1 $s2) ) | 'fim' -> ^( JMP ^( LEXP $p) ^( SLIST ( $s1)* ) ) ) )
			DebugEnterAlt(1);
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:109:4: 'se' p= logic_expression 'entao' (s1+= statement )* (s2= senao_stat -> ^( SJMP ^( LEXP $p) ^( SLIST $s1 $s2) ) | 'fim' -> ^( JMP ^( LEXP $p) ^( SLIST ( $s1)* ) ) )
			{
			DebugLocation(109, 4);
			string_literal28=(IToken)Match(input,69,Follow._69_in_if_stat440); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_69.Add(string_literal28);

			DebugLocation(109, 10);
			PushFollow(Follow._logic_expression_in_if_stat444);
			p=logic_expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_logic_expression.Add(p.Tree);
			DebugLocation(109, 28);
			string_literal29=(IToken)Match(input,62,Follow._62_in_if_stat446); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_62.Add(string_literal29);

			DebugLocation(109, 38);
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:109:38: (s1+= statement )*
			try { DebugEnterSubRule(8);
			while (true)
			{
				int alt8=2;
				try { DebugEnterDecision(8, false);
				int LA8_0 = input.LA(1);

				if ((LA8_0==ID||LA8_0==39||LA8_0==61||(LA8_0>=66 && LA8_0<=69)||LA8_0==71))
				{
					alt8 = 1;
				}


				} finally { DebugExitDecision(8); }
				switch ( alt8 )
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:109:38: s1+= statement
					{
					DebugLocation(109, 38);
					PushFollow(Follow._statement_in_if_stat450);
					s1=statement();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_statement.Add(s1.Tree);
					if (list_s1==null) list_s1=new List<object>();
					list_s1.Add(s1.Tree);


					}
					break;

				default:
					goto loop8;
				}
			}

			loop8:
				;

			} finally { DebugExitSubRule(8); }

			DebugLocation(110, 2);
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:110:2: (s2= senao_stat -> ^( SJMP ^( LEXP $p) ^( SLIST $s1 $s2) ) | 'fim' -> ^( JMP ^( LEXP $p) ^( SLIST ( $s1)* ) ) )
			int alt9=2;
			try { DebugEnterSubRule(9);
			try { DebugEnterDecision(9, false);
			int LA9_0 = input.LA(1);

			if ((LA9_0==70))
			{
				alt9 = 1;
			}
			else if ((LA9_0==63))
			{
				alt9 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 9, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(9); }
			switch (alt9)
			{
			case 1:
				DebugEnterAlt(1);
				// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:110:4: s2= senao_stat
				{
				DebugLocation(110, 6);
				PushFollow(Follow._senao_stat_in_if_stat458);
				s2=senao_stat();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_senao_stat.Add(s2.Tree);


				{
				// AST REWRITE
				// elements: s2, s1, p
				// token labels: 
				// rule labels: retval, s2, p
				// token list labels: 
				// rule list labels: s1
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
				RewriteRuleSubtreeStream stream_s2=new RewriteRuleSubtreeStream(adaptor,"rule s2",s2!=null?s2.Tree:null);
				RewriteRuleSubtreeStream stream_p=new RewriteRuleSubtreeStream(adaptor,"rule p",p!=null?p.Tree:null);
				RewriteRuleSubtreeStream stream_s1=new RewriteRuleSubtreeStream(adaptor,"token s1",list_s1);
				root_0 = (object)adaptor.Nil();
				// 110:18: -> ^( SJMP ^( LEXP $p) ^( SLIST $s1 $s2) )
				{
					DebugLocation(110, 21);
					// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:110:21: ^( SJMP ^( LEXP $p) ^( SLIST $s1 $s2) )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(110, 23);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(SJMP, "SJMP"), root_1);

					DebugLocation(110, 28);
					// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:110:28: ^( LEXP $p)
					{
					object root_2 = (object)adaptor.Nil();
					DebugLocation(110, 30);
					root_2 = (object)adaptor.BecomeRoot((object)adaptor.Create(LEXP, "LEXP"), root_2);

					DebugLocation(110, 36);
					adaptor.AddChild(root_2, stream_p.NextTree());

					adaptor.AddChild(root_1, root_2);
					}
					DebugLocation(110, 39);
					// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:110:39: ^( SLIST $s1 $s2)
					{
					object root_2 = (object)adaptor.Nil();
					DebugLocation(110, 41);
					root_2 = (object)adaptor.BecomeRoot((object)adaptor.Create(SLIST, "SLIST"), root_2);

					DebugLocation(110, 48);
					adaptor.AddChild(root_2, stream_s1.NextTree());
					DebugLocation(110, 52);
					adaptor.AddChild(root_2, stream_s2.NextTree());

					adaptor.AddChild(root_1, root_2);
					}

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:111:4: 'fim'
				{
				DebugLocation(111, 4);
				string_literal30=(IToken)Match(input,63,Follow._63_in_if_stat486); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_63.Add(string_literal30);



				{
				// AST REWRITE
				// elements: p, s1
				// token labels: 
				// rule labels: retval, p
				// token list labels: 
				// rule list labels: s1
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
				RewriteRuleSubtreeStream stream_p=new RewriteRuleSubtreeStream(adaptor,"rule p",p!=null?p.Tree:null);
				RewriteRuleSubtreeStream stream_s1=new RewriteRuleSubtreeStream(adaptor,"token s1",list_s1);
				root_0 = (object)adaptor.Nil();
				// 111:10: -> ^( JMP ^( LEXP $p) ^( SLIST ( $s1)* ) )
				{
					DebugLocation(111, 13);
					// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:111:13: ^( JMP ^( LEXP $p) ^( SLIST ( $s1)* ) )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(111, 15);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(JMP, "JMP"), root_1);

					DebugLocation(111, 19);
					// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:111:19: ^( LEXP $p)
					{
					object root_2 = (object)adaptor.Nil();
					DebugLocation(111, 21);
					root_2 = (object)adaptor.BecomeRoot((object)adaptor.Create(LEXP, "LEXP"), root_2);

					DebugLocation(111, 27);
					adaptor.AddChild(root_2, stream_p.NextTree());

					adaptor.AddChild(root_1, root_2);
					}
					DebugLocation(111, 30);
					// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:111:30: ^( SLIST ( $s1)* )
					{
					object root_2 = (object)adaptor.Nil();
					DebugLocation(111, 32);
					root_2 = (object)adaptor.BecomeRoot((object)adaptor.Create(SLIST, "SLIST"), root_2);

					DebugLocation(111, 39);
					// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:111:39: ( $s1)*
					while ( stream_s1.HasNext )
					{
						DebugLocation(111, 39);
						adaptor.AddChild(root_2, stream_s1.NextTree());

					}
					stream_s1.Reset();

					adaptor.AddChild(root_1, root_2);
					}

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			} finally { DebugExitSubRule(9); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
			if (state.backtracking == 0)
			{
				 paraphrases.Pop(); 
			}
		}

			catch (RecognitionException e) {
				throw e;
			}

		finally
		{
			TraceOut("if_stat", 8);
			LeaveRule("if_stat", 8);
			LeaveRule_if_stat();
		}
		DebugLocation(113, 1);
		} finally { DebugExitRule(GrammarFileName, "if_stat"); }
		return retval;

	}
	// $ANTLR end "if_stat"

	partial void EnterRule_senao_stat();
	partial void LeaveRule_senao_stat();

	// $ANTLR start "senao_stat"
	// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:115:1: senao_stat : 'senao' (s2+= statement )* 'fim' -> ^( SLIST ( statement )* ) ;
	[GrammarRule("senao_stat")]
	private AstParserRuleReturnScope<object, IToken> senao_stat()
	{
		EnterRule_senao_stat();
		EnterRule("senao_stat", 9);
		TraceIn("senao_stat", 9);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken string_literal31 = default(IToken);
		IToken string_literal32 = default(IToken);
		List<object> list_s2 = null;
		AstParserRuleReturnScope<object, IToken> s2 = default(AstParserRuleReturnScope<object, IToken>);
		object string_literal31_tree = default(object);
		object string_literal32_tree = default(object);
		RewriteRuleITokenStream stream_70=new RewriteRuleITokenStream(adaptor,"token 70");
		RewriteRuleITokenStream stream_63=new RewriteRuleITokenStream(adaptor,"token 63");
		RewriteRuleSubtreeStream stream_statement=new RewriteRuleSubtreeStream(adaptor,"rule statement");
		try { DebugEnterRule(GrammarFileName, "senao_stat");
		DebugLocation(115, 1);
		try
		{
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:116:2: ( 'senao' (s2+= statement )* 'fim' -> ^( SLIST ( statement )* ) )
			DebugEnterAlt(1);
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:116:4: 'senao' (s2+= statement )* 'fim'
			{
			DebugLocation(116, 4);
			string_literal31=(IToken)Match(input,70,Follow._70_in_senao_stat522); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_70.Add(string_literal31);

			DebugLocation(116, 14);
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:116:14: (s2+= statement )*
			try { DebugEnterSubRule(10);
			while (true)
			{
				int alt10=2;
				try { DebugEnterDecision(10, false);
				int LA10_0 = input.LA(1);

				if ((LA10_0==ID||LA10_0==39||LA10_0==61||(LA10_0>=66 && LA10_0<=69)||LA10_0==71))
				{
					alt10 = 1;
				}


				} finally { DebugExitDecision(10); }
				switch ( alt10 )
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:116:14: s2+= statement
					{
					DebugLocation(116, 14);
					PushFollow(Follow._statement_in_senao_stat526);
					s2=statement();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_statement.Add(s2.Tree);
					if (list_s2==null) list_s2=new List<object>();
					list_s2.Add(s2.Tree);


					}
					break;

				default:
					goto loop10;
				}
			}

			loop10:
				;

			} finally { DebugExitSubRule(10); }

			DebugLocation(116, 27);
			string_literal32=(IToken)Match(input,63,Follow._63_in_senao_stat529); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_63.Add(string_literal32);



			{
			// AST REWRITE
			// elements: statement
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 116:33: -> ^( SLIST ( statement )* )
			{
				DebugLocation(116, 36);
				// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:116:36: ^( SLIST ( statement )* )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(116, 38);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(SLIST, "SLIST"), root_1);

				DebugLocation(116, 44);
				// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:116:44: ( statement )*
				while ( stream_statement.HasNext )
				{
					DebugLocation(116, 44);
					adaptor.AddChild(root_1, stream_statement.NextTree());

				}
				stream_statement.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

			catch (RecognitionException e) {
				throw e;
			}

		finally
		{
			TraceOut("senao_stat", 9);
			LeaveRule("senao_stat", 9);
			LeaveRule_senao_stat();
		}
		DebugLocation(117, 1);
		} finally { DebugExitRule(GrammarFileName, "senao_stat"); }
		return retval;

	}
	// $ANTLR end "senao_stat"

	partial void EnterRule_for_stat();
	partial void LeaveRule_for_stat();

	// $ANTLR start "for_stat"
	// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:119:1: for_stat : 'para' assign_var 'ate' index ( 'dec' ( statement )* 'fim' -> ^( LOOP DEC assign_var index ^( SLIST ( statement )* ) ) | ( statement )* 'fim' -> ^( LOOP assign_var index ^( SLIST ( statement )* ) ) ) ;
	[GrammarRule("for_stat")]
	private AstParserRuleReturnScope<object, IToken> for_stat()
	{
		EnterRule_for_stat();
		EnterRule("for_stat", 10);
		TraceIn("for_stat", 10);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken string_literal33 = default(IToken);
		IToken string_literal35 = default(IToken);
		IToken string_literal37 = default(IToken);
		IToken string_literal39 = default(IToken);
		IToken string_literal41 = default(IToken);
		AstParserRuleReturnScope<object, IToken> assign_var34 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> index36 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> statement38 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> statement40 = default(AstParserRuleReturnScope<object, IToken>);

		object string_literal33_tree = default(object);
		object string_literal35_tree = default(object);
		object string_literal37_tree = default(object);
		object string_literal39_tree = default(object);
		object string_literal41_tree = default(object);
		RewriteRuleITokenStream stream_66=new RewriteRuleITokenStream(adaptor,"token 66");
		RewriteRuleITokenStream stream_59=new RewriteRuleITokenStream(adaptor,"token 59");
		RewriteRuleITokenStream stream_58=new RewriteRuleITokenStream(adaptor,"token 58");
		RewriteRuleITokenStream stream_63=new RewriteRuleITokenStream(adaptor,"token 63");
		RewriteRuleSubtreeStream stream_statement=new RewriteRuleSubtreeStream(adaptor,"rule statement");
		RewriteRuleSubtreeStream stream_index=new RewriteRuleSubtreeStream(adaptor,"rule index");
		RewriteRuleSubtreeStream stream_assign_var=new RewriteRuleSubtreeStream(adaptor,"rule assign_var");
		try { DebugEnterRule(GrammarFileName, "for_stat");
		DebugLocation(119, 1);
		try
		{
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:119:9: ( 'para' assign_var 'ate' index ( 'dec' ( statement )* 'fim' -> ^( LOOP DEC assign_var index ^( SLIST ( statement )* ) ) | ( statement )* 'fim' -> ^( LOOP assign_var index ^( SLIST ( statement )* ) ) ) )
			DebugEnterAlt(1);
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:119:11: 'para' assign_var 'ate' index ( 'dec' ( statement )* 'fim' -> ^( LOOP DEC assign_var index ^( SLIST ( statement )* ) ) | ( statement )* 'fim' -> ^( LOOP assign_var index ^( SLIST ( statement )* ) ) )
			{
			DebugLocation(119, 11);
			string_literal33=(IToken)Match(input,66,Follow._66_in_for_stat549); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_66.Add(string_literal33);

			DebugLocation(119, 18);
			PushFollow(Follow._assign_var_in_for_stat551);
			assign_var34=assign_var();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_assign_var.Add(assign_var34.Tree);
			DebugLocation(119, 29);
			string_literal35=(IToken)Match(input,58,Follow._58_in_for_stat553); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_58.Add(string_literal35);

			DebugLocation(119, 35);
			PushFollow(Follow._index_in_for_stat555);
			index36=index();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_index.Add(index36.Tree);
			DebugLocation(121, 3);
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:121:3: ( 'dec' ( statement )* 'fim' -> ^( LOOP DEC assign_var index ^( SLIST ( statement )* ) ) | ( statement )* 'fim' -> ^( LOOP assign_var index ^( SLIST ( statement )* ) ) )
			int alt13=2;
			try { DebugEnterSubRule(13);
			try { DebugEnterDecision(13, false);
			int LA13_0 = input.LA(1);

			if ((LA13_0==59))
			{
				alt13 = 1;
			}
			else if ((LA13_0==ID||LA13_0==39||LA13_0==61||LA13_0==63||(LA13_0>=66 && LA13_0<=69)||LA13_0==71))
			{
				alt13 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 13, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(13); }
			switch (alt13)
			{
			case 1:
				DebugEnterAlt(1);
				// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:121:5: 'dec' ( statement )* 'fim'
				{
				DebugLocation(121, 5);
				string_literal37=(IToken)Match(input,59,Follow._59_in_for_stat563); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_59.Add(string_literal37);

				DebugLocation(121, 11);
				// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:121:11: ( statement )*
				try { DebugEnterSubRule(11);
				while (true)
				{
					int alt11=2;
					try { DebugEnterDecision(11, false);
					int LA11_0 = input.LA(1);

					if ((LA11_0==ID||LA11_0==39||LA11_0==61||(LA11_0>=66 && LA11_0<=69)||LA11_0==71))
					{
						alt11 = 1;
					}


					} finally { DebugExitDecision(11); }
					switch ( alt11 )
					{
					case 1:
						DebugEnterAlt(1);
						// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:121:11: statement
						{
						DebugLocation(121, 11);
						PushFollow(Follow._statement_in_for_stat565);
						statement38=statement();
						PopFollow();
						if (state.failed) return retval;
						if (state.backtracking == 0) stream_statement.Add(statement38.Tree);

						}
						break;

					default:
						goto loop11;
					}
				}

				loop11:
					;

				} finally { DebugExitSubRule(11); }

				DebugLocation(121, 22);
				string_literal39=(IToken)Match(input,63,Follow._63_in_for_stat568); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_63.Add(string_literal39);



				{
				// AST REWRITE
				// elements: statement, assign_var, index
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 121:28: -> ^( LOOP DEC assign_var index ^( SLIST ( statement )* ) )
				{
					DebugLocation(121, 31);
					// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:121:31: ^( LOOP DEC assign_var index ^( SLIST ( statement )* ) )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(121, 33);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(LOOP, "LOOP"), root_1);

					DebugLocation(121, 38);
					adaptor.AddChild(root_1, (object)adaptor.Create(DEC, "DEC"));
					DebugLocation(121, 42);
					adaptor.AddChild(root_1, stream_assign_var.NextTree());
					DebugLocation(121, 53);
					adaptor.AddChild(root_1, stream_index.NextTree());
					DebugLocation(121, 59);
					// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:121:59: ^( SLIST ( statement )* )
					{
					object root_2 = (object)adaptor.Nil();
					DebugLocation(121, 61);
					root_2 = (object)adaptor.BecomeRoot((object)adaptor.Create(SLIST, "SLIST"), root_2);

					DebugLocation(121, 67);
					// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:121:67: ( statement )*
					while ( stream_statement.HasNext )
					{
						DebugLocation(121, 67);
						adaptor.AddChild(root_2, stream_statement.NextTree());

					}
					stream_statement.Reset();

					adaptor.AddChild(root_1, root_2);
					}

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:122:5: ( statement )* 'fim'
				{
				DebugLocation(122, 5);
				// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:122:5: ( statement )*
				try { DebugEnterSubRule(12);
				while (true)
				{
					int alt12=2;
					try { DebugEnterDecision(12, false);
					int LA12_0 = input.LA(1);

					if ((LA12_0==ID||LA12_0==39||LA12_0==61||(LA12_0>=66 && LA12_0<=69)||LA12_0==71))
					{
						alt12 = 1;
					}


					} finally { DebugExitDecision(12); }
					switch ( alt12 )
					{
					case 1:
						DebugEnterAlt(1);
						// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:122:5: statement
						{
						DebugLocation(122, 5);
						PushFollow(Follow._statement_in_for_stat593);
						statement40=statement();
						PopFollow();
						if (state.failed) return retval;
						if (state.backtracking == 0) stream_statement.Add(statement40.Tree);

						}
						break;

					default:
						goto loop12;
					}
				}

				loop12:
					;

				} finally { DebugExitSubRule(12); }

				DebugLocation(122, 16);
				string_literal41=(IToken)Match(input,63,Follow._63_in_for_stat596); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_63.Add(string_literal41);



				{
				// AST REWRITE
				// elements: statement, assign_var, index
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 122:22: -> ^( LOOP assign_var index ^( SLIST ( statement )* ) )
				{
					DebugLocation(122, 25);
					// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:122:25: ^( LOOP assign_var index ^( SLIST ( statement )* ) )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(122, 27);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(LOOP, "LOOP"), root_1);

					DebugLocation(122, 32);
					adaptor.AddChild(root_1, stream_assign_var.NextTree());
					DebugLocation(122, 43);
					adaptor.AddChild(root_1, stream_index.NextTree());
					DebugLocation(122, 49);
					// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:122:49: ^( SLIST ( statement )* )
					{
					object root_2 = (object)adaptor.Nil();
					DebugLocation(122, 51);
					root_2 = (object)adaptor.BecomeRoot((object)adaptor.Create(SLIST, "SLIST"), root_2);

					DebugLocation(122, 57);
					// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:122:57: ( statement )*
					while ( stream_statement.HasNext )
					{
						DebugLocation(122, 57);
						adaptor.AddChild(root_2, stream_statement.NextTree());

					}
					stream_statement.Reset();

					adaptor.AddChild(root_1, root_2);
					}

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			} finally { DebugExitSubRule(13); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

			catch (RecognitionException e) {
				throw e;
			}

		finally
		{
			TraceOut("for_stat", 10);
			LeaveRule("for_stat", 10);
			LeaveRule_for_stat();
		}
		DebugLocation(124, 1);
		} finally { DebugExitRule(GrammarFileName, "for_stat"); }
		return retval;

	}
	// $ANTLR end "for_stat"

	partial void EnterRule_while_stat();
	partial void LeaveRule_while_stat();

	// $ANTLR start "while_stat"
	// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:126:1: while_stat : 'enquanto' logic_expression ( statement )* 'fim' -> ^( LOOP ^( LEXP logic_expression ) ^( SLIST ( statement )* ) ) ;
	[GrammarRule("while_stat")]
	private AstParserRuleReturnScope<object, IToken> while_stat()
	{
		EnterRule_while_stat();
		EnterRule("while_stat", 11);
		TraceIn("while_stat", 11);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken string_literal42 = default(IToken);
		IToken string_literal45 = default(IToken);
		AstParserRuleReturnScope<object, IToken> logic_expression43 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> statement44 = default(AstParserRuleReturnScope<object, IToken>);

		object string_literal42_tree = default(object);
		object string_literal45_tree = default(object);
		RewriteRuleITokenStream stream_63=new RewriteRuleITokenStream(adaptor,"token 63");
		RewriteRuleITokenStream stream_61=new RewriteRuleITokenStream(adaptor,"token 61");
		RewriteRuleSubtreeStream stream_statement=new RewriteRuleSubtreeStream(adaptor,"rule statement");
		RewriteRuleSubtreeStream stream_logic_expression=new RewriteRuleSubtreeStream(adaptor,"rule logic_expression");
		try { DebugEnterRule(GrammarFileName, "while_stat");
		DebugLocation(126, 1);
		try
		{
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:127:2: ( 'enquanto' logic_expression ( statement )* 'fim' -> ^( LOOP ^( LEXP logic_expression ) ^( SLIST ( statement )* ) ) )
			DebugEnterAlt(1);
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:127:4: 'enquanto' logic_expression ( statement )* 'fim'
			{
			DebugLocation(127, 4);
			string_literal42=(IToken)Match(input,61,Follow._61_in_while_stat629); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_61.Add(string_literal42);

			DebugLocation(127, 15);
			PushFollow(Follow._logic_expression_in_while_stat631);
			logic_expression43=logic_expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_logic_expression.Add(logic_expression43.Tree);
			DebugLocation(127, 32);
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:127:32: ( statement )*
			try { DebugEnterSubRule(14);
			while (true)
			{
				int alt14=2;
				try { DebugEnterDecision(14, false);
				int LA14_0 = input.LA(1);

				if ((LA14_0==ID||LA14_0==39||LA14_0==61||(LA14_0>=66 && LA14_0<=69)||LA14_0==71))
				{
					alt14 = 1;
				}


				} finally { DebugExitDecision(14); }
				switch ( alt14 )
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:127:32: statement
					{
					DebugLocation(127, 32);
					PushFollow(Follow._statement_in_while_stat633);
					statement44=statement();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_statement.Add(statement44.Tree);

					}
					break;

				default:
					goto loop14;
				}
			}

			loop14:
				;

			} finally { DebugExitSubRule(14); }

			DebugLocation(127, 43);
			string_literal45=(IToken)Match(input,63,Follow._63_in_while_stat636); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_63.Add(string_literal45);



			{
			// AST REWRITE
			// elements: logic_expression, statement
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 128:3: -> ^( LOOP ^( LEXP logic_expression ) ^( SLIST ( statement )* ) )
			{
				DebugLocation(128, 6);
				// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:128:6: ^( LOOP ^( LEXP logic_expression ) ^( SLIST ( statement )* ) )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(128, 8);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(LOOP, "LOOP"), root_1);

				DebugLocation(128, 13);
				// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:128:13: ^( LEXP logic_expression )
				{
				object root_2 = (object)adaptor.Nil();
				DebugLocation(128, 15);
				root_2 = (object)adaptor.BecomeRoot((object)adaptor.Create(LEXP, "LEXP"), root_2);

				DebugLocation(128, 20);
				adaptor.AddChild(root_2, stream_logic_expression.NextTree());

				adaptor.AddChild(root_1, root_2);
				}
				DebugLocation(128, 38);
				// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:128:38: ^( SLIST ( statement )* )
				{
				object root_2 = (object)adaptor.Nil();
				DebugLocation(128, 40);
				root_2 = (object)adaptor.BecomeRoot((object)adaptor.Create(SLIST, "SLIST"), root_2);

				DebugLocation(128, 46);
				// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:128:46: ( statement )*
				while ( stream_statement.HasNext )
				{
					DebugLocation(128, 46);
					adaptor.AddChild(root_2, stream_statement.NextTree());

				}
				stream_statement.Reset();

				adaptor.AddChild(root_1, root_2);
				}

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

			catch (RecognitionException e) {
				throw e;
			}

		finally
		{
			TraceOut("while_stat", 11);
			LeaveRule("while_stat", 11);
			LeaveRule_while_stat();
		}
		DebugLocation(129, 1);
		} finally { DebugExitRule(GrammarFileName, "while_stat"); }
		return retval;

	}
	// $ANTLR end "while_stat"

	partial void EnterRule_repeat_stat();
	partial void LeaveRule_repeat_stat();

	// $ANTLR start "repeat_stat"
	// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:131:1: repeat_stat : 'repita' ( statement )* 'ate' logic_expression -> ^( LOOP ^( SLIST ( statement )* ) ^( LEXP logic_expression ) ) ;
	[GrammarRule("repeat_stat")]
	private AstParserRuleReturnScope<object, IToken> repeat_stat()
	{
		EnterRule_repeat_stat();
		EnterRule("repeat_stat", 12);
		TraceIn("repeat_stat", 12);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken string_literal46 = default(IToken);
		IToken string_literal48 = default(IToken);
		AstParserRuleReturnScope<object, IToken> statement47 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> logic_expression49 = default(AstParserRuleReturnScope<object, IToken>);

		object string_literal46_tree = default(object);
		object string_literal48_tree = default(object);
		RewriteRuleITokenStream stream_67=new RewriteRuleITokenStream(adaptor,"token 67");
		RewriteRuleITokenStream stream_58=new RewriteRuleITokenStream(adaptor,"token 58");
		RewriteRuleSubtreeStream stream_statement=new RewriteRuleSubtreeStream(adaptor,"rule statement");
		RewriteRuleSubtreeStream stream_logic_expression=new RewriteRuleSubtreeStream(adaptor,"rule logic_expression");
		try { DebugEnterRule(GrammarFileName, "repeat_stat");
		DebugLocation(131, 1);
		try
		{
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:131:13: ( 'repita' ( statement )* 'ate' logic_expression -> ^( LOOP ^( SLIST ( statement )* ) ^( LEXP logic_expression ) ) )
			DebugEnterAlt(1);
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:131:15: 'repita' ( statement )* 'ate' logic_expression
			{
			DebugLocation(131, 15);
			string_literal46=(IToken)Match(input,67,Follow._67_in_repeat_stat668); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_67.Add(string_literal46);

			DebugLocation(131, 24);
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:131:24: ( statement )*
			try { DebugEnterSubRule(15);
			while (true)
			{
				int alt15=2;
				try { DebugEnterDecision(15, false);
				int LA15_0 = input.LA(1);

				if ((LA15_0==ID||LA15_0==39||LA15_0==61||(LA15_0>=66 && LA15_0<=69)||LA15_0==71))
				{
					alt15 = 1;
				}


				} finally { DebugExitDecision(15); }
				switch ( alt15 )
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:131:24: statement
					{
					DebugLocation(131, 24);
					PushFollow(Follow._statement_in_repeat_stat670);
					statement47=statement();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_statement.Add(statement47.Tree);

					}
					break;

				default:
					goto loop15;
				}
			}

			loop15:
				;

			} finally { DebugExitSubRule(15); }

			DebugLocation(131, 35);
			string_literal48=(IToken)Match(input,58,Follow._58_in_repeat_stat673); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_58.Add(string_literal48);

			DebugLocation(131, 41);
			PushFollow(Follow._logic_expression_in_repeat_stat675);
			logic_expression49=logic_expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_logic_expression.Add(logic_expression49.Tree);


			{
			// AST REWRITE
			// elements: statement, logic_expression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 132:3: -> ^( LOOP ^( SLIST ( statement )* ) ^( LEXP logic_expression ) )
			{
				DebugLocation(132, 6);
				// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:132:6: ^( LOOP ^( SLIST ( statement )* ) ^( LEXP logic_expression ) )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(132, 8);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(LOOP, "LOOP"), root_1);

				DebugLocation(132, 13);
				// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:132:13: ^( SLIST ( statement )* )
				{
				object root_2 = (object)adaptor.Nil();
				DebugLocation(132, 15);
				root_2 = (object)adaptor.BecomeRoot((object)adaptor.Create(SLIST, "SLIST"), root_2);

				DebugLocation(132, 21);
				// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:132:21: ( statement )*
				while ( stream_statement.HasNext )
				{
					DebugLocation(132, 21);
					adaptor.AddChild(root_2, stream_statement.NextTree());

				}
				stream_statement.Reset();

				adaptor.AddChild(root_1, root_2);
				}
				DebugLocation(132, 33);
				// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:132:33: ^( LEXP logic_expression )
				{
				object root_2 = (object)adaptor.Nil();
				DebugLocation(132, 35);
				root_2 = (object)adaptor.BecomeRoot((object)adaptor.Create(LEXP, "LEXP"), root_2);

				DebugLocation(132, 40);
				adaptor.AddChild(root_2, stream_logic_expression.NextTree());

				adaptor.AddChild(root_1, root_2);
				}

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

			catch (RecognitionException e) {
				throw e;
			}

		finally
		{
			TraceOut("repeat_stat", 12);
			LeaveRule("repeat_stat", 12);
			LeaveRule_repeat_stat();
		}
		DebugLocation(133, 1);
		} finally { DebugExitRule(GrammarFileName, "repeat_stat"); }
		return retval;

	}
	// $ANTLR end "repeat_stat"

	partial void EnterRule_function_call();
	partial void LeaveRule_function_call();

	// $ANTLR start "function_call"
	// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:135:1: function_call : ID '(' ( function_arg_list )* ')' -> ^( CALL ID ( function_arg_list )* ) ;
	[GrammarRule("function_call")]
	private AstParserRuleReturnScope<object, IToken> function_call()
	{
		EnterRule_function_call();
		EnterRule("function_call", 13);
		TraceIn("function_call", 13);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken ID50 = default(IToken);
		IToken char_literal51 = default(IToken);
		IToken char_literal53 = default(IToken);
		AstParserRuleReturnScope<object, IToken> function_arg_list52 = default(AstParserRuleReturnScope<object, IToken>);

		object ID50_tree = default(object);
		object char_literal51_tree = default(object);
		object char_literal53_tree = default(object);
		RewriteRuleITokenStream stream_42=new RewriteRuleITokenStream(adaptor,"token 42");
		RewriteRuleITokenStream stream_41=new RewriteRuleITokenStream(adaptor,"token 41");
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleSubtreeStream stream_function_arg_list=new RewriteRuleSubtreeStream(adaptor,"rule function_arg_list");
		 paraphrases.Push("na chamada de função"); 
		try { DebugEnterRule(GrammarFileName, "function_call");
		DebugLocation(135, 1);
		try
		{
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:136:2: ( ID '(' ( function_arg_list )* ')' -> ^( CALL ID ( function_arg_list )* ) )
			DebugEnterAlt(1);
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:136:4: ID '(' ( function_arg_list )* ')'
			{
			DebugLocation(136, 4);
			ID50=(IToken)Match(input,ID,Follow._ID_in_function_call723); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ID.Add(ID50);

			DebugLocation(136, 7);
			char_literal51=(IToken)Match(input,41,Follow._41_in_function_call725); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_41.Add(char_literal51);

			DebugLocation(136, 11);
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:136:11: ( function_arg_list )*
			try { DebugEnterSubRule(16);
			while (true)
			{
				int alt16=2;
				try { DebugEnterDecision(16, false);
				int LA16_0 = input.LA(1);

				if ((LA16_0==FLOAT||LA16_0==ID||LA16_0==INT||LA16_0==STRING||LA16_0==41))
				{
					alt16 = 1;
				}


				} finally { DebugExitDecision(16); }
				switch ( alt16 )
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:136:11: function_arg_list
					{
					DebugLocation(136, 11);
					PushFollow(Follow._function_arg_list_in_function_call727);
					function_arg_list52=function_arg_list();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_function_arg_list.Add(function_arg_list52.Tree);

					}
					break;

				default:
					goto loop16;
				}
			}

			loop16:
				;

			} finally { DebugExitSubRule(16); }

			DebugLocation(136, 30);
			char_literal53=(IToken)Match(input,42,Follow._42_in_function_call730); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_42.Add(char_literal53);



			{
			// AST REWRITE
			// elements: function_arg_list, ID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 136:34: -> ^( CALL ID ( function_arg_list )* )
			{
				DebugLocation(136, 37);
				// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:136:37: ^( CALL ID ( function_arg_list )* )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(136, 39);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(CALL, "CALL"), root_1);

				DebugLocation(136, 44);
				adaptor.AddChild(root_1, stream_ID.NextNode());
				DebugLocation(136, 47);
				// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:136:47: ( function_arg_list )*
				while ( stream_function_arg_list.HasNext )
				{
					DebugLocation(136, 47);
					adaptor.AddChild(root_1, stream_function_arg_list.NextTree());

				}
				stream_function_arg_list.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
			if (state.backtracking == 0)
			{
				 paraphrases.Pop(); 
			}
		}

			catch (RecognitionException e) {
				throw e;
			}

		finally
		{
			TraceOut("function_call", 13);
			LeaveRule("function_call", 13);
			LeaveRule_function_call();
		}
		DebugLocation(137, 1);
		} finally { DebugExitRule(GrammarFileName, "function_call"); }
		return retval;

	}
	// $ANTLR end "function_call"

	partial void EnterRule_property_call();
	partial void LeaveRule_property_call();

	// $ANTLR start "property_call"
	// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:139:1: property_call : o= ID '.' p= ID -> ^( PCALL $o $p) ;
	[GrammarRule("property_call")]
	private AstParserRuleReturnScope<object, IToken> property_call()
	{
		EnterRule_property_call();
		EnterRule("property_call", 14);
		TraceIn("property_call", 14);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken o = default(IToken);
		IToken p = default(IToken);
		IToken char_literal54 = default(IToken);

		object o_tree = default(object);
		object p_tree = default(object);
		object char_literal54_tree = default(object);
		RewriteRuleITokenStream stream_47=new RewriteRuleITokenStream(adaptor,"token 47");
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		 paraphrases.Push("na chamada de propriedade"); 
		try { DebugEnterRule(GrammarFileName, "property_call");
		DebugLocation(139, 1);
		try
		{
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:140:2: (o= ID '.' p= ID -> ^( PCALL $o $p) )
			DebugEnterAlt(1);
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:140:4: o= ID '.' p= ID
			{
			DebugLocation(140, 5);
			o=(IToken)Match(input,ID,Follow._ID_in_property_call771); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ID.Add(o);

			DebugLocation(140, 8);
			char_literal54=(IToken)Match(input,47,Follow._47_in_property_call772); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_47.Add(char_literal54);

			DebugLocation(140, 12);
			p=(IToken)Match(input,ID,Follow._ID_in_property_call775); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ID.Add(p);



			{
			// AST REWRITE
			// elements: o, p
			// token labels: p, o
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleITokenStream stream_p=new RewriteRuleITokenStream(adaptor,"token p",p);
			RewriteRuleITokenStream stream_o=new RewriteRuleITokenStream(adaptor,"token o",o);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 140:17: -> ^( PCALL $o $p)
			{
				DebugLocation(140, 20);
				// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:140:20: ^( PCALL $o $p)
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(140, 22);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(PCALL, "PCALL"), root_1);

				DebugLocation(140, 29);
				adaptor.AddChild(root_1, stream_o.NextNode());
				DebugLocation(140, 32);
				adaptor.AddChild(root_1, stream_p.NextNode());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
			if (state.backtracking == 0)
			{
				 paraphrases.Pop(); 
			}
		}

			catch (RecognitionException e) {
				throw e;
			}

		finally
		{
			TraceOut("property_call", 14);
			LeaveRule("property_call", 14);
			LeaveRule_property_call();
		}
		DebugLocation(141, 1);
		} finally { DebugExitRule(GrammarFileName, "property_call"); }
		return retval;

	}
	// $ANTLR end "property_call"

	partial void EnterRule_method_call();
	partial void LeaveRule_method_call();

	// $ANTLR start "method_call"
	// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:143:1: method_call : o= ID '.' p= ID '(' ( function_arg_list )* ')' -> ^( MCALL $o $p ( function_arg_list )* ) ;
	[GrammarRule("method_call")]
	private AstParserRuleReturnScope<object, IToken> method_call()
	{
		EnterRule_method_call();
		EnterRule("method_call", 15);
		TraceIn("method_call", 15);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken o = default(IToken);
		IToken p = default(IToken);
		IToken char_literal55 = default(IToken);
		IToken char_literal56 = default(IToken);
		IToken char_literal58 = default(IToken);
		AstParserRuleReturnScope<object, IToken> function_arg_list57 = default(AstParserRuleReturnScope<object, IToken>);

		object o_tree = default(object);
		object p_tree = default(object);
		object char_literal55_tree = default(object);
		object char_literal56_tree = default(object);
		object char_literal58_tree = default(object);
		RewriteRuleITokenStream stream_42=new RewriteRuleITokenStream(adaptor,"token 42");
		RewriteRuleITokenStream stream_47=new RewriteRuleITokenStream(adaptor,"token 47");
		RewriteRuleITokenStream stream_41=new RewriteRuleITokenStream(adaptor,"token 41");
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleSubtreeStream stream_function_arg_list=new RewriteRuleSubtreeStream(adaptor,"rule function_arg_list");
		 paraphrases.Push("na chamada de propriedade"); 
		try { DebugEnterRule(GrammarFileName, "method_call");
		DebugLocation(143, 1);
		try
		{
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:144:2: (o= ID '.' p= ID '(' ( function_arg_list )* ')' -> ^( MCALL $o $p ( function_arg_list )* ) )
			DebugEnterAlt(1);
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:144:4: o= ID '.' p= ID '(' ( function_arg_list )* ')'
			{
			DebugLocation(144, 5);
			o=(IToken)Match(input,ID,Follow._ID_in_method_call819); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ID.Add(o);

			DebugLocation(144, 8);
			char_literal55=(IToken)Match(input,47,Follow._47_in_method_call820); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_47.Add(char_literal55);

			DebugLocation(144, 12);
			p=(IToken)Match(input,ID,Follow._ID_in_method_call823); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ID.Add(p);

			DebugLocation(144, 16);
			char_literal56=(IToken)Match(input,41,Follow._41_in_method_call825); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_41.Add(char_literal56);

			DebugLocation(144, 20);
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:144:20: ( function_arg_list )*
			try { DebugEnterSubRule(17);
			while (true)
			{
				int alt17=2;
				try { DebugEnterDecision(17, false);
				int LA17_0 = input.LA(1);

				if ((LA17_0==FLOAT||LA17_0==ID||LA17_0==INT||LA17_0==STRING||LA17_0==41))
				{
					alt17 = 1;
				}


				} finally { DebugExitDecision(17); }
				switch ( alt17 )
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:144:20: function_arg_list
					{
					DebugLocation(144, 20);
					PushFollow(Follow._function_arg_list_in_method_call827);
					function_arg_list57=function_arg_list();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_function_arg_list.Add(function_arg_list57.Tree);

					}
					break;

				default:
					goto loop17;
				}
			}

			loop17:
				;

			} finally { DebugExitSubRule(17); }

			DebugLocation(144, 39);
			char_literal58=(IToken)Match(input,42,Follow._42_in_method_call830); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_42.Add(char_literal58);



			{
			// AST REWRITE
			// elements: o, p, function_arg_list
			// token labels: p, o
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleITokenStream stream_p=new RewriteRuleITokenStream(adaptor,"token p",p);
			RewriteRuleITokenStream stream_o=new RewriteRuleITokenStream(adaptor,"token o",o);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 144:43: -> ^( MCALL $o $p ( function_arg_list )* )
			{
				DebugLocation(144, 46);
				// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:144:46: ^( MCALL $o $p ( function_arg_list )* )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(144, 48);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(MCALL, "MCALL"), root_1);

				DebugLocation(144, 55);
				adaptor.AddChild(root_1, stream_o.NextNode());
				DebugLocation(144, 58);
				adaptor.AddChild(root_1, stream_p.NextNode());
				DebugLocation(144, 60);
				// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:144:60: ( function_arg_list )*
				while ( stream_function_arg_list.HasNext )
				{
					DebugLocation(144, 60);
					adaptor.AddChild(root_1, stream_function_arg_list.NextTree());

				}
				stream_function_arg_list.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
			if (state.backtracking == 0)
			{
				 paraphrases.Pop(); 
			}
		}

			catch (RecognitionException e) {
				throw e;
			}

		finally
		{
			TraceOut("method_call", 15);
			LeaveRule("method_call", 15);
			LeaveRule_method_call();
		}
		DebugLocation(145, 1);
		} finally { DebugExitRule(GrammarFileName, "method_call"); }
		return retval;

	}
	// $ANTLR end "method_call"

	partial void EnterRule_function_arg_list();
	partial void LeaveRule_function_arg_list();

	// $ANTLR start "function_arg_list"
	// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:147:1: function_arg_list : plus_expression ( ',' plus_expression )* -> ^( ARG ( plus_expression )* ) ;
	[GrammarRule("function_arg_list")]
	private AstParserRuleReturnScope<object, IToken> function_arg_list()
	{
		EnterRule_function_arg_list();
		EnterRule("function_arg_list", 16);
		TraceIn("function_arg_list", 16);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken char_literal60 = default(IToken);
		AstParserRuleReturnScope<object, IToken> plus_expression59 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> plus_expression61 = default(AstParserRuleReturnScope<object, IToken>);

		object char_literal60_tree = default(object);
		RewriteRuleITokenStream stream_45=new RewriteRuleITokenStream(adaptor,"token 45");
		RewriteRuleSubtreeStream stream_plus_expression=new RewriteRuleSubtreeStream(adaptor,"rule plus_expression");
		 paraphrases.Push("nos argumentos da função"); 
		try { DebugEnterRule(GrammarFileName, "function_arg_list");
		DebugLocation(147, 1);
		try
		{
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:149:2: ( plus_expression ( ',' plus_expression )* -> ^( ARG ( plus_expression )* ) )
			DebugEnterAlt(1);
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:149:4: plus_expression ( ',' plus_expression )*
			{
			DebugLocation(149, 4);
			PushFollow(Follow._plus_expression_in_function_arg_list875);
			plus_expression59=plus_expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_plus_expression.Add(plus_expression59.Tree);
			DebugLocation(149, 20);
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:149:20: ( ',' plus_expression )*
			try { DebugEnterSubRule(18);
			while (true)
			{
				int alt18=2;
				try { DebugEnterDecision(18, false);
				int LA18_0 = input.LA(1);

				if ((LA18_0==45))
				{
					alt18 = 1;
				}


				} finally { DebugExitDecision(18); }
				switch ( alt18 )
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:149:21: ',' plus_expression
					{
					DebugLocation(149, 21);
					char_literal60=(IToken)Match(input,45,Follow._45_in_function_arg_list878); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_45.Add(char_literal60);

					DebugLocation(149, 25);
					PushFollow(Follow._plus_expression_in_function_arg_list880);
					plus_expression61=plus_expression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_plus_expression.Add(plus_expression61.Tree);

					}
					break;

				default:
					goto loop18;
				}
			}

			loop18:
				;

			} finally { DebugExitSubRule(18); }



			{
			// AST REWRITE
			// elements: plus_expression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 149:43: -> ^( ARG ( plus_expression )* )
			{
				DebugLocation(149, 46);
				// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:149:46: ^( ARG ( plus_expression )* )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(149, 48);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(ARG, "ARG"), root_1);

				DebugLocation(149, 52);
				// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:149:52: ( plus_expression )*
				while ( stream_plus_expression.HasNext )
				{
					DebugLocation(149, 52);
					adaptor.AddChild(root_1, stream_plus_expression.NextTree());

				}
				stream_plus_expression.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
			if (state.backtracking == 0)
			{
				 paraphrases.Pop(); 
			}
		}

			catch (RecognitionException e) {
				throw e;
			}

		finally
		{
			TraceOut("function_arg_list", 16);
			LeaveRule("function_arg_list", 16);
			LeaveRule_function_arg_list();
		}
		DebugLocation(150, 1);
		} finally { DebugExitRule(GrammarFileName, "function_arg_list"); }
		return retval;

	}
	// $ANTLR end "function_arg_list"

	partial void EnterRule_assign_var();
	partial void LeaveRule_assign_var();

	// $ANTLR start "assign_var"
	// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:152:1: assign_var : ( ID '=' '[' INT '..' INT ']' -> ^( ASGN ID INT INT ) | ID '=' '{' INT ( ',' INT )* '}' -> ^( ASGN ID ^( ILIST ( INT )* ) ) | ID '[' index ']' '=' assign_expression -> ^( ASGN ^( AR index ) ID assign_expression ) | ID '=' assign_expression -> ^( ASGN ID assign_expression ) );
	[GrammarRule("assign_var")]
	private AstParserRuleReturnScope<object, IToken> assign_var()
	{
		EnterRule_assign_var();
		EnterRule("assign_var", 17);
		TraceIn("assign_var", 17);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken ID62 = default(IToken);
		IToken char_literal63 = default(IToken);
		IToken char_literal64 = default(IToken);
		IToken INT65 = default(IToken);
		IToken string_literal66 = default(IToken);
		IToken INT67 = default(IToken);
		IToken char_literal68 = default(IToken);
		IToken ID69 = default(IToken);
		IToken char_literal70 = default(IToken);
		IToken char_literal71 = default(IToken);
		IToken INT72 = default(IToken);
		IToken char_literal73 = default(IToken);
		IToken INT74 = default(IToken);
		IToken char_literal75 = default(IToken);
		IToken ID76 = default(IToken);
		IToken char_literal77 = default(IToken);
		IToken char_literal79 = default(IToken);
		IToken char_literal80 = default(IToken);
		IToken ID82 = default(IToken);
		IToken char_literal83 = default(IToken);
		AstParserRuleReturnScope<object, IToken> index78 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> assign_expression81 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> assign_expression84 = default(AstParserRuleReturnScope<object, IToken>);

		object ID62_tree = default(object);
		object char_literal63_tree = default(object);
		object char_literal64_tree = default(object);
		object INT65_tree = default(object);
		object string_literal66_tree = default(object);
		object INT67_tree = default(object);
		object char_literal68_tree = default(object);
		object ID69_tree = default(object);
		object char_literal70_tree = default(object);
		object char_literal71_tree = default(object);
		object INT72_tree = default(object);
		object char_literal73_tree = default(object);
		object INT74_tree = default(object);
		object char_literal75_tree = default(object);
		object ID76_tree = default(object);
		object char_literal77_tree = default(object);
		object char_literal79_tree = default(object);
		object char_literal80_tree = default(object);
		object ID82_tree = default(object);
		object char_literal83_tree = default(object);
		RewriteRuleITokenStream stream_48=new RewriteRuleITokenStream(adaptor,"token 48");
		RewriteRuleITokenStream stream_45=new RewriteRuleITokenStream(adaptor,"token 45");
		RewriteRuleITokenStream stream_INT=new RewriteRuleITokenStream(adaptor,"token INT");
		RewriteRuleITokenStream stream_57=new RewriteRuleITokenStream(adaptor,"token 57");
		RewriteRuleITokenStream stream_56=new RewriteRuleITokenStream(adaptor,"token 56");
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleITokenStream stream_52=new RewriteRuleITokenStream(adaptor,"token 52");
		RewriteRuleITokenStream stream_72=new RewriteRuleITokenStream(adaptor,"token 72");
		RewriteRuleITokenStream stream_73=new RewriteRuleITokenStream(adaptor,"token 73");
		RewriteRuleSubtreeStream stream_assign_expression=new RewriteRuleSubtreeStream(adaptor,"rule assign_expression");
		RewriteRuleSubtreeStream stream_index=new RewriteRuleSubtreeStream(adaptor,"rule index");
		 paraphrases.Push("na atribuição de variável"); 
		try { DebugEnterRule(GrammarFileName, "assign_var");
		DebugLocation(152, 1);
		try
		{
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:153:2: ( ID '=' '[' INT '..' INT ']' -> ^( ASGN ID INT INT ) | ID '=' '{' INT ( ',' INT )* '}' -> ^( ASGN ID ^( ILIST ( INT )* ) ) | ID '[' index ']' '=' assign_expression -> ^( ASGN ^( AR index ) ID assign_expression ) | ID '=' assign_expression -> ^( ASGN ID assign_expression ) )
			int alt20=4;
			try { DebugEnterDecision(20, false);
			int LA20_0 = input.LA(1);

			if ((LA20_0==ID))
			{
				int LA20_1 = input.LA(2);

				if ((LA20_1==52))
				{
					int LA20_2 = input.LA(3);

					if ((EvaluatePredicate(synpred26_NPortugol_fragment)))
					{
						alt20 = 1;
					}
					else if ((EvaluatePredicate(synpred28_NPortugol_fragment)))
					{
						alt20 = 2;
					}
					else if ((true))
					{
						alt20 = 4;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 20, 2, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}
				else if ((LA20_1==56))
				{
					alt20 = 3;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 20, 1, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 20, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(20); }
			switch (alt20)
			{
			case 1:
				DebugEnterAlt(1);
				// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:154:9: ID '=' '[' INT '..' INT ']'
				{
				DebugLocation(154, 9);
				ID62=(IToken)Match(input,ID,Follow._ID_in_assign_var932); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_ID.Add(ID62);

				DebugLocation(154, 12);
				char_literal63=(IToken)Match(input,52,Follow._52_in_assign_var934); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_52.Add(char_literal63);

				DebugLocation(154, 16);
				char_literal64=(IToken)Match(input,56,Follow._56_in_assign_var936); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_56.Add(char_literal64);

				DebugLocation(154, 20);
				INT65=(IToken)Match(input,INT,Follow._INT_in_assign_var938); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_INT.Add(INT65);

				DebugLocation(154, 24);
				string_literal66=(IToken)Match(input,48,Follow._48_in_assign_var940); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_48.Add(string_literal66);

				DebugLocation(154, 29);
				INT67=(IToken)Match(input,INT,Follow._INT_in_assign_var942); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_INT.Add(INT67);

				DebugLocation(154, 33);
				char_literal68=(IToken)Match(input,57,Follow._57_in_assign_var944); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_57.Add(char_literal68);



				{
				// AST REWRITE
				// elements: INT, INT, ID
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 154:37: -> ^( ASGN ID INT INT )
				{
					DebugLocation(154, 40);
					// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:154:40: ^( ASGN ID INT INT )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(154, 42);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(ASGN, "ASGN"), root_1);

					DebugLocation(154, 47);
					adaptor.AddChild(root_1, stream_ID.NextNode());
					DebugLocation(154, 50);
					adaptor.AddChild(root_1, stream_INT.NextNode());
					DebugLocation(154, 54);
					adaptor.AddChild(root_1, stream_INT.NextNode());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:155:10: ID '=' '{' INT ( ',' INT )* '}'
				{
				DebugLocation(155, 10);
				ID69=(IToken)Match(input,ID,Follow._ID_in_assign_var967); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_ID.Add(ID69);

				DebugLocation(155, 13);
				char_literal70=(IToken)Match(input,52,Follow._52_in_assign_var969); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_52.Add(char_literal70);

				DebugLocation(155, 17);
				char_literal71=(IToken)Match(input,72,Follow._72_in_assign_var971); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_72.Add(char_literal71);

				DebugLocation(155, 21);
				INT72=(IToken)Match(input,INT,Follow._INT_in_assign_var973); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_INT.Add(INT72);

				DebugLocation(155, 25);
				// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:155:25: ( ',' INT )*
				try { DebugEnterSubRule(19);
				while (true)
				{
					int alt19=2;
					try { DebugEnterDecision(19, false);
					int LA19_0 = input.LA(1);

					if ((LA19_0==45))
					{
						alt19 = 1;
					}


					} finally { DebugExitDecision(19); }
					switch ( alt19 )
					{
					case 1:
						DebugEnterAlt(1);
						// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:155:26: ',' INT
						{
						DebugLocation(155, 26);
						char_literal73=(IToken)Match(input,45,Follow._45_in_assign_var976); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_45.Add(char_literal73);

						DebugLocation(155, 30);
						INT74=(IToken)Match(input,INT,Follow._INT_in_assign_var978); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_INT.Add(INT74);


						}
						break;

					default:
						goto loop19;
					}
				}

				loop19:
					;

				} finally { DebugExitSubRule(19); }

				DebugLocation(155, 36);
				char_literal75=(IToken)Match(input,73,Follow._73_in_assign_var982); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_73.Add(char_literal75);



				{
				// AST REWRITE
				// elements: INT, ID
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 155:40: -> ^( ASGN ID ^( ILIST ( INT )* ) )
				{
					DebugLocation(155, 43);
					// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:155:43: ^( ASGN ID ^( ILIST ( INT )* ) )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(155, 45);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(ASGN, "ASGN"), root_1);

					DebugLocation(155, 50);
					adaptor.AddChild(root_1, stream_ID.NextNode());
					DebugLocation(155, 53);
					// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:155:53: ^( ILIST ( INT )* )
					{
					object root_2 = (object)adaptor.Nil();
					DebugLocation(155, 55);
					root_2 = (object)adaptor.BecomeRoot((object)adaptor.Create(ILIST, "ILIST"), root_2);

					DebugLocation(155, 61);
					// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:155:61: ( INT )*
					while ( stream_INT.HasNext )
					{
						DebugLocation(155, 61);
						adaptor.AddChild(root_2, stream_INT.NextNode());

					}
					stream_INT.Reset();

					adaptor.AddChild(root_1, root_2);
					}

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:156:4: ID '[' index ']' '=' assign_expression
				{
				DebugLocation(156, 4);
				ID76=(IToken)Match(input,ID,Follow._ID_in_assign_var1002); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_ID.Add(ID76);

				DebugLocation(156, 7);
				char_literal77=(IToken)Match(input,56,Follow._56_in_assign_var1004); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_56.Add(char_literal77);

				DebugLocation(156, 11);
				PushFollow(Follow._index_in_assign_var1006);
				index78=index();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_index.Add(index78.Tree);
				DebugLocation(156, 17);
				char_literal79=(IToken)Match(input,57,Follow._57_in_assign_var1008); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_57.Add(char_literal79);

				DebugLocation(156, 21);
				char_literal80=(IToken)Match(input,52,Follow._52_in_assign_var1010); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_52.Add(char_literal80);

				DebugLocation(156, 25);
				PushFollow(Follow._assign_expression_in_assign_var1012);
				assign_expression81=assign_expression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_assign_expression.Add(assign_expression81.Tree);


				{
				// AST REWRITE
				// elements: ID, assign_expression, index
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 156:44: -> ^( ASGN ^( AR index ) ID assign_expression )
				{
					DebugLocation(156, 47);
					// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:156:47: ^( ASGN ^( AR index ) ID assign_expression )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(156, 49);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(ASGN, "ASGN"), root_1);

					DebugLocation(156, 54);
					// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:156:54: ^( AR index )
					{
					object root_2 = (object)adaptor.Nil();
					DebugLocation(156, 56);
					root_2 = (object)adaptor.BecomeRoot((object)adaptor.Create(AR, "AR"), root_2);

					DebugLocation(156, 59);
					adaptor.AddChild(root_2, stream_index.NextTree());

					adaptor.AddChild(root_1, root_2);
					}
					DebugLocation(156, 66);
					adaptor.AddChild(root_1, stream_ID.NextNode());
					DebugLocation(156, 69);
					adaptor.AddChild(root_1, stream_assign_expression.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:157:11: ID '=' assign_expression
				{
				DebugLocation(157, 11);
				ID82=(IToken)Match(input,ID,Follow._ID_in_assign_var1041); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_ID.Add(ID82);

				DebugLocation(157, 14);
				char_literal83=(IToken)Match(input,52,Follow._52_in_assign_var1043); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_52.Add(char_literal83);

				DebugLocation(157, 18);
				PushFollow(Follow._assign_expression_in_assign_var1045);
				assign_expression84=assign_expression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_assign_expression.Add(assign_expression84.Tree);


				{
				// AST REWRITE
				// elements: ID, assign_expression
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 157:37: -> ^( ASGN ID assign_expression )
				{
					DebugLocation(157, 40);
					// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:157:40: ^( ASGN ID assign_expression )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(157, 42);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(ASGN, "ASGN"), root_1);

					DebugLocation(157, 47);
					adaptor.AddChild(root_1, stream_ID.NextNode());
					DebugLocation(157, 50);
					adaptor.AddChild(root_1, stream_assign_expression.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
			if (state.backtracking == 0)
			{
				 paraphrases.Pop(); 
			}
		}

			catch (RecognitionException e) {
				throw e;
			}

		finally
		{
			TraceOut("assign_var", 17);
			LeaveRule("assign_var", 17);
			LeaveRule_assign_var();
		}
		DebugLocation(158, 1);
		} finally { DebugExitRule(GrammarFileName, "assign_var"); }
		return retval;

	}
	// $ANTLR end "assign_var"

	partial void EnterRule_return_stat();
	partial void LeaveRule_return_stat();

	// $ANTLR start "return_stat"
	// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:160:1: return_stat : 'retorne' assign_expression -> ^( RET assign_expression ) ;
	[GrammarRule("return_stat")]
	private AstParserRuleReturnScope<object, IToken> return_stat()
	{
		EnterRule_return_stat();
		EnterRule("return_stat", 18);
		TraceIn("return_stat", 18);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken string_literal85 = default(IToken);
		AstParserRuleReturnScope<object, IToken> assign_expression86 = default(AstParserRuleReturnScope<object, IToken>);

		object string_literal85_tree = default(object);
		RewriteRuleITokenStream stream_68=new RewriteRuleITokenStream(adaptor,"token 68");
		RewriteRuleSubtreeStream stream_assign_expression=new RewriteRuleSubtreeStream(adaptor,"rule assign_expression");
		try { DebugEnterRule(GrammarFileName, "return_stat");
		DebugLocation(160, 1);
		try
		{
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:161:2: ( 'retorne' assign_expression -> ^( RET assign_expression ) )
			DebugEnterAlt(1);
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:161:4: 'retorne' assign_expression
			{
			DebugLocation(161, 4);
			string_literal85=(IToken)Match(input,68,Follow._68_in_return_stat1068); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_68.Add(string_literal85);

			DebugLocation(161, 14);
			PushFollow(Follow._assign_expression_in_return_stat1070);
			assign_expression86=assign_expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_assign_expression.Add(assign_expression86.Tree);


			{
			// AST REWRITE
			// elements: assign_expression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 161:33: -> ^( RET assign_expression )
			{
				DebugLocation(161, 36);
				// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:161:36: ^( RET assign_expression )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(161, 38);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(RET, "RET"), root_1);

				DebugLocation(161, 42);
				adaptor.AddChild(root_1, stream_assign_expression.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

			catch (RecognitionException e) {
				throw e;
			}

		finally
		{
			TraceOut("return_stat", 18);
			LeaveRule("return_stat", 18);
			LeaveRule_return_stat();
		}
		DebugLocation(162, 1);
		} finally { DebugExitRule(GrammarFileName, "return_stat"); }
		return retval;

	}
	// $ANTLR end "return_stat"

	partial void EnterRule_asm_code();
	partial void LeaveRule_asm_code();

	// $ANTLR start "asm_code"
	// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:165:1: asm_code : '#' ( STRING )* '#' -> ^( ASM ( STRING )* ) ;
	[GrammarRule("asm_code")]
	private AstParserRuleReturnScope<object, IToken> asm_code()
	{
		EnterRule_asm_code();
		EnterRule("asm_code", 19);
		TraceIn("asm_code", 19);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken char_literal87 = default(IToken);
		IToken STRING88 = default(IToken);
		IToken char_literal89 = default(IToken);

		object char_literal87_tree = default(object);
		object STRING88_tree = default(object);
		object char_literal89_tree = default(object);
		RewriteRuleITokenStream stream_39=new RewriteRuleITokenStream(adaptor,"token 39");
		RewriteRuleITokenStream stream_STRING=new RewriteRuleITokenStream(adaptor,"token STRING");
		try { DebugEnterRule(GrammarFileName, "asm_code");
		DebugLocation(165, 8);
		try
		{
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:165:9: ( '#' ( STRING )* '#' -> ^( ASM ( STRING )* ) )
			DebugEnterAlt(1);
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:165:11: '#' ( STRING )* '#'
			{
			DebugLocation(165, 11);
			char_literal87=(IToken)Match(input,39,Follow._39_in_asm_code1089); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_39.Add(char_literal87);

			DebugLocation(165, 15);
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:165:15: ( STRING )*
			try { DebugEnterSubRule(21);
			while (true)
			{
				int alt21=2;
				try { DebugEnterDecision(21, false);
				int LA21_0 = input.LA(1);

				if ((LA21_0==STRING))
				{
					alt21 = 1;
				}


				} finally { DebugExitDecision(21); }
				switch ( alt21 )
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:165:15: STRING
					{
					DebugLocation(165, 15);
					STRING88=(IToken)Match(input,STRING,Follow._STRING_in_asm_code1091); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_STRING.Add(STRING88);


					}
					break;

				default:
					goto loop21;
				}
			}

			loop21:
				;

			} finally { DebugExitSubRule(21); }

			DebugLocation(165, 23);
			char_literal89=(IToken)Match(input,39,Follow._39_in_asm_code1094); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_39.Add(char_literal89);



			{
			// AST REWRITE
			// elements: STRING
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 165:27: -> ^( ASM ( STRING )* )
			{
				DebugLocation(165, 30);
				// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:165:30: ^( ASM ( STRING )* )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(165, 32);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(ASM, "ASM"), root_1);

				DebugLocation(165, 36);
				// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:165:36: ( STRING )*
				while ( stream_STRING.HasNext )
				{
					DebugLocation(165, 36);
					adaptor.AddChild(root_1, stream_STRING.NextNode());

				}
				stream_STRING.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

			catch (RecognitionException e) {
				throw e;
			}

		finally
		{
			TraceOut("asm_code", 19);
			LeaveRule("asm_code", 19);
			LeaveRule_asm_code();
		}
		DebugLocation(166, 8);
		} finally { DebugExitRule(GrammarFileName, "asm_code"); }
		return retval;

	}
	// $ANTLR end "asm_code"

	partial void EnterRule_logic_expression();
	partial void LeaveRule_logic_expression();

	// $ANTLR start "logic_expression"
	// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:172:1: logic_expression : ( plus_expression ) ( binop ^ plus_expression )* ;
	[GrammarRule("logic_expression")]
	private AstParserRuleReturnScope<object, IToken> logic_expression()
	{
		EnterRule_logic_expression();
		EnterRule("logic_expression", 20);
		TraceIn("logic_expression", 20);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> plus_expression90 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> binop91 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> plus_expression92 = default(AstParserRuleReturnScope<object, IToken>);

		try { DebugEnterRule(GrammarFileName, "logic_expression");
		DebugLocation(172, 1);
		try
		{
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:173:2: ( ( plus_expression ) ( binop ^ plus_expression )* )
			DebugEnterAlt(1);
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:173:4: ( plus_expression ) ( binop ^ plus_expression )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(173, 4);
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:173:4: ( plus_expression )
			DebugEnterAlt(1);
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:173:5: plus_expression
			{
			DebugLocation(173, 5);
			PushFollow(Follow._plus_expression_in_logic_expression1126);
			plus_expression90=plus_expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, plus_expression90.Tree);

			}

			DebugLocation(173, 22);
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:173:22: ( binop ^ plus_expression )*
			try { DebugEnterSubRule(22);
			while (true)
			{
				int alt22=2;
				try { DebugEnterDecision(22, false);
				int LA22_0 = input.LA(1);

				if ((LA22_0==38||(LA22_0>=50 && LA22_0<=51)||(LA22_0>=53 && LA22_0<=55)||LA22_0==60||LA22_0==65))
				{
					alt22 = 1;
				}


				} finally { DebugExitDecision(22); }
				switch ( alt22 )
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:173:23: binop ^ plus_expression
					{
					DebugLocation(173, 28);
					PushFollow(Follow._binop_in_logic_expression1130);
					binop91=binop();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) root_0 = (object)adaptor.BecomeRoot(binop91.Tree, root_0);
					DebugLocation(173, 30);
					PushFollow(Follow._plus_expression_in_logic_expression1133);
					plus_expression92=plus_expression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, plus_expression92.Tree);

					}
					break;

				default:
					goto loop22;
				}
			}

			loop22:
				;

			} finally { DebugExitSubRule(22); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

			catch (RecognitionException e) {
				throw e;
			}

		finally
		{
			TraceOut("logic_expression", 20);
			LeaveRule("logic_expression", 20);
			LeaveRule_logic_expression();
		}
		DebugLocation(174, 1);
		} finally { DebugExitRule(GrammarFileName, "logic_expression"); }
		return retval;

	}
	// $ANTLR end "logic_expression"

	partial void EnterRule_binop();
	partial void LeaveRule_binop();

	// $ANTLR start "binop"
	// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:176:1: binop : ( '<' | '>' | '<=' | '>=' | '==' | '!=' | 'e' | 'ou' );
	[GrammarRule("binop")]
	private AstParserRuleReturnScope<object, IToken> binop()
	{
		EnterRule_binop();
		EnterRule("binop", 21);
		TraceIn("binop", 21);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken set93 = default(IToken);

		object set93_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "binop");
		DebugLocation(176, 59);
		try
		{
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:176:7: ( '<' | '>' | '<=' | '>=' | '==' | '!=' | 'e' | 'ou' )
			DebugEnterAlt(1);
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(176, 7);

			set93=(IToken)input.LT(1);
			if (input.LA(1)==38||(input.LA(1)>=50 && input.LA(1)<=51)||(input.LA(1)>=53 && input.LA(1)<=55)||input.LA(1)==60||input.LA(1)==65)
			{
				input.Consume();
				if (state.backtracking == 0) adaptor.AddChild(root_0, (object)adaptor.Create(set93));
				state.errorRecovery=false;state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

			catch (RecognitionException e) {
				throw e;
			}

		finally
		{
			TraceOut("binop", 21);
			LeaveRule("binop", 21);
			LeaveRule_binop();
		}
		DebugLocation(176, 59);
		} finally { DebugExitRule(GrammarFileName, "binop"); }
		return retval;

	}
	// $ANTLR end "binop"

	partial void EnterRule_assign_expression();
	partial void LeaveRule_assign_expression();

	// $ANTLR start "assign_expression"
	// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:179:1: assign_expression options {k=3; } : plus_expression ;
	[GrammarRule("assign_expression")]
	private AstParserRuleReturnScope<object, IToken> assign_expression()
	{
		EnterRule_assign_expression();
		EnterRule("assign_expression", 22);
		TraceIn("assign_expression", 22);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> plus_expression94 = default(AstParserRuleReturnScope<object, IToken>);

		try { DebugEnterRule(GrammarFileName, "assign_expression");
		DebugLocation(179, 19);
		try
		{
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:181:2: ( plus_expression )
			DebugEnterAlt(1);
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:181:5: plus_expression
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(181, 5);
			PushFollow(Follow._plus_expression_in_assign_expression1194);
			plus_expression94=plus_expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, plus_expression94.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

			catch (RecognitionException e) {
				throw e;
			}

		finally
		{
			TraceOut("assign_expression", 22);
			LeaveRule("assign_expression", 22);
			LeaveRule_assign_expression();
		}
		DebugLocation(181, 19);
		} finally { DebugExitRule(GrammarFileName, "assign_expression"); }
		return retval;

	}
	// $ANTLR end "assign_expression"

	partial void EnterRule_plus_expression();
	partial void LeaveRule_plus_expression();

	// $ANTLR start "plus_expression"
	// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:183:1: plus_expression : ( mul_expression ) ( '+' ^ mul_expression | '-' ^ mul_expression )* ;
	[GrammarRule("plus_expression")]
	private AstParserRuleReturnScope<object, IToken> plus_expression()
	{
		EnterRule_plus_expression();
		EnterRule("plus_expression", 23);
		TraceIn("plus_expression", 23);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken char_literal96 = default(IToken);
		IToken char_literal98 = default(IToken);
		AstParserRuleReturnScope<object, IToken> mul_expression95 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> mul_expression97 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> mul_expression99 = default(AstParserRuleReturnScope<object, IToken>);

		object char_literal96_tree = default(object);
		object char_literal98_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "plus_expression");
		DebugLocation(183, 1);
		try
		{
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:184:2: ( ( mul_expression ) ( '+' ^ mul_expression | '-' ^ mul_expression )* )
			DebugEnterAlt(1);
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:184:4: ( mul_expression ) ( '+' ^ mul_expression | '-' ^ mul_expression )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(184, 4);
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:184:4: ( mul_expression )
			DebugEnterAlt(1);
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:184:5: mul_expression
			{
			DebugLocation(184, 5);
			PushFollow(Follow._mul_expression_in_plus_expression1204);
			mul_expression95=mul_expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, mul_expression95.Tree);

			}

			DebugLocation(184, 21);
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:184:21: ( '+' ^ mul_expression | '-' ^ mul_expression )*
			try { DebugEnterSubRule(23);
			while (true)
			{
				int alt23=3;
				try { DebugEnterDecision(23, false);
				int LA23_0 = input.LA(1);

				if ((LA23_0==44))
				{
					alt23 = 1;
				}
				else if ((LA23_0==46))
				{
					alt23 = 2;
				}


				} finally { DebugExitDecision(23); }
				switch ( alt23 )
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:184:22: '+' ^ mul_expression
					{
					DebugLocation(184, 25);
					char_literal96=(IToken)Match(input,44,Follow._44_in_plus_expression1208); if (state.failed) return retval;
					if (state.backtracking == 0) {
					char_literal96_tree = (object)adaptor.Create(char_literal96);
					root_0 = (object)adaptor.BecomeRoot(char_literal96_tree, root_0);
					}
					DebugLocation(184, 27);
					PushFollow(Follow._mul_expression_in_plus_expression1211);
					mul_expression97=mul_expression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, mul_expression97.Tree);

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:184:44: '-' ^ mul_expression
					{
					DebugLocation(184, 47);
					char_literal98=(IToken)Match(input,46,Follow._46_in_plus_expression1215); if (state.failed) return retval;
					if (state.backtracking == 0) {
					char_literal98_tree = (object)adaptor.Create(char_literal98);
					root_0 = (object)adaptor.BecomeRoot(char_literal98_tree, root_0);
					}
					DebugLocation(184, 49);
					PushFollow(Follow._mul_expression_in_plus_expression1218);
					mul_expression99=mul_expression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, mul_expression99.Tree);

					}
					break;

				default:
					goto loop23;
				}
			}

			loop23:
				;

			} finally { DebugExitSubRule(23); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

			catch (RecognitionException e) {
				throw e;
			}

		finally
		{
			TraceOut("plus_expression", 23);
			LeaveRule("plus_expression", 23);
			LeaveRule_plus_expression();
		}
		DebugLocation(185, 1);
		} finally { DebugExitRule(GrammarFileName, "plus_expression"); }
		return retval;

	}
	// $ANTLR end "plus_expression"

	partial void EnterRule_mul_expression();
	partial void LeaveRule_mul_expression();

	// $ANTLR start "mul_expression"
	// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:187:1: mul_expression : ( primary_ar_expression ) ( '/' ^ primary_ar_expression | '%' ^ primary_ar_expression | '*' ^ primary_ar_expression )* ;
	[GrammarRule("mul_expression")]
	private AstParserRuleReturnScope<object, IToken> mul_expression()
	{
		EnterRule_mul_expression();
		EnterRule("mul_expression", 24);
		TraceIn("mul_expression", 24);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken char_literal101 = default(IToken);
		IToken char_literal103 = default(IToken);
		IToken char_literal105 = default(IToken);
		AstParserRuleReturnScope<object, IToken> primary_ar_expression100 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> primary_ar_expression102 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> primary_ar_expression104 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> primary_ar_expression106 = default(AstParserRuleReturnScope<object, IToken>);

		object char_literal101_tree = default(object);
		object char_literal103_tree = default(object);
		object char_literal105_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "mul_expression");
		DebugLocation(187, 1);
		try
		{
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:188:2: ( ( primary_ar_expression ) ( '/' ^ primary_ar_expression | '%' ^ primary_ar_expression | '*' ^ primary_ar_expression )* )
			DebugEnterAlt(1);
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:188:4: ( primary_ar_expression ) ( '/' ^ primary_ar_expression | '%' ^ primary_ar_expression | '*' ^ primary_ar_expression )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(188, 4);
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:188:4: ( primary_ar_expression )
			DebugEnterAlt(1);
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:188:5: primary_ar_expression
			{
			DebugLocation(188, 5);
			PushFollow(Follow._primary_ar_expression_in_mul_expression1233);
			primary_ar_expression100=primary_ar_expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, primary_ar_expression100.Tree);

			}

			DebugLocation(188, 28);
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:188:28: ( '/' ^ primary_ar_expression | '%' ^ primary_ar_expression | '*' ^ primary_ar_expression )*
			try { DebugEnterSubRule(24);
			while (true)
			{
				int alt24=4;
				try { DebugEnterDecision(24, false);
				switch (input.LA(1))
				{
				case 49:
					{
					alt24 = 1;
					}
					break;
				case 40:
					{
					alt24 = 2;
					}
					break;
				case 43:
					{
					alt24 = 3;
					}
					break;
				}

				} finally { DebugExitDecision(24); }
				switch ( alt24 )
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:188:30: '/' ^ primary_ar_expression
					{
					DebugLocation(188, 33);
					char_literal101=(IToken)Match(input,49,Follow._49_in_mul_expression1238); if (state.failed) return retval;
					if (state.backtracking == 0) {
					char_literal101_tree = (object)adaptor.Create(char_literal101);
					root_0 = (object)adaptor.BecomeRoot(char_literal101_tree, root_0);
					}
					DebugLocation(188, 35);
					PushFollow(Follow._primary_ar_expression_in_mul_expression1241);
					primary_ar_expression102=primary_ar_expression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, primary_ar_expression102.Tree);

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:188:59: '%' ^ primary_ar_expression
					{
					DebugLocation(188, 62);
					char_literal103=(IToken)Match(input,40,Follow._40_in_mul_expression1245); if (state.failed) return retval;
					if (state.backtracking == 0) {
					char_literal103_tree = (object)adaptor.Create(char_literal103);
					root_0 = (object)adaptor.BecomeRoot(char_literal103_tree, root_0);
					}
					DebugLocation(188, 64);
					PushFollow(Follow._primary_ar_expression_in_mul_expression1248);
					primary_ar_expression104=primary_ar_expression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, primary_ar_expression104.Tree);

					}
					break;
				case 3:
					DebugEnterAlt(3);
					// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:188:88: '*' ^ primary_ar_expression
					{
					DebugLocation(188, 91);
					char_literal105=(IToken)Match(input,43,Follow._43_in_mul_expression1252); if (state.failed) return retval;
					if (state.backtracking == 0) {
					char_literal105_tree = (object)adaptor.Create(char_literal105);
					root_0 = (object)adaptor.BecomeRoot(char_literal105_tree, root_0);
					}
					DebugLocation(188, 93);
					PushFollow(Follow._primary_ar_expression_in_mul_expression1255);
					primary_ar_expression106=primary_ar_expression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, primary_ar_expression106.Tree);

					}
					break;

				default:
					goto loop24;
				}
			}

			loop24:
				;

			} finally { DebugExitSubRule(24); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

			catch (RecognitionException e) {
				throw e;
			}

		finally
		{
			TraceOut("mul_expression", 24);
			LeaveRule("mul_expression", 24);
			LeaveRule_mul_expression();
		}
		DebugLocation(189, 1);
		} finally { DebugExitRule(GrammarFileName, "mul_expression"); }
		return retval;

	}
	// $ANTLR end "mul_expression"

	partial void EnterRule_primary_ar_expression();
	partial void LeaveRule_primary_ar_expression();

	// $ANTLR start "primary_ar_expression"
	// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:191:1: primary_ar_expression : ({...}? => function_call | ID | ID '[' index ']' -> ^( INDEX index ) ID | method_call | property_call | constant | parenthesisExpression );
	[GrammarRule("primary_ar_expression")]
	private AstParserRuleReturnScope<object, IToken> primary_ar_expression()
	{
		EnterRule_primary_ar_expression();
		EnterRule("primary_ar_expression", 25);
		TraceIn("primary_ar_expression", 25);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken ID108 = default(IToken);
		IToken ID109 = default(IToken);
		IToken char_literal110 = default(IToken);
		IToken char_literal112 = default(IToken);
		AstParserRuleReturnScope<object, IToken> function_call107 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> index111 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> method_call113 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> property_call114 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> constant115 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> parenthesisExpression116 = default(AstParserRuleReturnScope<object, IToken>);

		object ID108_tree = default(object);
		object ID109_tree = default(object);
		object char_literal110_tree = default(object);
		object char_literal112_tree = default(object);
		RewriteRuleITokenStream stream_57=new RewriteRuleITokenStream(adaptor,"token 57");
		RewriteRuleITokenStream stream_56=new RewriteRuleITokenStream(adaptor,"token 56");
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleSubtreeStream stream_index=new RewriteRuleSubtreeStream(adaptor,"rule index");
		try { DebugEnterRule(GrammarFileName, "primary_ar_expression");
		DebugLocation(191, 1);
		try
		{
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:192:2: ({...}? => function_call | ID | ID '[' index ']' -> ^( INDEX index ) ID | method_call | property_call | constant | parenthesisExpression )
			int alt25=7;
			try { DebugEnterDecision(25, false);
			switch (input.LA(1))
			{
			case ID:
				{
				switch (input.LA(2))
				{
				case 41:
					{
					int LA25_4 = input.LA(3);

					if ((((( (!IsDefinedID(input.LT(1).Text)) && input.LT(2).Text =="(" )&&( (!IsDefinedID(input.LT(1).Text)) && input.LT(2).Text =="(" ))&&EvaluatePredicate(synpred44_NPortugol_fragment))))
					{
						alt25 = 1;
					}
					else if ((EvaluatePredicate(synpred45_NPortugol_fragment)))
					{
						alt25 = 2;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 25, 4, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					}
					break;
				case 56:
					{
					alt25 = 3;
					}
					break;
				case 47:
					{
					int LA25_6 = input.LA(3);

					if ((EvaluatePredicate(synpred47_NPortugol_fragment)))
					{
						alt25 = 4;
					}
					else if ((EvaluatePredicate(synpred48_NPortugol_fragment)))
					{
						alt25 = 5;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 25, 6, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					}
					break;
				case EOF:
				case FLOAT:
				case ID:
				case INT:
				case STRING:
				case 38:
				case 39:
				case 40:
				case 42:
				case 43:
				case 44:
				case 45:
				case 46:
				case 49:
				case 50:
				case 51:
				case 53:
				case 54:
				case 55:
				case 58:
				case 60:
				case 61:
				case 62:
				case 63:
				case 65:
				case 66:
				case 67:
				case 68:
				case 69:
				case 70:
				case 71:
					{
					alt25 = 2;
					}
					break;
				default:
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 25, 1, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}

				}
				break;
			case FLOAT:
			case INT:
			case STRING:
				{
				alt25 = 6;
				}
				break;
			case 41:
				{
				alt25 = 7;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 25, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(25); }
			switch (alt25)
			{
			case 1:
				DebugEnterAlt(1);
				// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:192:4: {...}? => function_call
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(192, 4);
				if (!(( (!IsDefinedID(input.LT(1).Text)) && input.LT(2).Text =="(" )))
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					throw new FailedPredicateException(input, "primary_ar_expression", " (!IsDefinedID(input.LT(1).Text)) && input.LT(2).Text ==\"(\" ");
				}
				DebugLocation(192, 71);
				PushFollow(Follow._function_call_in_primary_ar_expression1273);
				function_call107=function_call();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, function_call107.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:193:4: ID
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(193, 4);
				ID108=(IToken)Match(input,ID,Follow._ID_in_primary_ar_expression1278); if (state.failed) return retval;
				if (state.backtracking == 0) {
				ID108_tree = (object)adaptor.Create(ID108);
				adaptor.AddChild(root_0, ID108_tree);
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:194:4: ID '[' index ']'
				{
				DebugLocation(194, 4);
				ID109=(IToken)Match(input,ID,Follow._ID_in_primary_ar_expression1283); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_ID.Add(ID109);

				DebugLocation(194, 7);
				char_literal110=(IToken)Match(input,56,Follow._56_in_primary_ar_expression1285); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_56.Add(char_literal110);

				DebugLocation(194, 11);
				PushFollow(Follow._index_in_primary_ar_expression1287);
				index111=index();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_index.Add(index111.Tree);
				DebugLocation(194, 17);
				char_literal112=(IToken)Match(input,57,Follow._57_in_primary_ar_expression1289); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_57.Add(char_literal112);



				{
				// AST REWRITE
				// elements: index, ID
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 194:21: -> ^( INDEX index ) ID
				{
					DebugLocation(194, 24);
					// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:194:24: ^( INDEX index )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(194, 26);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(INDEX, "INDEX"), root_1);

					DebugLocation(194, 32);
					adaptor.AddChild(root_1, stream_index.NextTree());

					adaptor.AddChild(root_0, root_1);
					}
					DebugLocation(194, 39);
					adaptor.AddChild(root_0, stream_ID.NextNode());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:195:4: method_call
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(195, 4);
				PushFollow(Follow._method_call_in_primary_ar_expression1304);
				method_call113=method_call();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, method_call113.Tree);

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:196:4: property_call
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(196, 4);
				PushFollow(Follow._property_call_in_primary_ar_expression1310);
				property_call114=property_call();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, property_call114.Tree);

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:197:4: constant
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(197, 4);
				PushFollow(Follow._constant_in_primary_ar_expression1315);
				constant115=constant();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, constant115.Tree);

				}
				break;
			case 7:
				DebugEnterAlt(7);
				// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:198:4: parenthesisExpression
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(198, 4);
				PushFollow(Follow._parenthesisExpression_in_primary_ar_expression1320);
				parenthesisExpression116=parenthesisExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, parenthesisExpression116.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

			catch (RecognitionException e) {
				throw e;
			}

		finally
		{
			TraceOut("primary_ar_expression", 25);
			LeaveRule("primary_ar_expression", 25);
			LeaveRule_primary_ar_expression();
		}
		DebugLocation(199, 1);
		} finally { DebugExitRule(GrammarFileName, "primary_ar_expression"); }
		return retval;

	}
	// $ANTLR end "primary_ar_expression"

	partial void EnterRule_parenthesisExpression();
	partial void LeaveRule_parenthesisExpression();

	// $ANTLR start "parenthesisExpression"
	// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:201:1: parenthesisExpression : '(' plus_expression ')' -> plus_expression ;
	[GrammarRule("parenthesisExpression")]
	private AstParserRuleReturnScope<object, IToken> parenthesisExpression()
	{
		EnterRule_parenthesisExpression();
		EnterRule("parenthesisExpression", 26);
		TraceIn("parenthesisExpression", 26);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken char_literal117 = default(IToken);
		IToken char_literal119 = default(IToken);
		AstParserRuleReturnScope<object, IToken> plus_expression118 = default(AstParserRuleReturnScope<object, IToken>);

		object char_literal117_tree = default(object);
		object char_literal119_tree = default(object);
		RewriteRuleITokenStream stream_42=new RewriteRuleITokenStream(adaptor,"token 42");
		RewriteRuleITokenStream stream_41=new RewriteRuleITokenStream(adaptor,"token 41");
		RewriteRuleSubtreeStream stream_plus_expression=new RewriteRuleSubtreeStream(adaptor,"rule plus_expression");
		try { DebugEnterRule(GrammarFileName, "parenthesisExpression");
		DebugLocation(201, 1);
		try
		{
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:201:22: ( '(' plus_expression ')' -> plus_expression )
			DebugEnterAlt(1);
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:201:24: '(' plus_expression ')'
			{
			DebugLocation(201, 24);
			char_literal117=(IToken)Match(input,41,Follow._41_in_parenthesisExpression1335); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_41.Add(char_literal117);

			DebugLocation(201, 28);
			PushFollow(Follow._plus_expression_in_parenthesisExpression1337);
			plus_expression118=plus_expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_plus_expression.Add(plus_expression118.Tree);
			DebugLocation(201, 44);
			char_literal119=(IToken)Match(input,42,Follow._42_in_parenthesisExpression1339); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_42.Add(char_literal119);



			{
			// AST REWRITE
			// elements: plus_expression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 201:48: -> plus_expression
			{
				DebugLocation(201, 51);
				adaptor.AddChild(root_0, stream_plus_expression.NextTree());

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

			catch (RecognitionException e) {
				throw e;
			}

		finally
		{
			TraceOut("parenthesisExpression", 26);
			LeaveRule("parenthesisExpression", 26);
			LeaveRule_parenthesisExpression();
		}
		DebugLocation(202, 1);
		} finally { DebugExitRule(GrammarFileName, "parenthesisExpression"); }
		return retval;

	}
	// $ANTLR end "parenthesisExpression"

	partial void EnterRule_constant();
	partial void LeaveRule_constant();

	// $ANTLR start "constant"
	// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:204:1: constant : ( INT | FLOAT | STRING );
	[GrammarRule("constant")]
	private AstParserRuleReturnScope<object, IToken> constant()
	{
		EnterRule_constant();
		EnterRule("constant", 27);
		TraceIn("constant", 27);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken set120 = default(IToken);

		object set120_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "constant");
		DebugLocation(204, 30);
		try
		{
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:204:9: ( INT | FLOAT | STRING )
			DebugEnterAlt(1);
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(204, 9);

			set120=(IToken)input.LT(1);
			if (input.LA(1)==FLOAT||input.LA(1)==INT||input.LA(1)==STRING)
			{
				input.Consume();
				if (state.backtracking == 0) adaptor.AddChild(root_0, (object)adaptor.Create(set120));
				state.errorRecovery=false;state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

			catch (RecognitionException e) {
				throw e;
			}

		finally
		{
			TraceOut("constant", 27);
			LeaveRule("constant", 27);
			LeaveRule_constant();
		}
		DebugLocation(204, 30);
		} finally { DebugExitRule(GrammarFileName, "constant"); }
		return retval;

	}
	// $ANTLR end "constant"

	partial void EnterRule_atom();
	partial void LeaveRule_atom();

	// $ANTLR start "atom"
	// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:206:1: atom : ( constant | ID );
	[GrammarRule("atom")]
	private AstParserRuleReturnScope<object, IToken> atom()
	{
		EnterRule_atom();
		EnterRule("atom", 28);
		TraceIn("atom", 28);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken ID122 = default(IToken);
		AstParserRuleReturnScope<object, IToken> constant121 = default(AstParserRuleReturnScope<object, IToken>);

		object ID122_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "atom");
		DebugLocation(206, 20);
		try
		{
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:206:6: ( constant | ID )
			int alt26=2;
			try { DebugEnterDecision(26, false);
			int LA26_0 = input.LA(1);

			if ((LA26_0==FLOAT||LA26_0==INT||LA26_0==STRING))
			{
				alt26 = 1;
			}
			else if ((LA26_0==ID))
			{
				alt26 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 26, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(26); }
			switch (alt26)
			{
			case 1:
				DebugEnterAlt(1);
				// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:206:8: constant
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(206, 8);
				PushFollow(Follow._constant_in_atom1370);
				constant121=constant();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, constant121.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:206:19: ID
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(206, 19);
				ID122=(IToken)Match(input,ID,Follow._ID_in_atom1374); if (state.failed) return retval;
				if (state.backtracking == 0) {
				ID122_tree = (object)adaptor.Create(ID122);
				adaptor.AddChild(root_0, ID122_tree);
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

			catch (RecognitionException e) {
				throw e;
			}

		finally
		{
			TraceOut("atom", 28);
			LeaveRule("atom", 28);
			LeaveRule_atom();
		}
		DebugLocation(206, 20);
		} finally { DebugExitRule(GrammarFileName, "atom"); }
		return retval;

	}
	// $ANTLR end "atom"

	partial void EnterRule_index();
	partial void LeaveRule_index();

	// $ANTLR start "index"
	// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:208:1: index : ( INT | ID );
	[GrammarRule("index")]
	private AstParserRuleReturnScope<object, IToken> index()
	{
		EnterRule_index();
		EnterRule("index", 29);
		TraceIn("index", 29);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken set123 = default(IToken);

		object set123_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "index");
		DebugLocation(208, 16);
		try
		{
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:208:7: ( INT | ID )
			DebugEnterAlt(1);
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(208, 7);

			set123=(IToken)input.LT(1);
			if (input.LA(1)==ID||input.LA(1)==INT)
			{
				input.Consume();
				if (state.backtracking == 0) adaptor.AddChild(root_0, (object)adaptor.Create(set123));
				state.errorRecovery=false;state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

			catch (RecognitionException e) {
				throw e;
			}

		finally
		{
			TraceOut("index", 29);
			LeaveRule("index", 29);
			LeaveRule_index();
		}
		DebugLocation(208, 16);
		} finally { DebugExitRule(GrammarFileName, "index"); }
		return retval;

	}
	// $ANTLR end "index"

	partial void EnterRule_number();
	partial void LeaveRule_number();

	// $ANTLR start "number"
	// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:210:1: number : ( INT | FLOAT );
	[GrammarRule("number")]
	private AstParserRuleReturnScope<object, IToken> number()
	{
		EnterRule_number();
		EnterRule("number", 30);
		TraceIn("number", 30);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken set124 = default(IToken);

		object set124_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "number");
		DebugLocation(210, 20);
		try
		{
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:210:8: ( INT | FLOAT )
			DebugEnterAlt(1);
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(210, 8);

			set124=(IToken)input.LT(1);
			if (input.LA(1)==FLOAT||input.LA(1)==INT)
			{
				input.Consume();
				if (state.backtracking == 0) adaptor.AddChild(root_0, (object)adaptor.Create(set124));
				state.errorRecovery=false;state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

			catch (RecognitionException e) {
				throw e;
			}

		finally
		{
			TraceOut("number", 30);
			LeaveRule("number", 30);
			LeaveRule_number();
		}
		DebugLocation(210, 20);
		} finally { DebugExitRule(GrammarFileName, "number"); }
		return retval;

	}
	// $ANTLR end "number"

	partial void EnterRule_synpred23_NPortugol_fragment();
	partial void LeaveRule_synpred23_NPortugol_fragment();

	// $ANTLR start synpred23_NPortugol
	public void synpred23_NPortugol_fragment()
	{
		EnterRule_synpred23_NPortugol_fragment();
		EnterRule("synpred23_NPortugol_fragment", 53);
		TraceIn("synpred23_NPortugol_fragment", 53);
		try
		{
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:136:11: ( function_arg_list )
			DebugEnterAlt(1);
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:136:11: function_arg_list
			{
			DebugLocation(136, 11);
			PushFollow(Follow._function_arg_list_in_synpred23_NPortugol727);
			function_arg_list();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred23_NPortugol_fragment", 53);
			LeaveRule("synpred23_NPortugol_fragment", 53);
			LeaveRule_synpred23_NPortugol_fragment();
		}
	}
	// $ANTLR end synpred23_NPortugol

	partial void EnterRule_synpred24_NPortugol_fragment();
	partial void LeaveRule_synpred24_NPortugol_fragment();

	// $ANTLR start synpred24_NPortugol
	public void synpred24_NPortugol_fragment()
	{
		EnterRule_synpred24_NPortugol_fragment();
		EnterRule("synpred24_NPortugol_fragment", 54);
		TraceIn("synpred24_NPortugol_fragment", 54);
		try
		{
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:144:20: ( function_arg_list )
			DebugEnterAlt(1);
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:144:20: function_arg_list
			{
			DebugLocation(144, 20);
			PushFollow(Follow._function_arg_list_in_synpred24_NPortugol827);
			function_arg_list();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred24_NPortugol_fragment", 54);
			LeaveRule("synpred24_NPortugol_fragment", 54);
			LeaveRule_synpred24_NPortugol_fragment();
		}
	}
	// $ANTLR end synpred24_NPortugol

	partial void EnterRule_synpred26_NPortugol_fragment();
	partial void LeaveRule_synpred26_NPortugol_fragment();

	// $ANTLR start synpred26_NPortugol
	public void synpred26_NPortugol_fragment()
	{
		EnterRule_synpred26_NPortugol_fragment();
		EnterRule("synpred26_NPortugol_fragment", 56);
		TraceIn("synpred26_NPortugol_fragment", 56);
		try
		{
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:154:9: ( ID '=' '[' INT '..' INT ']' )
			DebugEnterAlt(1);
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:154:9: ID '=' '[' INT '..' INT ']'
			{
			DebugLocation(154, 9);
			Match(input,ID,Follow._ID_in_synpred26_NPortugol932); if (state.failed) return;
			DebugLocation(154, 12);
			Match(input,52,Follow._52_in_synpred26_NPortugol934); if (state.failed) return;
			DebugLocation(154, 16);
			Match(input,56,Follow._56_in_synpred26_NPortugol936); if (state.failed) return;
			DebugLocation(154, 20);
			Match(input,INT,Follow._INT_in_synpred26_NPortugol938); if (state.failed) return;
			DebugLocation(154, 24);
			Match(input,48,Follow._48_in_synpred26_NPortugol940); if (state.failed) return;
			DebugLocation(154, 29);
			Match(input,INT,Follow._INT_in_synpred26_NPortugol942); if (state.failed) return;
			DebugLocation(154, 33);
			Match(input,57,Follow._57_in_synpred26_NPortugol944); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred26_NPortugol_fragment", 56);
			LeaveRule("synpred26_NPortugol_fragment", 56);
			LeaveRule_synpred26_NPortugol_fragment();
		}
	}
	// $ANTLR end synpred26_NPortugol

	partial void EnterRule_synpred28_NPortugol_fragment();
	partial void LeaveRule_synpred28_NPortugol_fragment();

	// $ANTLR start synpred28_NPortugol
	public void synpred28_NPortugol_fragment()
	{
		EnterRule_synpred28_NPortugol_fragment();
		EnterRule("synpred28_NPortugol_fragment", 58);
		TraceIn("synpred28_NPortugol_fragment", 58);
		try
		{
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:155:10: ( ID '=' '{' INT ( ',' INT )* '}' )
			DebugEnterAlt(1);
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:155:10: ID '=' '{' INT ( ',' INT )* '}'
			{
			DebugLocation(155, 10);
			Match(input,ID,Follow._ID_in_synpred28_NPortugol967); if (state.failed) return;
			DebugLocation(155, 13);
			Match(input,52,Follow._52_in_synpred28_NPortugol969); if (state.failed) return;
			DebugLocation(155, 17);
			Match(input,72,Follow._72_in_synpred28_NPortugol971); if (state.failed) return;
			DebugLocation(155, 21);
			Match(input,INT,Follow._INT_in_synpred28_NPortugol973); if (state.failed) return;
			DebugLocation(155, 25);
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:155:25: ( ',' INT )*
			try { DebugEnterSubRule(28);
			while (true)
			{
				int alt28=2;
				try { DebugEnterDecision(28, false);
				int LA28_0 = input.LA(1);

				if ((LA28_0==45))
				{
					alt28 = 1;
				}


				} finally { DebugExitDecision(28); }
				switch ( alt28 )
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:155:26: ',' INT
					{
					DebugLocation(155, 26);
					Match(input,45,Follow._45_in_synpred28_NPortugol976); if (state.failed) return;
					DebugLocation(155, 30);
					Match(input,INT,Follow._INT_in_synpred28_NPortugol978); if (state.failed) return;

					}
					break;

				default:
					goto loop28;
				}
			}

			loop28:
				;

			} finally { DebugExitSubRule(28); }

			DebugLocation(155, 36);
			Match(input,73,Follow._73_in_synpred28_NPortugol982); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred28_NPortugol_fragment", 58);
			LeaveRule("synpred28_NPortugol_fragment", 58);
			LeaveRule_synpred28_NPortugol_fragment();
		}
	}
	// $ANTLR end synpred28_NPortugol

	partial void EnterRule_synpred44_NPortugol_fragment();
	partial void LeaveRule_synpred44_NPortugol_fragment();

	// $ANTLR start synpred44_NPortugol
	public void synpred44_NPortugol_fragment()
	{
		EnterRule_synpred44_NPortugol_fragment();
		EnterRule("synpred44_NPortugol_fragment", 74);
		TraceIn("synpred44_NPortugol_fragment", 74);
		try
		{
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:192:4: ({...}? => function_call )
			DebugEnterAlt(1);
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:192:4: {...}? => function_call
			{
			DebugLocation(192, 4);
			if (!(( (!IsDefinedID(input.LT(1).Text)) && input.LT(2).Text =="(" )))
			{
				if (state.backtracking>0) {state.failed=true; return;}
				throw new FailedPredicateException(input, "synpred44_NPortugol", " (!IsDefinedID(input.LT(1).Text)) && input.LT(2).Text ==\"(\" ");
			}
			DebugLocation(192, 71);
			PushFollow(Follow._function_call_in_synpred44_NPortugol1273);
			function_call();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred44_NPortugol_fragment", 74);
			LeaveRule("synpred44_NPortugol_fragment", 74);
			LeaveRule_synpred44_NPortugol_fragment();
		}
	}
	// $ANTLR end synpred44_NPortugol

	partial void EnterRule_synpred45_NPortugol_fragment();
	partial void LeaveRule_synpred45_NPortugol_fragment();

	// $ANTLR start synpred45_NPortugol
	public void synpred45_NPortugol_fragment()
	{
		EnterRule_synpred45_NPortugol_fragment();
		EnterRule("synpred45_NPortugol_fragment", 75);
		TraceIn("synpred45_NPortugol_fragment", 75);
		try
		{
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:193:4: ( ID )
			DebugEnterAlt(1);
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:193:4: ID
			{
			DebugLocation(193, 4);
			Match(input,ID,Follow._ID_in_synpred45_NPortugol1278); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred45_NPortugol_fragment", 75);
			LeaveRule("synpred45_NPortugol_fragment", 75);
			LeaveRule_synpred45_NPortugol_fragment();
		}
	}
	// $ANTLR end synpred45_NPortugol

	partial void EnterRule_synpred47_NPortugol_fragment();
	partial void LeaveRule_synpred47_NPortugol_fragment();

	// $ANTLR start synpred47_NPortugol
	public void synpred47_NPortugol_fragment()
	{
		EnterRule_synpred47_NPortugol_fragment();
		EnterRule("synpred47_NPortugol_fragment", 77);
		TraceIn("synpred47_NPortugol_fragment", 77);
		try
		{
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:195:4: ( method_call )
			DebugEnterAlt(1);
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:195:4: method_call
			{
			DebugLocation(195, 4);
			PushFollow(Follow._method_call_in_synpred47_NPortugol1304);
			method_call();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred47_NPortugol_fragment", 77);
			LeaveRule("synpred47_NPortugol_fragment", 77);
			LeaveRule_synpred47_NPortugol_fragment();
		}
	}
	// $ANTLR end synpred47_NPortugol

	partial void EnterRule_synpred48_NPortugol_fragment();
	partial void LeaveRule_synpred48_NPortugol_fragment();

	// $ANTLR start synpred48_NPortugol
	public void synpred48_NPortugol_fragment()
	{
		EnterRule_synpred48_NPortugol_fragment();
		EnterRule("synpred48_NPortugol_fragment", 78);
		TraceIn("synpred48_NPortugol_fragment", 78);
		try
		{
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:196:4: ( property_call )
			DebugEnterAlt(1);
			// E:\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:196:4: property_call
			{
			DebugLocation(196, 4);
			PushFollow(Follow._property_call_in_synpred48_NPortugol1310);
			property_call();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred48_NPortugol_fragment", 78);
			LeaveRule("synpred48_NPortugol_fragment", 78);
			LeaveRule_synpred48_NPortugol_fragment();
		}
	}
	// $ANTLR end synpred48_NPortugol
	#endregion Rules

	#region Synpreds
	private bool EvaluatePredicate(System.Action fragment)
	{
		bool success = false;
		state.backtracking++;
		try { DebugBeginBacktrack(state.backtracking);
		int start = input.Mark();
		try
		{
			fragment();
		}
		catch ( RecognitionException re )
		{
			System.Console.Error.WriteLine("impossible: "+re);
		}
		success = !state.failed;
		input.Rewind(start);
		} finally { DebugEndBacktrack(state.backtracking, success); }
		state.backtracking--;
		state.failed=false;
		return success;
	}
	#endregion Synpreds


	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _declare_function_in_script148 = new BitSet(new ulong[]{0x2UL,0x1UL});
		public static readonly BitSet _64_in_declare_function159 = new BitSet(new ulong[]{0x400020000UL});
		public static readonly BitSet _TYPE_in_declare_function163 = new BitSet(new ulong[]{0x20000UL});
		public static readonly BitSet _ID_in_declare_function168 = new BitSet(new ulong[]{0x20000000000UL});
		public static readonly BitSet _41_in_declare_function170 = new BitSet(new ulong[]{0x40400000000UL});
		public static readonly BitSet _function_param_list_in_declare_function172 = new BitSet(new ulong[]{0x40400000000UL});
		public static readonly BitSet _42_in_declare_function175 = new BitSet(new ulong[]{0xA000008000020000UL,0xBCUL});
		public static readonly BitSet _statement_in_declare_function177 = new BitSet(new ulong[]{0xA000008000020000UL,0xBCUL});
		public static readonly BitSet _63_in_declare_function180 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _declare_local_in_statement230 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _if_stat_in_statement236 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _for_stat_in_statement242 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _while_stat_in_statement247 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _repeat_stat_in_statement252 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _function_call_in_statement258 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _assign_var_in_statement264 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _return_stat_in_statement270 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _asm_code_in_statement275 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _param_in_function_param_list303 = new BitSet(new ulong[]{0x200000000002UL});
		public static readonly BitSet _45_in_function_param_list306 = new BitSet(new ulong[]{0x400000000UL});
		public static readonly BitSet _param_in_function_param_list308 = new BitSet(new ulong[]{0x200000000002UL});
		public static readonly BitSet _TYPE_in_param331 = new BitSet(new ulong[]{0x20000UL});
		public static readonly BitSet _ID_in_param333 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _71_in_declare_local373 = new BitSet(new ulong[]{0x400000000UL});
		public static readonly BitSet _local_var_in_declare_local375 = new BitSet(new ulong[]{0x200000000002UL});
		public static readonly BitSet _45_in_declare_local378 = new BitSet(new ulong[]{0x20000UL});
		public static readonly BitSet _ID_in_declare_local380 = new BitSet(new ulong[]{0x200000000002UL});
		public static readonly BitSet _TYPE_in_local_var406 = new BitSet(new ulong[]{0x20000UL});
		public static readonly BitSet _ID_in_local_var408 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _69_in_if_stat440 = new BitSet(new ulong[]{0x20200224000UL});
		public static readonly BitSet _logic_expression_in_if_stat444 = new BitSet(new ulong[]{0x4000000000000000UL});
		public static readonly BitSet _62_in_if_stat446 = new BitSet(new ulong[]{0xA000008000020000UL,0xFCUL});
		public static readonly BitSet _statement_in_if_stat450 = new BitSet(new ulong[]{0xA000008000020000UL,0xFCUL});
		public static readonly BitSet _senao_stat_in_if_stat458 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _63_in_if_stat486 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _70_in_senao_stat522 = new BitSet(new ulong[]{0xA000008000020000UL,0xBCUL});
		public static readonly BitSet _statement_in_senao_stat526 = new BitSet(new ulong[]{0xA000008000020000UL,0xBCUL});
		public static readonly BitSet _63_in_senao_stat529 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _66_in_for_stat549 = new BitSet(new ulong[]{0x20000UL});
		public static readonly BitSet _assign_var_in_for_stat551 = new BitSet(new ulong[]{0x400000000000000UL});
		public static readonly BitSet _58_in_for_stat553 = new BitSet(new ulong[]{0x220000UL});
		public static readonly BitSet _index_in_for_stat555 = new BitSet(new ulong[]{0xA800008000020000UL,0xBCUL});
		public static readonly BitSet _59_in_for_stat563 = new BitSet(new ulong[]{0xA000008000020000UL,0xBCUL});
		public static readonly BitSet _statement_in_for_stat565 = new BitSet(new ulong[]{0xA000008000020000UL,0xBCUL});
		public static readonly BitSet _63_in_for_stat568 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _statement_in_for_stat593 = new BitSet(new ulong[]{0xA000008000020000UL,0xBCUL});
		public static readonly BitSet _63_in_for_stat596 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _61_in_while_stat629 = new BitSet(new ulong[]{0x20200224000UL});
		public static readonly BitSet _logic_expression_in_while_stat631 = new BitSet(new ulong[]{0xA000008000020000UL,0xBCUL});
		public static readonly BitSet _statement_in_while_stat633 = new BitSet(new ulong[]{0xA000008000020000UL,0xBCUL});
		public static readonly BitSet _63_in_while_stat636 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _67_in_repeat_stat668 = new BitSet(new ulong[]{0x2400008000020000UL,0xBCUL});
		public static readonly BitSet _statement_in_repeat_stat670 = new BitSet(new ulong[]{0x2400008000020000UL,0xBCUL});
		public static readonly BitSet _58_in_repeat_stat673 = new BitSet(new ulong[]{0x20200224000UL});
		public static readonly BitSet _logic_expression_in_repeat_stat675 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_function_call723 = new BitSet(new ulong[]{0x20000000000UL});
		public static readonly BitSet _41_in_function_call725 = new BitSet(new ulong[]{0x60200224000UL});
		public static readonly BitSet _function_arg_list_in_function_call727 = new BitSet(new ulong[]{0x60200224000UL});
		public static readonly BitSet _42_in_function_call730 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_property_call771 = new BitSet(new ulong[]{0x800000000000UL});
		public static readonly BitSet _47_in_property_call772 = new BitSet(new ulong[]{0x20000UL});
		public static readonly BitSet _ID_in_property_call775 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_method_call819 = new BitSet(new ulong[]{0x800000000000UL});
		public static readonly BitSet _47_in_method_call820 = new BitSet(new ulong[]{0x20000UL});
		public static readonly BitSet _ID_in_method_call823 = new BitSet(new ulong[]{0x20000000000UL});
		public static readonly BitSet _41_in_method_call825 = new BitSet(new ulong[]{0x60200224000UL});
		public static readonly BitSet _function_arg_list_in_method_call827 = new BitSet(new ulong[]{0x60200224000UL});
		public static readonly BitSet _42_in_method_call830 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _plus_expression_in_function_arg_list875 = new BitSet(new ulong[]{0x200000000002UL});
		public static readonly BitSet _45_in_function_arg_list878 = new BitSet(new ulong[]{0x20200224000UL});
		public static readonly BitSet _plus_expression_in_function_arg_list880 = new BitSet(new ulong[]{0x200000000002UL});
		public static readonly BitSet _ID_in_assign_var932 = new BitSet(new ulong[]{0x10000000000000UL});
		public static readonly BitSet _52_in_assign_var934 = new BitSet(new ulong[]{0x100000000000000UL});
		public static readonly BitSet _56_in_assign_var936 = new BitSet(new ulong[]{0x200000UL});
		public static readonly BitSet _INT_in_assign_var938 = new BitSet(new ulong[]{0x1000000000000UL});
		public static readonly BitSet _48_in_assign_var940 = new BitSet(new ulong[]{0x200000UL});
		public static readonly BitSet _INT_in_assign_var942 = new BitSet(new ulong[]{0x200000000000000UL});
		public static readonly BitSet _57_in_assign_var944 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_assign_var967 = new BitSet(new ulong[]{0x10000000000000UL});
		public static readonly BitSet _52_in_assign_var969 = new BitSet(new ulong[]{0x0UL,0x100UL});
		public static readonly BitSet _72_in_assign_var971 = new BitSet(new ulong[]{0x200000UL});
		public static readonly BitSet _INT_in_assign_var973 = new BitSet(new ulong[]{0x200000000000UL,0x200UL});
		public static readonly BitSet _45_in_assign_var976 = new BitSet(new ulong[]{0x200000UL});
		public static readonly BitSet _INT_in_assign_var978 = new BitSet(new ulong[]{0x200000000000UL,0x200UL});
		public static readonly BitSet _73_in_assign_var982 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_assign_var1002 = new BitSet(new ulong[]{0x100000000000000UL});
		public static readonly BitSet _56_in_assign_var1004 = new BitSet(new ulong[]{0x220000UL});
		public static readonly BitSet _index_in_assign_var1006 = new BitSet(new ulong[]{0x200000000000000UL});
		public static readonly BitSet _57_in_assign_var1008 = new BitSet(new ulong[]{0x10000000000000UL});
		public static readonly BitSet _52_in_assign_var1010 = new BitSet(new ulong[]{0x20200224000UL});
		public static readonly BitSet _assign_expression_in_assign_var1012 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_assign_var1041 = new BitSet(new ulong[]{0x10000000000000UL});
		public static readonly BitSet _52_in_assign_var1043 = new BitSet(new ulong[]{0x20200224000UL});
		public static readonly BitSet _assign_expression_in_assign_var1045 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _68_in_return_stat1068 = new BitSet(new ulong[]{0x20200224000UL});
		public static readonly BitSet _assign_expression_in_return_stat1070 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _39_in_asm_code1089 = new BitSet(new ulong[]{0x8200000000UL});
		public static readonly BitSet _STRING_in_asm_code1091 = new BitSet(new ulong[]{0x8200000000UL});
		public static readonly BitSet _39_in_asm_code1094 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _plus_expression_in_logic_expression1126 = new BitSet(new ulong[]{0x10EC004000000002UL,0x2UL});
		public static readonly BitSet _binop_in_logic_expression1130 = new BitSet(new ulong[]{0x20200224000UL});
		public static readonly BitSet _plus_expression_in_logic_expression1133 = new BitSet(new ulong[]{0x10EC004000000002UL,0x2UL});
		public static readonly BitSet _plus_expression_in_assign_expression1194 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _mul_expression_in_plus_expression1204 = new BitSet(new ulong[]{0x500000000002UL});
		public static readonly BitSet _44_in_plus_expression1208 = new BitSet(new ulong[]{0x20200224000UL});
		public static readonly BitSet _mul_expression_in_plus_expression1211 = new BitSet(new ulong[]{0x500000000002UL});
		public static readonly BitSet _46_in_plus_expression1215 = new BitSet(new ulong[]{0x20200224000UL});
		public static readonly BitSet _mul_expression_in_plus_expression1218 = new BitSet(new ulong[]{0x500000000002UL});
		public static readonly BitSet _primary_ar_expression_in_mul_expression1233 = new BitSet(new ulong[]{0x2090000000002UL});
		public static readonly BitSet _49_in_mul_expression1238 = new BitSet(new ulong[]{0x20200224000UL});
		public static readonly BitSet _primary_ar_expression_in_mul_expression1241 = new BitSet(new ulong[]{0x2090000000002UL});
		public static readonly BitSet _40_in_mul_expression1245 = new BitSet(new ulong[]{0x20200224000UL});
		public static readonly BitSet _primary_ar_expression_in_mul_expression1248 = new BitSet(new ulong[]{0x2090000000002UL});
		public static readonly BitSet _43_in_mul_expression1252 = new BitSet(new ulong[]{0x20200224000UL});
		public static readonly BitSet _primary_ar_expression_in_mul_expression1255 = new BitSet(new ulong[]{0x2090000000002UL});
		public static readonly BitSet _function_call_in_primary_ar_expression1273 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_primary_ar_expression1278 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_primary_ar_expression1283 = new BitSet(new ulong[]{0x100000000000000UL});
		public static readonly BitSet _56_in_primary_ar_expression1285 = new BitSet(new ulong[]{0x220000UL});
		public static readonly BitSet _index_in_primary_ar_expression1287 = new BitSet(new ulong[]{0x200000000000000UL});
		public static readonly BitSet _57_in_primary_ar_expression1289 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _method_call_in_primary_ar_expression1304 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _property_call_in_primary_ar_expression1310 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _constant_in_primary_ar_expression1315 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _parenthesisExpression_in_primary_ar_expression1320 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _41_in_parenthesisExpression1335 = new BitSet(new ulong[]{0x20200224000UL});
		public static readonly BitSet _plus_expression_in_parenthesisExpression1337 = new BitSet(new ulong[]{0x40000000000UL});
		public static readonly BitSet _42_in_parenthesisExpression1339 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _constant_in_atom1370 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_atom1374 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _function_arg_list_in_synpred23_NPortugol727 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _function_arg_list_in_synpred24_NPortugol827 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_synpred26_NPortugol932 = new BitSet(new ulong[]{0x10000000000000UL});
		public static readonly BitSet _52_in_synpred26_NPortugol934 = new BitSet(new ulong[]{0x100000000000000UL});
		public static readonly BitSet _56_in_synpred26_NPortugol936 = new BitSet(new ulong[]{0x200000UL});
		public static readonly BitSet _INT_in_synpred26_NPortugol938 = new BitSet(new ulong[]{0x1000000000000UL});
		public static readonly BitSet _48_in_synpred26_NPortugol940 = new BitSet(new ulong[]{0x200000UL});
		public static readonly BitSet _INT_in_synpred26_NPortugol942 = new BitSet(new ulong[]{0x200000000000000UL});
		public static readonly BitSet _57_in_synpred26_NPortugol944 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_synpred28_NPortugol967 = new BitSet(new ulong[]{0x10000000000000UL});
		public static readonly BitSet _52_in_synpred28_NPortugol969 = new BitSet(new ulong[]{0x0UL,0x100UL});
		public static readonly BitSet _72_in_synpred28_NPortugol971 = new BitSet(new ulong[]{0x200000UL});
		public static readonly BitSet _INT_in_synpred28_NPortugol973 = new BitSet(new ulong[]{0x200000000000UL,0x200UL});
		public static readonly BitSet _45_in_synpred28_NPortugol976 = new BitSet(new ulong[]{0x200000UL});
		public static readonly BitSet _INT_in_synpred28_NPortugol978 = new BitSet(new ulong[]{0x200000000000UL,0x200UL});
		public static readonly BitSet _73_in_synpred28_NPortugol982 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _function_call_in_synpred44_NPortugol1273 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_synpred45_NPortugol1278 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _method_call_in_synpred47_NPortugol1304 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _property_call_in_synpred48_NPortugol1310 = new BitSet(new ulong[]{0x2UL});
	}
	#endregion Follow sets
}

} // namespace NPortugol2.Compiler
