//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.4
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.4 E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g 2012-10-13 17:57:58

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019

using System.Collections;

using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;


using Antlr.Runtime.Tree;
using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;

namespace NPortugol2.Compiler
{
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.4")]
[System.CLSCompliant(false)]
public partial class NPortugolParser : Antlr.Runtime.Parser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "AR", "ARG", "ASGN", "ASM", "CALL", "CHAR", "DEC", "ESC_SEQ", "EXP", "EXPONENT", "FLOAT", "FUNC", "HEX_DIGIT", "ID", "ILIST", "INDEX", "INIT", "INT", "JMP", "LEXP", "LOOP", "MCALL", "NEWLINE", "OCTAL_ESC", "PARAM", "PCALL", "RET", "SJMP", "SLIST", "STRING", "TYPE", "UNICODE_ESC", "VAR", "WS", "'!='", "'#'", "'%'", "'('", "')'", "'*'", "'+'", "','", "'-'", "'.'", "'..'", "'/'", "'<'", "'<='", "'='", "'=='", "'>'", "'>='", "'['", "']'", "'ate'", "'dec'", "'e'", "'enquanto'", "'entao'", "'fim'", "'funcao'", "'ou'", "'para'", "'repita'", "'retorne'", "'se'", "'senao'", "'variavel'", "'{'", "'}'"
	};
	public const int EOF=-1;
	public const int T__38=38;
	public const int T__39=39;
	public const int T__40=40;
	public const int T__41=41;
	public const int T__42=42;
	public const int T__43=43;
	public const int T__44=44;
	public const int T__45=45;
	public const int T__46=46;
	public const int T__47=47;
	public const int T__48=48;
	public const int T__49=49;
	public const int T__50=50;
	public const int T__51=51;
	public const int T__52=52;
	public const int T__53=53;
	public const int T__54=54;
	public const int T__55=55;
	public const int T__56=56;
	public const int T__57=57;
	public const int T__58=58;
	public const int T__59=59;
	public const int T__60=60;
	public const int T__61=61;
	public const int T__62=62;
	public const int T__63=63;
	public const int T__64=64;
	public const int T__65=65;
	public const int T__66=66;
	public const int T__67=67;
	public const int T__68=68;
	public const int T__69=69;
	public const int T__70=70;
	public const int T__71=71;
	public const int T__72=72;
	public const int T__73=73;
	public const int AR=4;
	public const int ARG=5;
	public const int ASGN=6;
	public const int ASM=7;
	public const int CALL=8;
	public const int CHAR=9;
	public const int DEC=10;
	public const int ESC_SEQ=11;
	public const int EXP=12;
	public const int EXPONENT=13;
	public const int FLOAT=14;
	public const int FUNC=15;
	public const int HEX_DIGIT=16;
	public const int ID=17;
	public const int ILIST=18;
	public const int INDEX=19;
	public const int INIT=20;
	public const int INT=21;
	public const int JMP=22;
	public const int LEXP=23;
	public const int LOOP=24;
	public const int MCALL=25;
	public const int NEWLINE=26;
	public const int OCTAL_ESC=27;
	public const int PARAM=28;
	public const int PCALL=29;
	public const int RET=30;
	public const int SJMP=31;
	public const int SLIST=32;
	public const int STRING=33;
	public const int TYPE=34;
	public const int UNICODE_ESC=35;
	public const int VAR=36;
	public const int WS=37;

	public NPortugolParser(ITokenStream input)
		: this(input, new RecognizerSharedState())
	{
	}
	public NPortugolParser(ITokenStream input, RecognizerSharedState state)
		: base(input, state)
	{
		ITreeAdaptor treeAdaptor = default(ITreeAdaptor);
		CreateTreeAdaptor(ref treeAdaptor);
		TreeAdaptor = treeAdaptor ?? new CommonTreeAdaptor();
		OnCreated();
	}
	// Implement this function in your helper file to use a custom tree adaptor
	partial void CreateTreeAdaptor(ref ITreeAdaptor adaptor);

	private ITreeAdaptor adaptor;

	public ITreeAdaptor TreeAdaptor
	{
		get
		{
			return adaptor;
		}

		set
		{
			this.adaptor = value;
		}
	}

	public override string[] TokenNames { get { return NPortugolParser.tokenNames; } }
	public override string GrammarFileName { get { return "E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g"; } }



		Stack<string> paraphrases = new Stack<string>();
		
	        public string GetErrorMessage(RecognitionException e)
	        {
	            string msg = "Erro na linha {0} posição {1}: '{2}'";
		    msg = string.Format(msg, e.Line, e.CharPositionInLine, e.Token.Text);
	            if (paraphrases.Count > 0){
	                string paraphrase = (string)paraphrases.Pop();
	                msg = msg + " " + paraphrase;
	            }
	            return msg;
	        }
		protected void mismatch(IIntStream input, int ttype, BitSet follow)	{
			throw new MismatchedTokenException(ttype, input);
		}
		public void recoverFromMismatchedSet(IIntStream input,RecognitionException e, BitSet follow) {
			throw e;
		}

		public List<string> Functions = new List<string>();
		public List<string> Symbols = new List<string>();	
		public bool IsDefinedID(string id){    return Symbols.Contains(id);}
		public bool IsDefined(string name) { return Functions.Contains(name); }
		public void DefineID(IList<IToken> ids){ foreach(var id in ids) { Symbols.Add(id.Text); }}
		public void DefineFunction(string name){ Functions.Add(name);}	


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	#region Rules
	partial void EnterRule_script();
	partial void LeaveRule_script();

	// $ANTLR start "script"
	// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:73:8: public script : ( declare_function )* ;
	[GrammarRule("script")]
	public AstParserRuleReturnScope<object, IToken> script()
	{
		EnterRule_script();
		EnterRule("script", 1);
		TraceIn("script", 1);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> declare_function1 = default(AstParserRuleReturnScope<object, IToken>);

		try { DebugEnterRule(GrammarFileName, "script");
		DebugLocation(73, 34);
		try
		{
			// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:73:15: ( ( declare_function )* )
			DebugEnterAlt(1);
			// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:73:17: ( declare_function )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(73, 17);
			// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:73:17: ( declare_function )*
			try { DebugEnterSubRule(1);
			while (true)
			{
				int alt1=2;
				try { DebugEnterDecision(1, false);
				int LA1_0 = input.LA(1);

				if ((LA1_0==64))
				{
					alt1 = 1;
				}


				} finally { DebugExitDecision(1); }
				switch ( alt1 )
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:73:17: declare_function
					{
					DebugLocation(73, 17);
					PushFollow(Follow._declare_function_in_script148);
					declare_function1=declare_function();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, declare_function1.Tree);

					}
					break;

				default:
					goto loop1;
				}
			}

			loop1:
				;

			} finally { DebugExitSubRule(1); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

			catch (RecognitionException e) {
				throw e;
			}

		finally
		{
			TraceOut("script", 1);
			LeaveRule("script", 1);
			LeaveRule_script();
		}
		DebugLocation(73, 34);
		} finally { DebugExitRule(GrammarFileName, "script"); }
		return retval;

	}
	// $ANTLR end "script"

	partial void EnterRule_declare_function();
	partial void LeaveRule_declare_function();

	// $ANTLR start "declare_function"
	// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:75:1: declare_function : 'funcao' (t= TYPE )? i= ID '(' ( function_param_list )* ')' ( statement )* 'fim' -> ^( FUNC ( TYPE )? ID ( function_param_list )* ^( SLIST ( statement )* ) ) ;
	[GrammarRule("declare_function")]
	private AstParserRuleReturnScope<object, IToken> declare_function()
	{
		EnterRule_declare_function();
		EnterRule("declare_function", 2);
		TraceIn("declare_function", 2);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken t = default(IToken);
		IToken i = default(IToken);
		IToken string_literal2 = default(IToken);
		IToken char_literal3 = default(IToken);
		IToken char_literal5 = default(IToken);
		IToken string_literal7 = default(IToken);
		AstParserRuleReturnScope<object, IToken> function_param_list4 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> statement6 = default(AstParserRuleReturnScope<object, IToken>);

		object t_tree = default(object);
		object i_tree = default(object);
		object string_literal2_tree = default(object);
		object char_literal3_tree = default(object);
		object char_literal5_tree = default(object);
		object string_literal7_tree = default(object);
		RewriteRuleITokenStream stream_42=new RewriteRuleITokenStream(adaptor,"token 42");
		RewriteRuleITokenStream stream_41=new RewriteRuleITokenStream(adaptor,"token 41");
		RewriteRuleITokenStream stream_64=new RewriteRuleITokenStream(adaptor,"token 64");
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleITokenStream stream_63=new RewriteRuleITokenStream(adaptor,"token 63");
		RewriteRuleITokenStream stream_TYPE=new RewriteRuleITokenStream(adaptor,"token TYPE");
		RewriteRuleSubtreeStream stream_statement=new RewriteRuleSubtreeStream(adaptor,"rule statement");
		RewriteRuleSubtreeStream stream_function_param_list=new RewriteRuleSubtreeStream(adaptor,"rule function_param_list");
		try { DebugEnterRule(GrammarFileName, "declare_function");
		DebugLocation(75, 1);
		try
		{
			// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:76:2: ( 'funcao' (t= TYPE )? i= ID '(' ( function_param_list )* ')' ( statement )* 'fim' -> ^( FUNC ( TYPE )? ID ( function_param_list )* ^( SLIST ( statement )* ) ) )
			DebugEnterAlt(1);
			// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:76:4: 'funcao' (t= TYPE )? i= ID '(' ( function_param_list )* ')' ( statement )* 'fim'
			{
			DebugLocation(76, 4);
			string_literal2=(IToken)Match(input,64,Follow._64_in_declare_function159); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_64.Add(string_literal2);

			DebugLocation(76, 14);
			// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:76:14: (t= TYPE )?
			int alt2=2;
			try { DebugEnterSubRule(2);
			try { DebugEnterDecision(2, false);
			int LA2_0 = input.LA(1);

			if ((LA2_0==TYPE))
			{
				alt2 = 1;
			}
			} finally { DebugExitDecision(2); }
			switch (alt2)
			{
			case 1:
				DebugEnterAlt(1);
				// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:76:14: t= TYPE
				{
				DebugLocation(76, 14);
				t=(IToken)Match(input,TYPE,Follow._TYPE_in_declare_function163); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_TYPE.Add(t);


				}
				break;

			}
			} finally { DebugExitSubRule(2); }

			DebugLocation(76, 22);
			i=(IToken)Match(input,ID,Follow._ID_in_declare_function168); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ID.Add(i);

			DebugLocation(76, 26);
			char_literal3=(IToken)Match(input,41,Follow._41_in_declare_function170); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_41.Add(char_literal3);

			DebugLocation(76, 30);
			// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:76:30: ( function_param_list )*
			try { DebugEnterSubRule(3);
			while (true)
			{
				int alt3=2;
				try { DebugEnterDecision(3, false);
				int LA3_0 = input.LA(1);

				if ((LA3_0==TYPE))
				{
					alt3 = 1;
				}


				} finally { DebugExitDecision(3); }
				switch ( alt3 )
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:76:30: function_param_list
					{
					DebugLocation(76, 30);
					PushFollow(Follow._function_param_list_in_declare_function172);
					function_param_list4=function_param_list();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_function_param_list.Add(function_param_list4.Tree);

					}
					break;

				default:
					goto loop3;
				}
			}

			loop3:
				;

			} finally { DebugExitSubRule(3); }

			DebugLocation(76, 51);
			char_literal5=(IToken)Match(input,42,Follow._42_in_declare_function175); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_42.Add(char_literal5);

			DebugLocation(76, 55);
			// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:76:55: ( statement )*
			try { DebugEnterSubRule(4);
			while (true)
			{
				int alt4=2;
				try { DebugEnterDecision(4, false);
				int LA4_0 = input.LA(1);

				if ((LA4_0==ID||LA4_0==39||LA4_0==61||(LA4_0>=66 && LA4_0<=69)||LA4_0==71))
				{
					alt4 = 1;
				}


				} finally { DebugExitDecision(4); }
				switch ( alt4 )
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:76:55: statement
					{
					DebugLocation(76, 55);
					PushFollow(Follow._statement_in_declare_function177);
					statement6=statement();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_statement.Add(statement6.Tree);

					}
					break;

				default:
					goto loop4;
				}
			}

			loop4:
				;

			} finally { DebugExitSubRule(4); }

			DebugLocation(76, 66);
			string_literal7=(IToken)Match(input,63,Follow._63_in_declare_function180); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_63.Add(string_literal7);

			DebugLocation(77, 3);
			if (state.backtracking == 0)
			{
				DefineFunction((i!=null?i.Text:null));
			}


			{
			// AST REWRITE
			// elements: TYPE, statement, function_param_list, ID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 78:3: -> ^( FUNC ( TYPE )? ID ( function_param_list )* ^( SLIST ( statement )* ) )
			{
				DebugLocation(78, 6);
				// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:78:6: ^( FUNC ( TYPE )? ID ( function_param_list )* ^( SLIST ( statement )* ) )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(78, 8);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(FUNC, "FUNC"), root_1);

				DebugLocation(78, 13);
				// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:78:13: ( TYPE )?
				if (stream_TYPE.HasNext)
				{
					DebugLocation(78, 13);
					adaptor.AddChild(root_1, stream_TYPE.NextNode());

				}
				stream_TYPE.Reset();
				DebugLocation(78, 19);
				adaptor.AddChild(root_1, stream_ID.NextNode());
				DebugLocation(78, 22);
				// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:78:22: ( function_param_list )*
				while ( stream_function_param_list.HasNext )
				{
					DebugLocation(78, 22);
					adaptor.AddChild(root_1, stream_function_param_list.NextTree());

				}
				stream_function_param_list.Reset();
				DebugLocation(78, 43);
				// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:78:43: ^( SLIST ( statement )* )
				{
				object root_2 = (object)adaptor.Nil();
				DebugLocation(78, 45);
				root_2 = (object)adaptor.BecomeRoot((object)adaptor.Create(SLIST, "SLIST"), root_2);

				DebugLocation(78, 51);
				// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:78:51: ( statement )*
				while ( stream_statement.HasNext )
				{
					DebugLocation(78, 51);
					adaptor.AddChild(root_2, stream_statement.NextTree());

				}
				stream_statement.Reset();

				adaptor.AddChild(root_1, root_2);
				}

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

			catch (RecognitionException e) {
				throw e;
			}

		finally
		{
			TraceOut("declare_function", 2);
			LeaveRule("declare_function", 2);
			LeaveRule_declare_function();
		}
		DebugLocation(79, 1);
		} finally { DebugExitRule(GrammarFileName, "declare_function"); }
		return retval;

	}
	// $ANTLR end "declare_function"

	partial void EnterRule_statement();
	partial void LeaveRule_statement();

	// $ANTLR start "statement"
	// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:81:1: statement : ( declare_local | if_stat | for_stat | while_stat | repeat_stat | function_call | assign_var | return_stat | asm_code );
	[GrammarRule("statement")]
	private AstParserRuleReturnScope<object, IToken> statement()
	{
		EnterRule_statement();
		EnterRule("statement", 3);
		TraceIn("statement", 3);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> declare_local8 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> if_stat9 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> for_stat10 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> while_stat11 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> repeat_stat12 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> function_call13 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> assign_var14 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> return_stat15 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> asm_code16 = default(AstParserRuleReturnScope<object, IToken>);

		 paraphrases.Push("na sentença"); 
		try { DebugEnterRule(GrammarFileName, "statement");
		DebugLocation(81, 1);
		try
		{
			// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:83:2: ( declare_local | if_stat | for_stat | while_stat | repeat_stat | function_call | assign_var | return_stat | asm_code )
			int alt5=9;
			try { DebugEnterDecision(5, false);
			switch (input.LA(1))
			{
			case 71:
				{
				alt5 = 1;
				}
				break;
			case 69:
				{
				alt5 = 2;
				}
				break;
			case 66:
				{
				alt5 = 3;
				}
				break;
			case 61:
				{
				alt5 = 4;
				}
				break;
			case 67:
				{
				alt5 = 5;
				}
				break;
			case ID:
				{
				int LA5_6 = input.LA(2);

				if ((LA5_6==41))
				{
					alt5 = 6;
				}
				else if ((LA5_6==52||LA5_6==56))
				{
					alt5 = 7;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 5, 6, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case 68:
				{
				alt5 = 8;
				}
				break;
			case 39:
				{
				alt5 = 9;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 5, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(5); }
			switch (alt5)
			{
			case 1:
				DebugEnterAlt(1);
				// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:83:4: declare_local
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(83, 4);
				PushFollow(Follow._declare_local_in_statement230);
				declare_local8=declare_local();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, declare_local8.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:84:4: if_stat
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(84, 4);
				PushFollow(Follow._if_stat_in_statement236);
				if_stat9=if_stat();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, if_stat9.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:85:4: for_stat
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(85, 4);
				PushFollow(Follow._for_stat_in_statement242);
				for_stat10=for_stat();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, for_stat10.Tree);

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:86:4: while_stat
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(86, 4);
				PushFollow(Follow._while_stat_in_statement247);
				while_stat11=while_stat();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, while_stat11.Tree);

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:87:4: repeat_stat
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(87, 4);
				PushFollow(Follow._repeat_stat_in_statement252);
				repeat_stat12=repeat_stat();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, repeat_stat12.Tree);

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:88:4: function_call
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(88, 4);
				PushFollow(Follow._function_call_in_statement258);
				function_call13=function_call();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, function_call13.Tree);

				}
				break;
			case 7:
				DebugEnterAlt(7);
				// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:89:4: assign_var
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(89, 4);
				PushFollow(Follow._assign_var_in_statement264);
				assign_var14=assign_var();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, assign_var14.Tree);

				}
				break;
			case 8:
				DebugEnterAlt(8);
				// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:90:4: return_stat
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(90, 4);
				PushFollow(Follow._return_stat_in_statement270);
				return_stat15=return_stat();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, return_stat15.Tree);

				}
				break;
			case 9:
				DebugEnterAlt(9);
				// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:91:4: asm_code
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(91, 4);
				PushFollow(Follow._asm_code_in_statement275);
				asm_code16=asm_code();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, asm_code16.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
			if (state.backtracking == 0)
			{
				 paraphrases.Pop(); 
			}
		}

			catch (RecognitionException e) {
				throw e;
			}

		finally
		{
			TraceOut("statement", 3);
			LeaveRule("statement", 3);
			LeaveRule_statement();
		}
		DebugLocation(92, 1);
		} finally { DebugExitRule(GrammarFileName, "statement"); }
		return retval;

	}
	// $ANTLR end "statement"

	partial void EnterRule_function_param_list();
	partial void LeaveRule_function_param_list();

	// $ANTLR start "function_param_list"
	// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:94:1: function_param_list : param ( ',' param )* -> ^( PARAM ( param )* ) ;
	[GrammarRule("function_param_list")]
	private AstParserRuleReturnScope<object, IToken> function_param_list()
	{
		EnterRule_function_param_list();
		EnterRule("function_param_list", 4);
		TraceIn("function_param_list", 4);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken char_literal18 = default(IToken);
		AstParserRuleReturnScope<object, IToken> param17 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> param19 = default(AstParserRuleReturnScope<object, IToken>);

		object char_literal18_tree = default(object);
		RewriteRuleITokenStream stream_45=new RewriteRuleITokenStream(adaptor,"token 45");
		RewriteRuleSubtreeStream stream_param=new RewriteRuleSubtreeStream(adaptor,"rule param");
		 paraphrases.Push("na lista de parâmetros"); 
		try { DebugEnterRule(GrammarFileName, "function_param_list");
		DebugLocation(94, 1);
		try
		{
			// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:95:2: ( param ( ',' param )* -> ^( PARAM ( param )* ) )
			DebugEnterAlt(1);
			// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:95:4: param ( ',' param )*
			{
			DebugLocation(95, 4);
			PushFollow(Follow._param_in_function_param_list303);
			param17=param();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_param.Add(param17.Tree);
			DebugLocation(95, 10);
			// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:95:10: ( ',' param )*
			try { DebugEnterSubRule(6);
			while (true)
			{
				int alt6=2;
				try { DebugEnterDecision(6, false);
				int LA6_0 = input.LA(1);

				if ((LA6_0==45))
				{
					alt6 = 1;
				}


				} finally { DebugExitDecision(6); }
				switch ( alt6 )
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:95:11: ',' param
					{
					DebugLocation(95, 11);
					char_literal18=(IToken)Match(input,45,Follow._45_in_function_param_list306); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_45.Add(char_literal18);

					DebugLocation(95, 15);
					PushFollow(Follow._param_in_function_param_list308);
					param19=param();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_param.Add(param19.Tree);

					}
					break;

				default:
					goto loop6;
				}
			}

			loop6:
				;

			} finally { DebugExitSubRule(6); }



			{
			// AST REWRITE
			// elements: param
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 95:23: -> ^( PARAM ( param )* )
			{
				DebugLocation(95, 26);
				// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:95:26: ^( PARAM ( param )* )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(95, 28);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(PARAM, "PARAM"), root_1);

				DebugLocation(95, 34);
				// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:95:34: ( param )*
				while ( stream_param.HasNext )
				{
					DebugLocation(95, 34);
					adaptor.AddChild(root_1, stream_param.NextTree());

				}
				stream_param.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
			if (state.backtracking == 0)
			{
				 paraphrases.Pop(); 
			}
		}

			catch (RecognitionException e) {
				throw e;
			}

		finally
		{
			TraceOut("function_param_list", 4);
			LeaveRule("function_param_list", 4);
			LeaveRule_function_param_list();
		}
		DebugLocation(96, 1);
		} finally { DebugExitRule(GrammarFileName, "function_param_list"); }
		return retval;

	}
	// $ANTLR end "function_param_list"

	partial void EnterRule_param();
	partial void LeaveRule_param();

	// $ANTLR start "param"
	// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:98:1: param : TYPE ID -> ^( TYPE ID ) ;
	[GrammarRule("param")]
	private AstParserRuleReturnScope<object, IToken> param()
	{
		EnterRule_param();
		EnterRule("param", 5);
		TraceIn("param", 5);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken TYPE20 = default(IToken);
		IToken ID21 = default(IToken);

		object TYPE20_tree = default(object);
		object ID21_tree = default(object);
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleITokenStream stream_TYPE=new RewriteRuleITokenStream(adaptor,"token TYPE");
		try { DebugEnterRule(GrammarFileName, "param");
		DebugLocation(98, 29);
		try
		{
			// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:98:7: ( TYPE ID -> ^( TYPE ID ) )
			DebugEnterAlt(1);
			// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:98:9: TYPE ID
			{
			DebugLocation(98, 9);
			TYPE20=(IToken)Match(input,TYPE,Follow._TYPE_in_param331); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_TYPE.Add(TYPE20);

			DebugLocation(98, 14);
			ID21=(IToken)Match(input,ID,Follow._ID_in_param333); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ID.Add(ID21);



			{
			// AST REWRITE
			// elements: TYPE, ID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 98:17: -> ^( TYPE ID )
			{
				DebugLocation(98, 20);
				// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:98:20: ^( TYPE ID )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(98, 22);
				root_1 = (object)adaptor.BecomeRoot(stream_TYPE.NextNode(), root_1);

				DebugLocation(98, 27);
				adaptor.AddChild(root_1, stream_ID.NextNode());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

			catch (RecognitionException e) {
				throw e;
			}

		finally
		{
			TraceOut("param", 5);
			LeaveRule("param", 5);
			LeaveRule_param();
		}
		DebugLocation(98, 29);
		} finally { DebugExitRule(GrammarFileName, "param"); }
		return retval;

	}
	// $ANTLR end "param"

	partial void EnterRule_declare_local();
	partial void LeaveRule_declare_local();

	// $ANTLR start "declare_local"
	// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:100:1: declare_local : 'variavel' i+= ID ( ',' i+= ID )* -> ^( VAR ( ID )* ) ;
	[GrammarRule("declare_local")]
	private AstParserRuleReturnScope<object, IToken> declare_local()
	{
		EnterRule_declare_local();
		EnterRule("declare_local", 6);
		TraceIn("declare_local", 6);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken string_literal22 = default(IToken);
		IToken char_literal23 = default(IToken);
		IToken i = default(IToken);
		List<IToken> list_i = null;

		object string_literal22_tree = default(object);
		object char_literal23_tree = default(object);
		object i_tree = default(object);
		RewriteRuleITokenStream stream_45=new RewriteRuleITokenStream(adaptor,"token 45");
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleITokenStream stream_71=new RewriteRuleITokenStream(adaptor,"token 71");
		 paraphrases.Push("na definição de variável"); 
		try { DebugEnterRule(GrammarFileName, "declare_local");
		DebugLocation(100, 1);
		try
		{
			// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:101:2: ( 'variavel' i+= ID ( ',' i+= ID )* -> ^( VAR ( ID )* ) )
			DebugEnterAlt(1);
			// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:101:4: 'variavel' i+= ID ( ',' i+= ID )*
			{
			DebugLocation(101, 4);
			string_literal22=(IToken)Match(input,71,Follow._71_in_declare_local373); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_71.Add(string_literal22);

			DebugLocation(101, 16);
			i=(IToken)Match(input,ID,Follow._ID_in_declare_local377); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ID.Add(i);

			if (list_i==null) list_i=new List<IToken>();
			list_i.Add(i);

			DebugLocation(101, 21);
			// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:101:21: ( ',' i+= ID )*
			try { DebugEnterSubRule(7);
			while (true)
			{
				int alt7=2;
				try { DebugEnterDecision(7, false);
				int LA7_0 = input.LA(1);

				if ((LA7_0==45))
				{
					alt7 = 1;
				}


				} finally { DebugExitDecision(7); }
				switch ( alt7 )
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:101:22: ',' i+= ID
					{
					DebugLocation(101, 22);
					char_literal23=(IToken)Match(input,45,Follow._45_in_declare_local380); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_45.Add(char_literal23);

					DebugLocation(101, 27);
					i=(IToken)Match(input,ID,Follow._ID_in_declare_local384); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_ID.Add(i);

					if (list_i==null) list_i=new List<IToken>();
					list_i.Add(i);


					}
					break;

				default:
					goto loop7;
				}
			}

			loop7:
				;

			} finally { DebugExitSubRule(7); }

			DebugLocation(102, 4);
			if (state.backtracking == 0)
			{
				DefineID(list_i);
			}


			{
			// AST REWRITE
			// elements: ID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 103:2: -> ^( VAR ( ID )* )
			{
				DebugLocation(103, 5);
				// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:103:5: ^( VAR ( ID )* )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(103, 7);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(VAR, "VAR"), root_1);

				DebugLocation(103, 11);
				// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:103:11: ( ID )*
				while ( stream_ID.HasNext )
				{
					DebugLocation(103, 11);
					adaptor.AddChild(root_1, stream_ID.NextNode());

				}
				stream_ID.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
			if (state.backtracking == 0)
			{
				 paraphrases.Pop(); 
			}
		}

			catch (RecognitionException e) {
				throw e;
			}

		finally
		{
			TraceOut("declare_local", 6);
			LeaveRule("declare_local", 6);
			LeaveRule_declare_local();
		}
		DebugLocation(104, 1);
		} finally { DebugExitRule(GrammarFileName, "declare_local"); }
		return retval;

	}
	// $ANTLR end "declare_local"

	partial void EnterRule_if_stat();
	partial void LeaveRule_if_stat();

	// $ANTLR start "if_stat"
	// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:106:1: if_stat : 'se' p= logic_expression 'entao' (s1+= statement )* (s2= senao_stat -> ^( SJMP ^( LEXP $p) ^( SLIST $s1 $s2) ) | 'fim' -> ^( JMP ^( LEXP $p) ^( SLIST ( $s1)* ) ) ) ;
	[GrammarRule("if_stat")]
	private AstParserRuleReturnScope<object, IToken> if_stat()
	{
		EnterRule_if_stat();
		EnterRule("if_stat", 7);
		TraceIn("if_stat", 7);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken string_literal24 = default(IToken);
		IToken string_literal25 = default(IToken);
		IToken string_literal26 = default(IToken);
		List<object> list_s1 = null;
		AstParserRuleReturnScope<object, IToken> p = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> s2 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> s1 = default(AstParserRuleReturnScope<object, IToken>);
		object string_literal24_tree = default(object);
		object string_literal25_tree = default(object);
		object string_literal26_tree = default(object);
		RewriteRuleITokenStream stream_69=new RewriteRuleITokenStream(adaptor,"token 69");
		RewriteRuleITokenStream stream_62=new RewriteRuleITokenStream(adaptor,"token 62");
		RewriteRuleITokenStream stream_63=new RewriteRuleITokenStream(adaptor,"token 63");
		RewriteRuleSubtreeStream stream_statement=new RewriteRuleSubtreeStream(adaptor,"rule statement");
		RewriteRuleSubtreeStream stream_logic_expression=new RewriteRuleSubtreeStream(adaptor,"rule logic_expression");
		RewriteRuleSubtreeStream stream_senao_stat=new RewriteRuleSubtreeStream(adaptor,"rule senao_stat");
		 paraphrases.Push("se"); 
		try { DebugEnterRule(GrammarFileName, "if_stat");
		DebugLocation(106, 1);
		try
		{
			// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:108:2: ( 'se' p= logic_expression 'entao' (s1+= statement )* (s2= senao_stat -> ^( SJMP ^( LEXP $p) ^( SLIST $s1 $s2) ) | 'fim' -> ^( JMP ^( LEXP $p) ^( SLIST ( $s1)* ) ) ) )
			DebugEnterAlt(1);
			// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:108:4: 'se' p= logic_expression 'entao' (s1+= statement )* (s2= senao_stat -> ^( SJMP ^( LEXP $p) ^( SLIST $s1 $s2) ) | 'fim' -> ^( JMP ^( LEXP $p) ^( SLIST ( $s1)* ) ) )
			{
			DebugLocation(108, 4);
			string_literal24=(IToken)Match(input,69,Follow._69_in_if_stat427); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_69.Add(string_literal24);

			DebugLocation(108, 10);
			PushFollow(Follow._logic_expression_in_if_stat431);
			p=logic_expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_logic_expression.Add(p.Tree);
			DebugLocation(108, 28);
			string_literal25=(IToken)Match(input,62,Follow._62_in_if_stat433); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_62.Add(string_literal25);

			DebugLocation(108, 38);
			// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:108:38: (s1+= statement )*
			try { DebugEnterSubRule(8);
			while (true)
			{
				int alt8=2;
				try { DebugEnterDecision(8, false);
				int LA8_0 = input.LA(1);

				if ((LA8_0==ID||LA8_0==39||LA8_0==61||(LA8_0>=66 && LA8_0<=69)||LA8_0==71))
				{
					alt8 = 1;
				}


				} finally { DebugExitDecision(8); }
				switch ( alt8 )
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:108:38: s1+= statement
					{
					DebugLocation(108, 38);
					PushFollow(Follow._statement_in_if_stat437);
					s1=statement();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_statement.Add(s1.Tree);
					if (list_s1==null) list_s1=new List<object>();
					list_s1.Add(s1.Tree);


					}
					break;

				default:
					goto loop8;
				}
			}

			loop8:
				;

			} finally { DebugExitSubRule(8); }

			DebugLocation(109, 2);
			// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:109:2: (s2= senao_stat -> ^( SJMP ^( LEXP $p) ^( SLIST $s1 $s2) ) | 'fim' -> ^( JMP ^( LEXP $p) ^( SLIST ( $s1)* ) ) )
			int alt9=2;
			try { DebugEnterSubRule(9);
			try { DebugEnterDecision(9, false);
			int LA9_0 = input.LA(1);

			if ((LA9_0==70))
			{
				alt9 = 1;
			}
			else if ((LA9_0==63))
			{
				alt9 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 9, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(9); }
			switch (alt9)
			{
			case 1:
				DebugEnterAlt(1);
				// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:109:4: s2= senao_stat
				{
				DebugLocation(109, 6);
				PushFollow(Follow._senao_stat_in_if_stat445);
				s2=senao_stat();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_senao_stat.Add(s2.Tree);


				{
				// AST REWRITE
				// elements: p, s2, s1
				// token labels: 
				// rule labels: retval, s2, p
				// token list labels: 
				// rule list labels: s1
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
				RewriteRuleSubtreeStream stream_s2=new RewriteRuleSubtreeStream(adaptor,"rule s2",s2!=null?s2.Tree:null);
				RewriteRuleSubtreeStream stream_p=new RewriteRuleSubtreeStream(adaptor,"rule p",p!=null?p.Tree:null);
				RewriteRuleSubtreeStream stream_s1=new RewriteRuleSubtreeStream(adaptor,"token s1",list_s1);
				root_0 = (object)adaptor.Nil();
				// 109:18: -> ^( SJMP ^( LEXP $p) ^( SLIST $s1 $s2) )
				{
					DebugLocation(109, 21);
					// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:109:21: ^( SJMP ^( LEXP $p) ^( SLIST $s1 $s2) )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(109, 23);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(SJMP, "SJMP"), root_1);

					DebugLocation(109, 28);
					// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:109:28: ^( LEXP $p)
					{
					object root_2 = (object)adaptor.Nil();
					DebugLocation(109, 30);
					root_2 = (object)adaptor.BecomeRoot((object)adaptor.Create(LEXP, "LEXP"), root_2);

					DebugLocation(109, 36);
					adaptor.AddChild(root_2, stream_p.NextTree());

					adaptor.AddChild(root_1, root_2);
					}
					DebugLocation(109, 39);
					// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:109:39: ^( SLIST $s1 $s2)
					{
					object root_2 = (object)adaptor.Nil();
					DebugLocation(109, 41);
					root_2 = (object)adaptor.BecomeRoot((object)adaptor.Create(SLIST, "SLIST"), root_2);

					DebugLocation(109, 48);
					adaptor.AddChild(root_2, stream_s1.NextTree());
					DebugLocation(109, 52);
					adaptor.AddChild(root_2, stream_s2.NextTree());

					adaptor.AddChild(root_1, root_2);
					}

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:110:4: 'fim'
				{
				DebugLocation(110, 4);
				string_literal26=(IToken)Match(input,63,Follow._63_in_if_stat473); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_63.Add(string_literal26);



				{
				// AST REWRITE
				// elements: p, s1
				// token labels: 
				// rule labels: retval, p
				// token list labels: 
				// rule list labels: s1
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
				RewriteRuleSubtreeStream stream_p=new RewriteRuleSubtreeStream(adaptor,"rule p",p!=null?p.Tree:null);
				RewriteRuleSubtreeStream stream_s1=new RewriteRuleSubtreeStream(adaptor,"token s1",list_s1);
				root_0 = (object)adaptor.Nil();
				// 110:10: -> ^( JMP ^( LEXP $p) ^( SLIST ( $s1)* ) )
				{
					DebugLocation(110, 13);
					// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:110:13: ^( JMP ^( LEXP $p) ^( SLIST ( $s1)* ) )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(110, 15);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(JMP, "JMP"), root_1);

					DebugLocation(110, 19);
					// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:110:19: ^( LEXP $p)
					{
					object root_2 = (object)adaptor.Nil();
					DebugLocation(110, 21);
					root_2 = (object)adaptor.BecomeRoot((object)adaptor.Create(LEXP, "LEXP"), root_2);

					DebugLocation(110, 27);
					adaptor.AddChild(root_2, stream_p.NextTree());

					adaptor.AddChild(root_1, root_2);
					}
					DebugLocation(110, 30);
					// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:110:30: ^( SLIST ( $s1)* )
					{
					object root_2 = (object)adaptor.Nil();
					DebugLocation(110, 32);
					root_2 = (object)adaptor.BecomeRoot((object)adaptor.Create(SLIST, "SLIST"), root_2);

					DebugLocation(110, 39);
					// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:110:39: ( $s1)*
					while ( stream_s1.HasNext )
					{
						DebugLocation(110, 39);
						adaptor.AddChild(root_2, stream_s1.NextTree());

					}
					stream_s1.Reset();

					adaptor.AddChild(root_1, root_2);
					}

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			} finally { DebugExitSubRule(9); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
			if (state.backtracking == 0)
			{
				 paraphrases.Pop(); 
			}
		}

			catch (RecognitionException e) {
				throw e;
			}

		finally
		{
			TraceOut("if_stat", 7);
			LeaveRule("if_stat", 7);
			LeaveRule_if_stat();
		}
		DebugLocation(112, 1);
		} finally { DebugExitRule(GrammarFileName, "if_stat"); }
		return retval;

	}
	// $ANTLR end "if_stat"

	partial void EnterRule_senao_stat();
	partial void LeaveRule_senao_stat();

	// $ANTLR start "senao_stat"
	// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:114:1: senao_stat : 'senao' (s2+= statement )* 'fim' -> ^( SLIST ( statement )* ) ;
	[GrammarRule("senao_stat")]
	private AstParserRuleReturnScope<object, IToken> senao_stat()
	{
		EnterRule_senao_stat();
		EnterRule("senao_stat", 8);
		TraceIn("senao_stat", 8);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken string_literal27 = default(IToken);
		IToken string_literal28 = default(IToken);
		List<object> list_s2 = null;
		AstParserRuleReturnScope<object, IToken> s2 = default(AstParserRuleReturnScope<object, IToken>);
		object string_literal27_tree = default(object);
		object string_literal28_tree = default(object);
		RewriteRuleITokenStream stream_70=new RewriteRuleITokenStream(adaptor,"token 70");
		RewriteRuleITokenStream stream_63=new RewriteRuleITokenStream(adaptor,"token 63");
		RewriteRuleSubtreeStream stream_statement=new RewriteRuleSubtreeStream(adaptor,"rule statement");
		try { DebugEnterRule(GrammarFileName, "senao_stat");
		DebugLocation(114, 1);
		try
		{
			// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:115:2: ( 'senao' (s2+= statement )* 'fim' -> ^( SLIST ( statement )* ) )
			DebugEnterAlt(1);
			// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:115:4: 'senao' (s2+= statement )* 'fim'
			{
			DebugLocation(115, 4);
			string_literal27=(IToken)Match(input,70,Follow._70_in_senao_stat509); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_70.Add(string_literal27);

			DebugLocation(115, 14);
			// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:115:14: (s2+= statement )*
			try { DebugEnterSubRule(10);
			while (true)
			{
				int alt10=2;
				try { DebugEnterDecision(10, false);
				int LA10_0 = input.LA(1);

				if ((LA10_0==ID||LA10_0==39||LA10_0==61||(LA10_0>=66 && LA10_0<=69)||LA10_0==71))
				{
					alt10 = 1;
				}


				} finally { DebugExitDecision(10); }
				switch ( alt10 )
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:115:14: s2+= statement
					{
					DebugLocation(115, 14);
					PushFollow(Follow._statement_in_senao_stat513);
					s2=statement();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_statement.Add(s2.Tree);
					if (list_s2==null) list_s2=new List<object>();
					list_s2.Add(s2.Tree);


					}
					break;

				default:
					goto loop10;
				}
			}

			loop10:
				;

			} finally { DebugExitSubRule(10); }

			DebugLocation(115, 27);
			string_literal28=(IToken)Match(input,63,Follow._63_in_senao_stat516); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_63.Add(string_literal28);



			{
			// AST REWRITE
			// elements: statement
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 115:33: -> ^( SLIST ( statement )* )
			{
				DebugLocation(115, 36);
				// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:115:36: ^( SLIST ( statement )* )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(115, 38);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(SLIST, "SLIST"), root_1);

				DebugLocation(115, 44);
				// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:115:44: ( statement )*
				while ( stream_statement.HasNext )
				{
					DebugLocation(115, 44);
					adaptor.AddChild(root_1, stream_statement.NextTree());

				}
				stream_statement.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

			catch (RecognitionException e) {
				throw e;
			}

		finally
		{
			TraceOut("senao_stat", 8);
			LeaveRule("senao_stat", 8);
			LeaveRule_senao_stat();
		}
		DebugLocation(116, 1);
		} finally { DebugExitRule(GrammarFileName, "senao_stat"); }
		return retval;

	}
	// $ANTLR end "senao_stat"

	partial void EnterRule_for_stat();
	partial void LeaveRule_for_stat();

	// $ANTLR start "for_stat"
	// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:118:1: for_stat : 'para' assign_var 'ate' index ( 'dec' ( statement )* 'fim' -> ^( LOOP DEC assign_var index ^( SLIST ( statement )* ) ) | ( statement )* 'fim' -> ^( LOOP assign_var index ^( SLIST ( statement )* ) ) ) ;
	[GrammarRule("for_stat")]
	private AstParserRuleReturnScope<object, IToken> for_stat()
	{
		EnterRule_for_stat();
		EnterRule("for_stat", 9);
		TraceIn("for_stat", 9);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken string_literal29 = default(IToken);
		IToken string_literal31 = default(IToken);
		IToken string_literal33 = default(IToken);
		IToken string_literal35 = default(IToken);
		IToken string_literal37 = default(IToken);
		AstParserRuleReturnScope<object, IToken> assign_var30 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> index32 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> statement34 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> statement36 = default(AstParserRuleReturnScope<object, IToken>);

		object string_literal29_tree = default(object);
		object string_literal31_tree = default(object);
		object string_literal33_tree = default(object);
		object string_literal35_tree = default(object);
		object string_literal37_tree = default(object);
		RewriteRuleITokenStream stream_66=new RewriteRuleITokenStream(adaptor,"token 66");
		RewriteRuleITokenStream stream_59=new RewriteRuleITokenStream(adaptor,"token 59");
		RewriteRuleITokenStream stream_58=new RewriteRuleITokenStream(adaptor,"token 58");
		RewriteRuleITokenStream stream_63=new RewriteRuleITokenStream(adaptor,"token 63");
		RewriteRuleSubtreeStream stream_statement=new RewriteRuleSubtreeStream(adaptor,"rule statement");
		RewriteRuleSubtreeStream stream_index=new RewriteRuleSubtreeStream(adaptor,"rule index");
		RewriteRuleSubtreeStream stream_assign_var=new RewriteRuleSubtreeStream(adaptor,"rule assign_var");
		try { DebugEnterRule(GrammarFileName, "for_stat");
		DebugLocation(118, 1);
		try
		{
			// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:118:9: ( 'para' assign_var 'ate' index ( 'dec' ( statement )* 'fim' -> ^( LOOP DEC assign_var index ^( SLIST ( statement )* ) ) | ( statement )* 'fim' -> ^( LOOP assign_var index ^( SLIST ( statement )* ) ) ) )
			DebugEnterAlt(1);
			// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:118:11: 'para' assign_var 'ate' index ( 'dec' ( statement )* 'fim' -> ^( LOOP DEC assign_var index ^( SLIST ( statement )* ) ) | ( statement )* 'fim' -> ^( LOOP assign_var index ^( SLIST ( statement )* ) ) )
			{
			DebugLocation(118, 11);
			string_literal29=(IToken)Match(input,66,Follow._66_in_for_stat536); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_66.Add(string_literal29);

			DebugLocation(118, 18);
			PushFollow(Follow._assign_var_in_for_stat538);
			assign_var30=assign_var();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_assign_var.Add(assign_var30.Tree);
			DebugLocation(118, 29);
			string_literal31=(IToken)Match(input,58,Follow._58_in_for_stat540); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_58.Add(string_literal31);

			DebugLocation(118, 35);
			PushFollow(Follow._index_in_for_stat542);
			index32=index();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_index.Add(index32.Tree);
			DebugLocation(120, 3);
			// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:120:3: ( 'dec' ( statement )* 'fim' -> ^( LOOP DEC assign_var index ^( SLIST ( statement )* ) ) | ( statement )* 'fim' -> ^( LOOP assign_var index ^( SLIST ( statement )* ) ) )
			int alt13=2;
			try { DebugEnterSubRule(13);
			try { DebugEnterDecision(13, false);
			int LA13_0 = input.LA(1);

			if ((LA13_0==59))
			{
				alt13 = 1;
			}
			else if ((LA13_0==ID||LA13_0==39||LA13_0==61||LA13_0==63||(LA13_0>=66 && LA13_0<=69)||LA13_0==71))
			{
				alt13 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 13, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(13); }
			switch (alt13)
			{
			case 1:
				DebugEnterAlt(1);
				// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:120:5: 'dec' ( statement )* 'fim'
				{
				DebugLocation(120, 5);
				string_literal33=(IToken)Match(input,59,Follow._59_in_for_stat550); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_59.Add(string_literal33);

				DebugLocation(120, 11);
				// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:120:11: ( statement )*
				try { DebugEnterSubRule(11);
				while (true)
				{
					int alt11=2;
					try { DebugEnterDecision(11, false);
					int LA11_0 = input.LA(1);

					if ((LA11_0==ID||LA11_0==39||LA11_0==61||(LA11_0>=66 && LA11_0<=69)||LA11_0==71))
					{
						alt11 = 1;
					}


					} finally { DebugExitDecision(11); }
					switch ( alt11 )
					{
					case 1:
						DebugEnterAlt(1);
						// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:120:11: statement
						{
						DebugLocation(120, 11);
						PushFollow(Follow._statement_in_for_stat552);
						statement34=statement();
						PopFollow();
						if (state.failed) return retval;
						if (state.backtracking == 0) stream_statement.Add(statement34.Tree);

						}
						break;

					default:
						goto loop11;
					}
				}

				loop11:
					;

				} finally { DebugExitSubRule(11); }

				DebugLocation(120, 22);
				string_literal35=(IToken)Match(input,63,Follow._63_in_for_stat555); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_63.Add(string_literal35);



				{
				// AST REWRITE
				// elements: index, assign_var, statement
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 120:28: -> ^( LOOP DEC assign_var index ^( SLIST ( statement )* ) )
				{
					DebugLocation(120, 31);
					// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:120:31: ^( LOOP DEC assign_var index ^( SLIST ( statement )* ) )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(120, 33);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(LOOP, "LOOP"), root_1);

					DebugLocation(120, 38);
					adaptor.AddChild(root_1, (object)adaptor.Create(DEC, "DEC"));
					DebugLocation(120, 42);
					adaptor.AddChild(root_1, stream_assign_var.NextTree());
					DebugLocation(120, 53);
					adaptor.AddChild(root_1, stream_index.NextTree());
					DebugLocation(120, 59);
					// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:120:59: ^( SLIST ( statement )* )
					{
					object root_2 = (object)adaptor.Nil();
					DebugLocation(120, 61);
					root_2 = (object)adaptor.BecomeRoot((object)adaptor.Create(SLIST, "SLIST"), root_2);

					DebugLocation(120, 67);
					// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:120:67: ( statement )*
					while ( stream_statement.HasNext )
					{
						DebugLocation(120, 67);
						adaptor.AddChild(root_2, stream_statement.NextTree());

					}
					stream_statement.Reset();

					adaptor.AddChild(root_1, root_2);
					}

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:121:5: ( statement )* 'fim'
				{
				DebugLocation(121, 5);
				// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:121:5: ( statement )*
				try { DebugEnterSubRule(12);
				while (true)
				{
					int alt12=2;
					try { DebugEnterDecision(12, false);
					int LA12_0 = input.LA(1);

					if ((LA12_0==ID||LA12_0==39||LA12_0==61||(LA12_0>=66 && LA12_0<=69)||LA12_0==71))
					{
						alt12 = 1;
					}


					} finally { DebugExitDecision(12); }
					switch ( alt12 )
					{
					case 1:
						DebugEnterAlt(1);
						// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:121:5: statement
						{
						DebugLocation(121, 5);
						PushFollow(Follow._statement_in_for_stat580);
						statement36=statement();
						PopFollow();
						if (state.failed) return retval;
						if (state.backtracking == 0) stream_statement.Add(statement36.Tree);

						}
						break;

					default:
						goto loop12;
					}
				}

				loop12:
					;

				} finally { DebugExitSubRule(12); }

				DebugLocation(121, 16);
				string_literal37=(IToken)Match(input,63,Follow._63_in_for_stat583); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_63.Add(string_literal37);



				{
				// AST REWRITE
				// elements: statement, index, assign_var
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 121:22: -> ^( LOOP assign_var index ^( SLIST ( statement )* ) )
				{
					DebugLocation(121, 25);
					// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:121:25: ^( LOOP assign_var index ^( SLIST ( statement )* ) )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(121, 27);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(LOOP, "LOOP"), root_1);

					DebugLocation(121, 32);
					adaptor.AddChild(root_1, stream_assign_var.NextTree());
					DebugLocation(121, 43);
					adaptor.AddChild(root_1, stream_index.NextTree());
					DebugLocation(121, 49);
					// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:121:49: ^( SLIST ( statement )* )
					{
					object root_2 = (object)adaptor.Nil();
					DebugLocation(121, 51);
					root_2 = (object)adaptor.BecomeRoot((object)adaptor.Create(SLIST, "SLIST"), root_2);

					DebugLocation(121, 57);
					// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:121:57: ( statement )*
					while ( stream_statement.HasNext )
					{
						DebugLocation(121, 57);
						adaptor.AddChild(root_2, stream_statement.NextTree());

					}
					stream_statement.Reset();

					adaptor.AddChild(root_1, root_2);
					}

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			} finally { DebugExitSubRule(13); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

			catch (RecognitionException e) {
				throw e;
			}

		finally
		{
			TraceOut("for_stat", 9);
			LeaveRule("for_stat", 9);
			LeaveRule_for_stat();
		}
		DebugLocation(123, 1);
		} finally { DebugExitRule(GrammarFileName, "for_stat"); }
		return retval;

	}
	// $ANTLR end "for_stat"

	partial void EnterRule_while_stat();
	partial void LeaveRule_while_stat();

	// $ANTLR start "while_stat"
	// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:125:1: while_stat : 'enquanto' logic_expression ( statement )* 'fim' -> ^( LOOP ^( LEXP logic_expression ) ^( SLIST ( statement )* ) ) ;
	[GrammarRule("while_stat")]
	private AstParserRuleReturnScope<object, IToken> while_stat()
	{
		EnterRule_while_stat();
		EnterRule("while_stat", 10);
		TraceIn("while_stat", 10);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken string_literal38 = default(IToken);
		IToken string_literal41 = default(IToken);
		AstParserRuleReturnScope<object, IToken> logic_expression39 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> statement40 = default(AstParserRuleReturnScope<object, IToken>);

		object string_literal38_tree = default(object);
		object string_literal41_tree = default(object);
		RewriteRuleITokenStream stream_63=new RewriteRuleITokenStream(adaptor,"token 63");
		RewriteRuleITokenStream stream_61=new RewriteRuleITokenStream(adaptor,"token 61");
		RewriteRuleSubtreeStream stream_statement=new RewriteRuleSubtreeStream(adaptor,"rule statement");
		RewriteRuleSubtreeStream stream_logic_expression=new RewriteRuleSubtreeStream(adaptor,"rule logic_expression");
		try { DebugEnterRule(GrammarFileName, "while_stat");
		DebugLocation(125, 1);
		try
		{
			// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:126:2: ( 'enquanto' logic_expression ( statement )* 'fim' -> ^( LOOP ^( LEXP logic_expression ) ^( SLIST ( statement )* ) ) )
			DebugEnterAlt(1);
			// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:126:4: 'enquanto' logic_expression ( statement )* 'fim'
			{
			DebugLocation(126, 4);
			string_literal38=(IToken)Match(input,61,Follow._61_in_while_stat616); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_61.Add(string_literal38);

			DebugLocation(126, 15);
			PushFollow(Follow._logic_expression_in_while_stat618);
			logic_expression39=logic_expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_logic_expression.Add(logic_expression39.Tree);
			DebugLocation(126, 32);
			// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:126:32: ( statement )*
			try { DebugEnterSubRule(14);
			while (true)
			{
				int alt14=2;
				try { DebugEnterDecision(14, false);
				int LA14_0 = input.LA(1);

				if ((LA14_0==ID||LA14_0==39||LA14_0==61||(LA14_0>=66 && LA14_0<=69)||LA14_0==71))
				{
					alt14 = 1;
				}


				} finally { DebugExitDecision(14); }
				switch ( alt14 )
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:126:32: statement
					{
					DebugLocation(126, 32);
					PushFollow(Follow._statement_in_while_stat620);
					statement40=statement();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_statement.Add(statement40.Tree);

					}
					break;

				default:
					goto loop14;
				}
			}

			loop14:
				;

			} finally { DebugExitSubRule(14); }

			DebugLocation(126, 43);
			string_literal41=(IToken)Match(input,63,Follow._63_in_while_stat623); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_63.Add(string_literal41);



			{
			// AST REWRITE
			// elements: statement, logic_expression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 127:3: -> ^( LOOP ^( LEXP logic_expression ) ^( SLIST ( statement )* ) )
			{
				DebugLocation(127, 6);
				// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:127:6: ^( LOOP ^( LEXP logic_expression ) ^( SLIST ( statement )* ) )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(127, 8);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(LOOP, "LOOP"), root_1);

				DebugLocation(127, 13);
				// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:127:13: ^( LEXP logic_expression )
				{
				object root_2 = (object)adaptor.Nil();
				DebugLocation(127, 15);
				root_2 = (object)adaptor.BecomeRoot((object)adaptor.Create(LEXP, "LEXP"), root_2);

				DebugLocation(127, 20);
				adaptor.AddChild(root_2, stream_logic_expression.NextTree());

				adaptor.AddChild(root_1, root_2);
				}
				DebugLocation(127, 38);
				// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:127:38: ^( SLIST ( statement )* )
				{
				object root_2 = (object)adaptor.Nil();
				DebugLocation(127, 40);
				root_2 = (object)adaptor.BecomeRoot((object)adaptor.Create(SLIST, "SLIST"), root_2);

				DebugLocation(127, 46);
				// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:127:46: ( statement )*
				while ( stream_statement.HasNext )
				{
					DebugLocation(127, 46);
					adaptor.AddChild(root_2, stream_statement.NextTree());

				}
				stream_statement.Reset();

				adaptor.AddChild(root_1, root_2);
				}

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

			catch (RecognitionException e) {
				throw e;
			}

		finally
		{
			TraceOut("while_stat", 10);
			LeaveRule("while_stat", 10);
			LeaveRule_while_stat();
		}
		DebugLocation(128, 1);
		} finally { DebugExitRule(GrammarFileName, "while_stat"); }
		return retval;

	}
	// $ANTLR end "while_stat"

	partial void EnterRule_repeat_stat();
	partial void LeaveRule_repeat_stat();

	// $ANTLR start "repeat_stat"
	// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:130:1: repeat_stat : 'repita' ( statement )* 'ate' logic_expression -> ^( LOOP ^( SLIST ( statement )* ) ^( LEXP logic_expression ) ) ;
	[GrammarRule("repeat_stat")]
	private AstParserRuleReturnScope<object, IToken> repeat_stat()
	{
		EnterRule_repeat_stat();
		EnterRule("repeat_stat", 11);
		TraceIn("repeat_stat", 11);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken string_literal42 = default(IToken);
		IToken string_literal44 = default(IToken);
		AstParserRuleReturnScope<object, IToken> statement43 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> logic_expression45 = default(AstParserRuleReturnScope<object, IToken>);

		object string_literal42_tree = default(object);
		object string_literal44_tree = default(object);
		RewriteRuleITokenStream stream_67=new RewriteRuleITokenStream(adaptor,"token 67");
		RewriteRuleITokenStream stream_58=new RewriteRuleITokenStream(adaptor,"token 58");
		RewriteRuleSubtreeStream stream_statement=new RewriteRuleSubtreeStream(adaptor,"rule statement");
		RewriteRuleSubtreeStream stream_logic_expression=new RewriteRuleSubtreeStream(adaptor,"rule logic_expression");
		try { DebugEnterRule(GrammarFileName, "repeat_stat");
		DebugLocation(130, 1);
		try
		{
			// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:130:13: ( 'repita' ( statement )* 'ate' logic_expression -> ^( LOOP ^( SLIST ( statement )* ) ^( LEXP logic_expression ) ) )
			DebugEnterAlt(1);
			// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:130:15: 'repita' ( statement )* 'ate' logic_expression
			{
			DebugLocation(130, 15);
			string_literal42=(IToken)Match(input,67,Follow._67_in_repeat_stat655); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_67.Add(string_literal42);

			DebugLocation(130, 24);
			// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:130:24: ( statement )*
			try { DebugEnterSubRule(15);
			while (true)
			{
				int alt15=2;
				try { DebugEnterDecision(15, false);
				int LA15_0 = input.LA(1);

				if ((LA15_0==ID||LA15_0==39||LA15_0==61||(LA15_0>=66 && LA15_0<=69)||LA15_0==71))
				{
					alt15 = 1;
				}


				} finally { DebugExitDecision(15); }
				switch ( alt15 )
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:130:24: statement
					{
					DebugLocation(130, 24);
					PushFollow(Follow._statement_in_repeat_stat657);
					statement43=statement();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_statement.Add(statement43.Tree);

					}
					break;

				default:
					goto loop15;
				}
			}

			loop15:
				;

			} finally { DebugExitSubRule(15); }

			DebugLocation(130, 35);
			string_literal44=(IToken)Match(input,58,Follow._58_in_repeat_stat660); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_58.Add(string_literal44);

			DebugLocation(130, 41);
			PushFollow(Follow._logic_expression_in_repeat_stat662);
			logic_expression45=logic_expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_logic_expression.Add(logic_expression45.Tree);


			{
			// AST REWRITE
			// elements: statement, logic_expression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 131:3: -> ^( LOOP ^( SLIST ( statement )* ) ^( LEXP logic_expression ) )
			{
				DebugLocation(131, 6);
				// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:131:6: ^( LOOP ^( SLIST ( statement )* ) ^( LEXP logic_expression ) )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(131, 8);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(LOOP, "LOOP"), root_1);

				DebugLocation(131, 13);
				// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:131:13: ^( SLIST ( statement )* )
				{
				object root_2 = (object)adaptor.Nil();
				DebugLocation(131, 15);
				root_2 = (object)adaptor.BecomeRoot((object)adaptor.Create(SLIST, "SLIST"), root_2);

				DebugLocation(131, 21);
				// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:131:21: ( statement )*
				while ( stream_statement.HasNext )
				{
					DebugLocation(131, 21);
					adaptor.AddChild(root_2, stream_statement.NextTree());

				}
				stream_statement.Reset();

				adaptor.AddChild(root_1, root_2);
				}
				DebugLocation(131, 33);
				// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:131:33: ^( LEXP logic_expression )
				{
				object root_2 = (object)adaptor.Nil();
				DebugLocation(131, 35);
				root_2 = (object)adaptor.BecomeRoot((object)adaptor.Create(LEXP, "LEXP"), root_2);

				DebugLocation(131, 40);
				adaptor.AddChild(root_2, stream_logic_expression.NextTree());

				adaptor.AddChild(root_1, root_2);
				}

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

			catch (RecognitionException e) {
				throw e;
			}

		finally
		{
			TraceOut("repeat_stat", 11);
			LeaveRule("repeat_stat", 11);
			LeaveRule_repeat_stat();
		}
		DebugLocation(132, 1);
		} finally { DebugExitRule(GrammarFileName, "repeat_stat"); }
		return retval;

	}
	// $ANTLR end "repeat_stat"

	partial void EnterRule_function_call();
	partial void LeaveRule_function_call();

	// $ANTLR start "function_call"
	// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:134:1: function_call : ID '(' ( function_arg_list )* ')' -> ^( CALL ID ( function_arg_list )* ) ;
	[GrammarRule("function_call")]
	private AstParserRuleReturnScope<object, IToken> function_call()
	{
		EnterRule_function_call();
		EnterRule("function_call", 12);
		TraceIn("function_call", 12);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken ID46 = default(IToken);
		IToken char_literal47 = default(IToken);
		IToken char_literal49 = default(IToken);
		AstParserRuleReturnScope<object, IToken> function_arg_list48 = default(AstParserRuleReturnScope<object, IToken>);

		object ID46_tree = default(object);
		object char_literal47_tree = default(object);
		object char_literal49_tree = default(object);
		RewriteRuleITokenStream stream_42=new RewriteRuleITokenStream(adaptor,"token 42");
		RewriteRuleITokenStream stream_41=new RewriteRuleITokenStream(adaptor,"token 41");
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleSubtreeStream stream_function_arg_list=new RewriteRuleSubtreeStream(adaptor,"rule function_arg_list");
		 paraphrases.Push("na chamada de função"); 
		try { DebugEnterRule(GrammarFileName, "function_call");
		DebugLocation(134, 1);
		try
		{
			// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:135:2: ( ID '(' ( function_arg_list )* ')' -> ^( CALL ID ( function_arg_list )* ) )
			DebugEnterAlt(1);
			// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:135:4: ID '(' ( function_arg_list )* ')'
			{
			DebugLocation(135, 4);
			ID46=(IToken)Match(input,ID,Follow._ID_in_function_call710); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ID.Add(ID46);

			DebugLocation(135, 7);
			char_literal47=(IToken)Match(input,41,Follow._41_in_function_call712); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_41.Add(char_literal47);

			DebugLocation(135, 11);
			// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:135:11: ( function_arg_list )*
			try { DebugEnterSubRule(16);
			while (true)
			{
				int alt16=2;
				try { DebugEnterDecision(16, false);
				int LA16_0 = input.LA(1);

				if ((LA16_0==FLOAT||LA16_0==ID||LA16_0==INT||LA16_0==STRING||LA16_0==41))
				{
					alt16 = 1;
				}


				} finally { DebugExitDecision(16); }
				switch ( alt16 )
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:135:11: function_arg_list
					{
					DebugLocation(135, 11);
					PushFollow(Follow._function_arg_list_in_function_call714);
					function_arg_list48=function_arg_list();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_function_arg_list.Add(function_arg_list48.Tree);

					}
					break;

				default:
					goto loop16;
				}
			}

			loop16:
				;

			} finally { DebugExitSubRule(16); }

			DebugLocation(135, 30);
			char_literal49=(IToken)Match(input,42,Follow._42_in_function_call717); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_42.Add(char_literal49);



			{
			// AST REWRITE
			// elements: ID, function_arg_list
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 135:34: -> ^( CALL ID ( function_arg_list )* )
			{
				DebugLocation(135, 37);
				// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:135:37: ^( CALL ID ( function_arg_list )* )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(135, 39);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(CALL, "CALL"), root_1);

				DebugLocation(135, 44);
				adaptor.AddChild(root_1, stream_ID.NextNode());
				DebugLocation(135, 47);
				// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:135:47: ( function_arg_list )*
				while ( stream_function_arg_list.HasNext )
				{
					DebugLocation(135, 47);
					adaptor.AddChild(root_1, stream_function_arg_list.NextTree());

				}
				stream_function_arg_list.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
			if (state.backtracking == 0)
			{
				 paraphrases.Pop(); 
			}
		}

			catch (RecognitionException e) {
				throw e;
			}

		finally
		{
			TraceOut("function_call", 12);
			LeaveRule("function_call", 12);
			LeaveRule_function_call();
		}
		DebugLocation(136, 1);
		} finally { DebugExitRule(GrammarFileName, "function_call"); }
		return retval;

	}
	// $ANTLR end "function_call"

	partial void EnterRule_property_call();
	partial void LeaveRule_property_call();

	// $ANTLR start "property_call"
	// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:138:1: property_call : o= ID '.' p= ID -> ^( PCALL $o $p) ;
	[GrammarRule("property_call")]
	private AstParserRuleReturnScope<object, IToken> property_call()
	{
		EnterRule_property_call();
		EnterRule("property_call", 13);
		TraceIn("property_call", 13);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken o = default(IToken);
		IToken p = default(IToken);
		IToken char_literal50 = default(IToken);

		object o_tree = default(object);
		object p_tree = default(object);
		object char_literal50_tree = default(object);
		RewriteRuleITokenStream stream_47=new RewriteRuleITokenStream(adaptor,"token 47");
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		 paraphrases.Push("na chamada de propriedade"); 
		try { DebugEnterRule(GrammarFileName, "property_call");
		DebugLocation(138, 1);
		try
		{
			// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:139:2: (o= ID '.' p= ID -> ^( PCALL $o $p) )
			DebugEnterAlt(1);
			// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:139:4: o= ID '.' p= ID
			{
			DebugLocation(139, 5);
			o=(IToken)Match(input,ID,Follow._ID_in_property_call758); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ID.Add(o);

			DebugLocation(139, 8);
			char_literal50=(IToken)Match(input,47,Follow._47_in_property_call759); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_47.Add(char_literal50);

			DebugLocation(139, 12);
			p=(IToken)Match(input,ID,Follow._ID_in_property_call762); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ID.Add(p);



			{
			// AST REWRITE
			// elements: o, p
			// token labels: p, o
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleITokenStream stream_p=new RewriteRuleITokenStream(adaptor,"token p",p);
			RewriteRuleITokenStream stream_o=new RewriteRuleITokenStream(adaptor,"token o",o);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 139:17: -> ^( PCALL $o $p)
			{
				DebugLocation(139, 20);
				// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:139:20: ^( PCALL $o $p)
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(139, 22);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(PCALL, "PCALL"), root_1);

				DebugLocation(139, 29);
				adaptor.AddChild(root_1, stream_o.NextNode());
				DebugLocation(139, 32);
				adaptor.AddChild(root_1, stream_p.NextNode());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
			if (state.backtracking == 0)
			{
				 paraphrases.Pop(); 
			}
		}

			catch (RecognitionException e) {
				throw e;
			}

		finally
		{
			TraceOut("property_call", 13);
			LeaveRule("property_call", 13);
			LeaveRule_property_call();
		}
		DebugLocation(140, 1);
		} finally { DebugExitRule(GrammarFileName, "property_call"); }
		return retval;

	}
	// $ANTLR end "property_call"

	partial void EnterRule_method_call();
	partial void LeaveRule_method_call();

	// $ANTLR start "method_call"
	// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:142:1: method_call : o= ID '.' p= ID '(' ( function_arg_list )* ')' -> ^( MCALL $o $p ( function_arg_list )* ) ;
	[GrammarRule("method_call")]
	private AstParserRuleReturnScope<object, IToken> method_call()
	{
		EnterRule_method_call();
		EnterRule("method_call", 14);
		TraceIn("method_call", 14);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken o = default(IToken);
		IToken p = default(IToken);
		IToken char_literal51 = default(IToken);
		IToken char_literal52 = default(IToken);
		IToken char_literal54 = default(IToken);
		AstParserRuleReturnScope<object, IToken> function_arg_list53 = default(AstParserRuleReturnScope<object, IToken>);

		object o_tree = default(object);
		object p_tree = default(object);
		object char_literal51_tree = default(object);
		object char_literal52_tree = default(object);
		object char_literal54_tree = default(object);
		RewriteRuleITokenStream stream_42=new RewriteRuleITokenStream(adaptor,"token 42");
		RewriteRuleITokenStream stream_47=new RewriteRuleITokenStream(adaptor,"token 47");
		RewriteRuleITokenStream stream_41=new RewriteRuleITokenStream(adaptor,"token 41");
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleSubtreeStream stream_function_arg_list=new RewriteRuleSubtreeStream(adaptor,"rule function_arg_list");
		 paraphrases.Push("na chamada de propriedade"); 
		try { DebugEnterRule(GrammarFileName, "method_call");
		DebugLocation(142, 1);
		try
		{
			// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:143:2: (o= ID '.' p= ID '(' ( function_arg_list )* ')' -> ^( MCALL $o $p ( function_arg_list )* ) )
			DebugEnterAlt(1);
			// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:143:4: o= ID '.' p= ID '(' ( function_arg_list )* ')'
			{
			DebugLocation(143, 5);
			o=(IToken)Match(input,ID,Follow._ID_in_method_call806); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ID.Add(o);

			DebugLocation(143, 8);
			char_literal51=(IToken)Match(input,47,Follow._47_in_method_call807); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_47.Add(char_literal51);

			DebugLocation(143, 12);
			p=(IToken)Match(input,ID,Follow._ID_in_method_call810); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ID.Add(p);

			DebugLocation(143, 16);
			char_literal52=(IToken)Match(input,41,Follow._41_in_method_call812); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_41.Add(char_literal52);

			DebugLocation(143, 20);
			// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:143:20: ( function_arg_list )*
			try { DebugEnterSubRule(17);
			while (true)
			{
				int alt17=2;
				try { DebugEnterDecision(17, false);
				int LA17_0 = input.LA(1);

				if ((LA17_0==FLOAT||LA17_0==ID||LA17_0==INT||LA17_0==STRING||LA17_0==41))
				{
					alt17 = 1;
				}


				} finally { DebugExitDecision(17); }
				switch ( alt17 )
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:143:20: function_arg_list
					{
					DebugLocation(143, 20);
					PushFollow(Follow._function_arg_list_in_method_call814);
					function_arg_list53=function_arg_list();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_function_arg_list.Add(function_arg_list53.Tree);

					}
					break;

				default:
					goto loop17;
				}
			}

			loop17:
				;

			} finally { DebugExitSubRule(17); }

			DebugLocation(143, 39);
			char_literal54=(IToken)Match(input,42,Follow._42_in_method_call817); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_42.Add(char_literal54);



			{
			// AST REWRITE
			// elements: o, function_arg_list, p
			// token labels: p, o
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleITokenStream stream_p=new RewriteRuleITokenStream(adaptor,"token p",p);
			RewriteRuleITokenStream stream_o=new RewriteRuleITokenStream(adaptor,"token o",o);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 143:43: -> ^( MCALL $o $p ( function_arg_list )* )
			{
				DebugLocation(143, 46);
				// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:143:46: ^( MCALL $o $p ( function_arg_list )* )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(143, 48);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(MCALL, "MCALL"), root_1);

				DebugLocation(143, 55);
				adaptor.AddChild(root_1, stream_o.NextNode());
				DebugLocation(143, 58);
				adaptor.AddChild(root_1, stream_p.NextNode());
				DebugLocation(143, 60);
				// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:143:60: ( function_arg_list )*
				while ( stream_function_arg_list.HasNext )
				{
					DebugLocation(143, 60);
					adaptor.AddChild(root_1, stream_function_arg_list.NextTree());

				}
				stream_function_arg_list.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
			if (state.backtracking == 0)
			{
				 paraphrases.Pop(); 
			}
		}

			catch (RecognitionException e) {
				throw e;
			}

		finally
		{
			TraceOut("method_call", 14);
			LeaveRule("method_call", 14);
			LeaveRule_method_call();
		}
		DebugLocation(144, 1);
		} finally { DebugExitRule(GrammarFileName, "method_call"); }
		return retval;

	}
	// $ANTLR end "method_call"

	partial void EnterRule_function_arg_list();
	partial void LeaveRule_function_arg_list();

	// $ANTLR start "function_arg_list"
	// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:146:1: function_arg_list : plus_expression ( ',' plus_expression )* -> ^( ARG ( plus_expression )* ) ;
	[GrammarRule("function_arg_list")]
	private AstParserRuleReturnScope<object, IToken> function_arg_list()
	{
		EnterRule_function_arg_list();
		EnterRule("function_arg_list", 15);
		TraceIn("function_arg_list", 15);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken char_literal56 = default(IToken);
		AstParserRuleReturnScope<object, IToken> plus_expression55 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> plus_expression57 = default(AstParserRuleReturnScope<object, IToken>);

		object char_literal56_tree = default(object);
		RewriteRuleITokenStream stream_45=new RewriteRuleITokenStream(adaptor,"token 45");
		RewriteRuleSubtreeStream stream_plus_expression=new RewriteRuleSubtreeStream(adaptor,"rule plus_expression");
		 paraphrases.Push("nos argumentos da função"); 
		try { DebugEnterRule(GrammarFileName, "function_arg_list");
		DebugLocation(146, 1);
		try
		{
			// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:148:2: ( plus_expression ( ',' plus_expression )* -> ^( ARG ( plus_expression )* ) )
			DebugEnterAlt(1);
			// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:148:4: plus_expression ( ',' plus_expression )*
			{
			DebugLocation(148, 4);
			PushFollow(Follow._plus_expression_in_function_arg_list862);
			plus_expression55=plus_expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_plus_expression.Add(plus_expression55.Tree);
			DebugLocation(148, 20);
			// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:148:20: ( ',' plus_expression )*
			try { DebugEnterSubRule(18);
			while (true)
			{
				int alt18=2;
				try { DebugEnterDecision(18, false);
				int LA18_0 = input.LA(1);

				if ((LA18_0==45))
				{
					alt18 = 1;
				}


				} finally { DebugExitDecision(18); }
				switch ( alt18 )
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:148:21: ',' plus_expression
					{
					DebugLocation(148, 21);
					char_literal56=(IToken)Match(input,45,Follow._45_in_function_arg_list865); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_45.Add(char_literal56);

					DebugLocation(148, 25);
					PushFollow(Follow._plus_expression_in_function_arg_list867);
					plus_expression57=plus_expression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_plus_expression.Add(plus_expression57.Tree);

					}
					break;

				default:
					goto loop18;
				}
			}

			loop18:
				;

			} finally { DebugExitSubRule(18); }



			{
			// AST REWRITE
			// elements: plus_expression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 148:43: -> ^( ARG ( plus_expression )* )
			{
				DebugLocation(148, 46);
				// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:148:46: ^( ARG ( plus_expression )* )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(148, 48);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(ARG, "ARG"), root_1);

				DebugLocation(148, 52);
				// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:148:52: ( plus_expression )*
				while ( stream_plus_expression.HasNext )
				{
					DebugLocation(148, 52);
					adaptor.AddChild(root_1, stream_plus_expression.NextTree());

				}
				stream_plus_expression.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
			if (state.backtracking == 0)
			{
				 paraphrases.Pop(); 
			}
		}

			catch (RecognitionException e) {
				throw e;
			}

		finally
		{
			TraceOut("function_arg_list", 15);
			LeaveRule("function_arg_list", 15);
			LeaveRule_function_arg_list();
		}
		DebugLocation(149, 1);
		} finally { DebugExitRule(GrammarFileName, "function_arg_list"); }
		return retval;

	}
	// $ANTLR end "function_arg_list"

	partial void EnterRule_assign_var();
	partial void LeaveRule_assign_var();

	// $ANTLR start "assign_var"
	// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:151:1: assign_var : ( ID '=' '[' INT '..' INT ']' -> ^( ASGN ID INT INT ) | ID '=' '{' INT ( ',' INT )* '}' -> ^( ASGN ID ^( ILIST ( INT )* ) ) | ID '[' index ']' '=' assign_expression -> ^( ASGN ^( AR index ) ID assign_expression ) | ID '=' assign_expression -> ^( ASGN ID assign_expression ) );
	[GrammarRule("assign_var")]
	private AstParserRuleReturnScope<object, IToken> assign_var()
	{
		EnterRule_assign_var();
		EnterRule("assign_var", 16);
		TraceIn("assign_var", 16);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken ID58 = default(IToken);
		IToken char_literal59 = default(IToken);
		IToken char_literal60 = default(IToken);
		IToken INT61 = default(IToken);
		IToken string_literal62 = default(IToken);
		IToken INT63 = default(IToken);
		IToken char_literal64 = default(IToken);
		IToken ID65 = default(IToken);
		IToken char_literal66 = default(IToken);
		IToken char_literal67 = default(IToken);
		IToken INT68 = default(IToken);
		IToken char_literal69 = default(IToken);
		IToken INT70 = default(IToken);
		IToken char_literal71 = default(IToken);
		IToken ID72 = default(IToken);
		IToken char_literal73 = default(IToken);
		IToken char_literal75 = default(IToken);
		IToken char_literal76 = default(IToken);
		IToken ID78 = default(IToken);
		IToken char_literal79 = default(IToken);
		AstParserRuleReturnScope<object, IToken> index74 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> assign_expression77 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> assign_expression80 = default(AstParserRuleReturnScope<object, IToken>);

		object ID58_tree = default(object);
		object char_literal59_tree = default(object);
		object char_literal60_tree = default(object);
		object INT61_tree = default(object);
		object string_literal62_tree = default(object);
		object INT63_tree = default(object);
		object char_literal64_tree = default(object);
		object ID65_tree = default(object);
		object char_literal66_tree = default(object);
		object char_literal67_tree = default(object);
		object INT68_tree = default(object);
		object char_literal69_tree = default(object);
		object INT70_tree = default(object);
		object char_literal71_tree = default(object);
		object ID72_tree = default(object);
		object char_literal73_tree = default(object);
		object char_literal75_tree = default(object);
		object char_literal76_tree = default(object);
		object ID78_tree = default(object);
		object char_literal79_tree = default(object);
		RewriteRuleITokenStream stream_48=new RewriteRuleITokenStream(adaptor,"token 48");
		RewriteRuleITokenStream stream_45=new RewriteRuleITokenStream(adaptor,"token 45");
		RewriteRuleITokenStream stream_INT=new RewriteRuleITokenStream(adaptor,"token INT");
		RewriteRuleITokenStream stream_57=new RewriteRuleITokenStream(adaptor,"token 57");
		RewriteRuleITokenStream stream_56=new RewriteRuleITokenStream(adaptor,"token 56");
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleITokenStream stream_52=new RewriteRuleITokenStream(adaptor,"token 52");
		RewriteRuleITokenStream stream_72=new RewriteRuleITokenStream(adaptor,"token 72");
		RewriteRuleITokenStream stream_73=new RewriteRuleITokenStream(adaptor,"token 73");
		RewriteRuleSubtreeStream stream_assign_expression=new RewriteRuleSubtreeStream(adaptor,"rule assign_expression");
		RewriteRuleSubtreeStream stream_index=new RewriteRuleSubtreeStream(adaptor,"rule index");
		 paraphrases.Push("na atribuição de variável"); 
		try { DebugEnterRule(GrammarFileName, "assign_var");
		DebugLocation(151, 1);
		try
		{
			// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:152:2: ( ID '=' '[' INT '..' INT ']' -> ^( ASGN ID INT INT ) | ID '=' '{' INT ( ',' INT )* '}' -> ^( ASGN ID ^( ILIST ( INT )* ) ) | ID '[' index ']' '=' assign_expression -> ^( ASGN ^( AR index ) ID assign_expression ) | ID '=' assign_expression -> ^( ASGN ID assign_expression ) )
			int alt20=4;
			try { DebugEnterDecision(20, false);
			int LA20_0 = input.LA(1);

			if ((LA20_0==ID))
			{
				int LA20_1 = input.LA(2);

				if ((LA20_1==52))
				{
					int LA20_2 = input.LA(3);

					if ((EvaluatePredicate(synpred26_NPortugol_fragment)))
					{
						alt20 = 1;
					}
					else if ((EvaluatePredicate(synpred28_NPortugol_fragment)))
					{
						alt20 = 2;
					}
					else if ((true))
					{
						alt20 = 4;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 20, 2, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}
				else if ((LA20_1==56))
				{
					alt20 = 3;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 20, 1, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 20, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(20); }
			switch (alt20)
			{
			case 1:
				DebugEnterAlt(1);
				// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:153:9: ID '=' '[' INT '..' INT ']'
				{
				DebugLocation(153, 9);
				ID58=(IToken)Match(input,ID,Follow._ID_in_assign_var919); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_ID.Add(ID58);

				DebugLocation(153, 12);
				char_literal59=(IToken)Match(input,52,Follow._52_in_assign_var921); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_52.Add(char_literal59);

				DebugLocation(153, 16);
				char_literal60=(IToken)Match(input,56,Follow._56_in_assign_var923); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_56.Add(char_literal60);

				DebugLocation(153, 20);
				INT61=(IToken)Match(input,INT,Follow._INT_in_assign_var925); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_INT.Add(INT61);

				DebugLocation(153, 24);
				string_literal62=(IToken)Match(input,48,Follow._48_in_assign_var927); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_48.Add(string_literal62);

				DebugLocation(153, 29);
				INT63=(IToken)Match(input,INT,Follow._INT_in_assign_var929); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_INT.Add(INT63);

				DebugLocation(153, 33);
				char_literal64=(IToken)Match(input,57,Follow._57_in_assign_var931); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_57.Add(char_literal64);



				{
				// AST REWRITE
				// elements: ID, INT, INT
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 153:37: -> ^( ASGN ID INT INT )
				{
					DebugLocation(153, 40);
					// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:153:40: ^( ASGN ID INT INT )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(153, 42);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(ASGN, "ASGN"), root_1);

					DebugLocation(153, 47);
					adaptor.AddChild(root_1, stream_ID.NextNode());
					DebugLocation(153, 50);
					adaptor.AddChild(root_1, stream_INT.NextNode());
					DebugLocation(153, 54);
					adaptor.AddChild(root_1, stream_INT.NextNode());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:154:10: ID '=' '{' INT ( ',' INT )* '}'
				{
				DebugLocation(154, 10);
				ID65=(IToken)Match(input,ID,Follow._ID_in_assign_var954); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_ID.Add(ID65);

				DebugLocation(154, 13);
				char_literal66=(IToken)Match(input,52,Follow._52_in_assign_var956); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_52.Add(char_literal66);

				DebugLocation(154, 17);
				char_literal67=(IToken)Match(input,72,Follow._72_in_assign_var958); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_72.Add(char_literal67);

				DebugLocation(154, 21);
				INT68=(IToken)Match(input,INT,Follow._INT_in_assign_var960); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_INT.Add(INT68);

				DebugLocation(154, 25);
				// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:154:25: ( ',' INT )*
				try { DebugEnterSubRule(19);
				while (true)
				{
					int alt19=2;
					try { DebugEnterDecision(19, false);
					int LA19_0 = input.LA(1);

					if ((LA19_0==45))
					{
						alt19 = 1;
					}


					} finally { DebugExitDecision(19); }
					switch ( alt19 )
					{
					case 1:
						DebugEnterAlt(1);
						// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:154:26: ',' INT
						{
						DebugLocation(154, 26);
						char_literal69=(IToken)Match(input,45,Follow._45_in_assign_var963); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_45.Add(char_literal69);

						DebugLocation(154, 30);
						INT70=(IToken)Match(input,INT,Follow._INT_in_assign_var965); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_INT.Add(INT70);


						}
						break;

					default:
						goto loop19;
					}
				}

				loop19:
					;

				} finally { DebugExitSubRule(19); }

				DebugLocation(154, 36);
				char_literal71=(IToken)Match(input,73,Follow._73_in_assign_var969); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_73.Add(char_literal71);



				{
				// AST REWRITE
				// elements: INT, ID
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 154:40: -> ^( ASGN ID ^( ILIST ( INT )* ) )
				{
					DebugLocation(154, 43);
					// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:154:43: ^( ASGN ID ^( ILIST ( INT )* ) )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(154, 45);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(ASGN, "ASGN"), root_1);

					DebugLocation(154, 50);
					adaptor.AddChild(root_1, stream_ID.NextNode());
					DebugLocation(154, 53);
					// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:154:53: ^( ILIST ( INT )* )
					{
					object root_2 = (object)adaptor.Nil();
					DebugLocation(154, 55);
					root_2 = (object)adaptor.BecomeRoot((object)adaptor.Create(ILIST, "ILIST"), root_2);

					DebugLocation(154, 61);
					// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:154:61: ( INT )*
					while ( stream_INT.HasNext )
					{
						DebugLocation(154, 61);
						adaptor.AddChild(root_2, stream_INT.NextNode());

					}
					stream_INT.Reset();

					adaptor.AddChild(root_1, root_2);
					}

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:155:4: ID '[' index ']' '=' assign_expression
				{
				DebugLocation(155, 4);
				ID72=(IToken)Match(input,ID,Follow._ID_in_assign_var989); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_ID.Add(ID72);

				DebugLocation(155, 7);
				char_literal73=(IToken)Match(input,56,Follow._56_in_assign_var991); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_56.Add(char_literal73);

				DebugLocation(155, 11);
				PushFollow(Follow._index_in_assign_var993);
				index74=index();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_index.Add(index74.Tree);
				DebugLocation(155, 17);
				char_literal75=(IToken)Match(input,57,Follow._57_in_assign_var995); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_57.Add(char_literal75);

				DebugLocation(155, 21);
				char_literal76=(IToken)Match(input,52,Follow._52_in_assign_var997); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_52.Add(char_literal76);

				DebugLocation(155, 25);
				PushFollow(Follow._assign_expression_in_assign_var999);
				assign_expression77=assign_expression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_assign_expression.Add(assign_expression77.Tree);


				{
				// AST REWRITE
				// elements: index, assign_expression, ID
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 155:44: -> ^( ASGN ^( AR index ) ID assign_expression )
				{
					DebugLocation(155, 47);
					// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:155:47: ^( ASGN ^( AR index ) ID assign_expression )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(155, 49);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(ASGN, "ASGN"), root_1);

					DebugLocation(155, 54);
					// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:155:54: ^( AR index )
					{
					object root_2 = (object)adaptor.Nil();
					DebugLocation(155, 56);
					root_2 = (object)adaptor.BecomeRoot((object)adaptor.Create(AR, "AR"), root_2);

					DebugLocation(155, 59);
					adaptor.AddChild(root_2, stream_index.NextTree());

					adaptor.AddChild(root_1, root_2);
					}
					DebugLocation(155, 66);
					adaptor.AddChild(root_1, stream_ID.NextNode());
					DebugLocation(155, 69);
					adaptor.AddChild(root_1, stream_assign_expression.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:156:11: ID '=' assign_expression
				{
				DebugLocation(156, 11);
				ID78=(IToken)Match(input,ID,Follow._ID_in_assign_var1028); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_ID.Add(ID78);

				DebugLocation(156, 14);
				char_literal79=(IToken)Match(input,52,Follow._52_in_assign_var1030); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_52.Add(char_literal79);

				DebugLocation(156, 18);
				PushFollow(Follow._assign_expression_in_assign_var1032);
				assign_expression80=assign_expression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_assign_expression.Add(assign_expression80.Tree);


				{
				// AST REWRITE
				// elements: assign_expression, ID
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 156:37: -> ^( ASGN ID assign_expression )
				{
					DebugLocation(156, 40);
					// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:156:40: ^( ASGN ID assign_expression )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(156, 42);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(ASGN, "ASGN"), root_1);

					DebugLocation(156, 47);
					adaptor.AddChild(root_1, stream_ID.NextNode());
					DebugLocation(156, 50);
					adaptor.AddChild(root_1, stream_assign_expression.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
			if (state.backtracking == 0)
			{
				 paraphrases.Pop(); 
			}
		}

			catch (RecognitionException e) {
				throw e;
			}

		finally
		{
			TraceOut("assign_var", 16);
			LeaveRule("assign_var", 16);
			LeaveRule_assign_var();
		}
		DebugLocation(157, 1);
		} finally { DebugExitRule(GrammarFileName, "assign_var"); }
		return retval;

	}
	// $ANTLR end "assign_var"

	partial void EnterRule_return_stat();
	partial void LeaveRule_return_stat();

	// $ANTLR start "return_stat"
	// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:159:1: return_stat : 'retorne' assign_expression -> ^( RET assign_expression ) ;
	[GrammarRule("return_stat")]
	private AstParserRuleReturnScope<object, IToken> return_stat()
	{
		EnterRule_return_stat();
		EnterRule("return_stat", 17);
		TraceIn("return_stat", 17);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken string_literal81 = default(IToken);
		AstParserRuleReturnScope<object, IToken> assign_expression82 = default(AstParserRuleReturnScope<object, IToken>);

		object string_literal81_tree = default(object);
		RewriteRuleITokenStream stream_68=new RewriteRuleITokenStream(adaptor,"token 68");
		RewriteRuleSubtreeStream stream_assign_expression=new RewriteRuleSubtreeStream(adaptor,"rule assign_expression");
		try { DebugEnterRule(GrammarFileName, "return_stat");
		DebugLocation(159, 1);
		try
		{
			// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:160:2: ( 'retorne' assign_expression -> ^( RET assign_expression ) )
			DebugEnterAlt(1);
			// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:160:4: 'retorne' assign_expression
			{
			DebugLocation(160, 4);
			string_literal81=(IToken)Match(input,68,Follow._68_in_return_stat1055); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_68.Add(string_literal81);

			DebugLocation(160, 14);
			PushFollow(Follow._assign_expression_in_return_stat1057);
			assign_expression82=assign_expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_assign_expression.Add(assign_expression82.Tree);


			{
			// AST REWRITE
			// elements: assign_expression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 160:33: -> ^( RET assign_expression )
			{
				DebugLocation(160, 36);
				// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:160:36: ^( RET assign_expression )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(160, 38);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(RET, "RET"), root_1);

				DebugLocation(160, 42);
				adaptor.AddChild(root_1, stream_assign_expression.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

			catch (RecognitionException e) {
				throw e;
			}

		finally
		{
			TraceOut("return_stat", 17);
			LeaveRule("return_stat", 17);
			LeaveRule_return_stat();
		}
		DebugLocation(161, 1);
		} finally { DebugExitRule(GrammarFileName, "return_stat"); }
		return retval;

	}
	// $ANTLR end "return_stat"

	partial void EnterRule_asm_code();
	partial void LeaveRule_asm_code();

	// $ANTLR start "asm_code"
	// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:164:1: asm_code : '#' ( STRING )* '#' -> ^( ASM ( STRING )* ) ;
	[GrammarRule("asm_code")]
	private AstParserRuleReturnScope<object, IToken> asm_code()
	{
		EnterRule_asm_code();
		EnterRule("asm_code", 18);
		TraceIn("asm_code", 18);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken char_literal83 = default(IToken);
		IToken STRING84 = default(IToken);
		IToken char_literal85 = default(IToken);

		object char_literal83_tree = default(object);
		object STRING84_tree = default(object);
		object char_literal85_tree = default(object);
		RewriteRuleITokenStream stream_39=new RewriteRuleITokenStream(adaptor,"token 39");
		RewriteRuleITokenStream stream_STRING=new RewriteRuleITokenStream(adaptor,"token STRING");
		try { DebugEnterRule(GrammarFileName, "asm_code");
		DebugLocation(164, 8);
		try
		{
			// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:164:9: ( '#' ( STRING )* '#' -> ^( ASM ( STRING )* ) )
			DebugEnterAlt(1);
			// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:164:11: '#' ( STRING )* '#'
			{
			DebugLocation(164, 11);
			char_literal83=(IToken)Match(input,39,Follow._39_in_asm_code1076); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_39.Add(char_literal83);

			DebugLocation(164, 15);
			// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:164:15: ( STRING )*
			try { DebugEnterSubRule(21);
			while (true)
			{
				int alt21=2;
				try { DebugEnterDecision(21, false);
				int LA21_0 = input.LA(1);

				if ((LA21_0==STRING))
				{
					alt21 = 1;
				}


				} finally { DebugExitDecision(21); }
				switch ( alt21 )
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:164:15: STRING
					{
					DebugLocation(164, 15);
					STRING84=(IToken)Match(input,STRING,Follow._STRING_in_asm_code1078); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_STRING.Add(STRING84);


					}
					break;

				default:
					goto loop21;
				}
			}

			loop21:
				;

			} finally { DebugExitSubRule(21); }

			DebugLocation(164, 23);
			char_literal85=(IToken)Match(input,39,Follow._39_in_asm_code1081); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_39.Add(char_literal85);



			{
			// AST REWRITE
			// elements: STRING
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 164:27: -> ^( ASM ( STRING )* )
			{
				DebugLocation(164, 30);
				// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:164:30: ^( ASM ( STRING )* )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(164, 32);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(ASM, "ASM"), root_1);

				DebugLocation(164, 36);
				// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:164:36: ( STRING )*
				while ( stream_STRING.HasNext )
				{
					DebugLocation(164, 36);
					adaptor.AddChild(root_1, stream_STRING.NextNode());

				}
				stream_STRING.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

			catch (RecognitionException e) {
				throw e;
			}

		finally
		{
			TraceOut("asm_code", 18);
			LeaveRule("asm_code", 18);
			LeaveRule_asm_code();
		}
		DebugLocation(165, 8);
		} finally { DebugExitRule(GrammarFileName, "asm_code"); }
		return retval;

	}
	// $ANTLR end "asm_code"

	partial void EnterRule_logic_expression();
	partial void LeaveRule_logic_expression();

	// $ANTLR start "logic_expression"
	// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:171:1: logic_expression : ( plus_expression ) ( binop ^ plus_expression )* ;
	[GrammarRule("logic_expression")]
	private AstParserRuleReturnScope<object, IToken> logic_expression()
	{
		EnterRule_logic_expression();
		EnterRule("logic_expression", 19);
		TraceIn("logic_expression", 19);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> plus_expression86 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> binop87 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> plus_expression88 = default(AstParserRuleReturnScope<object, IToken>);

		try { DebugEnterRule(GrammarFileName, "logic_expression");
		DebugLocation(171, 1);
		try
		{
			// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:172:2: ( ( plus_expression ) ( binop ^ plus_expression )* )
			DebugEnterAlt(1);
			// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:172:4: ( plus_expression ) ( binop ^ plus_expression )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(172, 4);
			// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:172:4: ( plus_expression )
			DebugEnterAlt(1);
			// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:172:5: plus_expression
			{
			DebugLocation(172, 5);
			PushFollow(Follow._plus_expression_in_logic_expression1113);
			plus_expression86=plus_expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, plus_expression86.Tree);

			}

			DebugLocation(172, 22);
			// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:172:22: ( binop ^ plus_expression )*
			try { DebugEnterSubRule(22);
			while (true)
			{
				int alt22=2;
				try { DebugEnterDecision(22, false);
				int LA22_0 = input.LA(1);

				if ((LA22_0==38||(LA22_0>=50 && LA22_0<=51)||(LA22_0>=53 && LA22_0<=55)||LA22_0==60||LA22_0==65))
				{
					alt22 = 1;
				}


				} finally { DebugExitDecision(22); }
				switch ( alt22 )
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:172:23: binop ^ plus_expression
					{
					DebugLocation(172, 28);
					PushFollow(Follow._binop_in_logic_expression1117);
					binop87=binop();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) root_0 = (object)adaptor.BecomeRoot(binop87.Tree, root_0);
					DebugLocation(172, 30);
					PushFollow(Follow._plus_expression_in_logic_expression1120);
					plus_expression88=plus_expression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, plus_expression88.Tree);

					}
					break;

				default:
					goto loop22;
				}
			}

			loop22:
				;

			} finally { DebugExitSubRule(22); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

			catch (RecognitionException e) {
				throw e;
			}

		finally
		{
			TraceOut("logic_expression", 19);
			LeaveRule("logic_expression", 19);
			LeaveRule_logic_expression();
		}
		DebugLocation(173, 1);
		} finally { DebugExitRule(GrammarFileName, "logic_expression"); }
		return retval;

	}
	// $ANTLR end "logic_expression"

	partial void EnterRule_binop();
	partial void LeaveRule_binop();

	// $ANTLR start "binop"
	// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:175:1: binop : ( '<' | '>' | '<=' | '>=' | '==' | '!=' | 'e' | 'ou' );
	[GrammarRule("binop")]
	private AstParserRuleReturnScope<object, IToken> binop()
	{
		EnterRule_binop();
		EnterRule("binop", 20);
		TraceIn("binop", 20);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken set89 = default(IToken);

		object set89_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "binop");
		DebugLocation(175, 59);
		try
		{
			// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:175:7: ( '<' | '>' | '<=' | '>=' | '==' | '!=' | 'e' | 'ou' )
			DebugEnterAlt(1);
			// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(175, 7);

			set89=(IToken)input.LT(1);
			if (input.LA(1)==38||(input.LA(1)>=50 && input.LA(1)<=51)||(input.LA(1)>=53 && input.LA(1)<=55)||input.LA(1)==60||input.LA(1)==65)
			{
				input.Consume();
				if (state.backtracking == 0) adaptor.AddChild(root_0, (object)adaptor.Create(set89));
				state.errorRecovery=false;state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

			catch (RecognitionException e) {
				throw e;
			}

		finally
		{
			TraceOut("binop", 20);
			LeaveRule("binop", 20);
			LeaveRule_binop();
		}
		DebugLocation(175, 59);
		} finally { DebugExitRule(GrammarFileName, "binop"); }
		return retval;

	}
	// $ANTLR end "binop"

	partial void EnterRule_assign_expression();
	partial void LeaveRule_assign_expression();

	// $ANTLR start "assign_expression"
	// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:178:1: assign_expression options {k=3; } : plus_expression ;
	[GrammarRule("assign_expression")]
	private AstParserRuleReturnScope<object, IToken> assign_expression()
	{
		EnterRule_assign_expression();
		EnterRule("assign_expression", 21);
		TraceIn("assign_expression", 21);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> plus_expression90 = default(AstParserRuleReturnScope<object, IToken>);

		try { DebugEnterRule(GrammarFileName, "assign_expression");
		DebugLocation(178, 19);
		try
		{
			// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:180:2: ( plus_expression )
			DebugEnterAlt(1);
			// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:180:5: plus_expression
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(180, 5);
			PushFollow(Follow._plus_expression_in_assign_expression1181);
			plus_expression90=plus_expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, plus_expression90.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

			catch (RecognitionException e) {
				throw e;
			}

		finally
		{
			TraceOut("assign_expression", 21);
			LeaveRule("assign_expression", 21);
			LeaveRule_assign_expression();
		}
		DebugLocation(180, 19);
		} finally { DebugExitRule(GrammarFileName, "assign_expression"); }
		return retval;

	}
	// $ANTLR end "assign_expression"

	partial void EnterRule_plus_expression();
	partial void LeaveRule_plus_expression();

	// $ANTLR start "plus_expression"
	// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:182:1: plus_expression : ( mul_expression ) ( '+' ^ mul_expression | '-' ^ mul_expression )* ;
	[GrammarRule("plus_expression")]
	private AstParserRuleReturnScope<object, IToken> plus_expression()
	{
		EnterRule_plus_expression();
		EnterRule("plus_expression", 22);
		TraceIn("plus_expression", 22);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken char_literal92 = default(IToken);
		IToken char_literal94 = default(IToken);
		AstParserRuleReturnScope<object, IToken> mul_expression91 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> mul_expression93 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> mul_expression95 = default(AstParserRuleReturnScope<object, IToken>);

		object char_literal92_tree = default(object);
		object char_literal94_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "plus_expression");
		DebugLocation(182, 1);
		try
		{
			// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:183:2: ( ( mul_expression ) ( '+' ^ mul_expression | '-' ^ mul_expression )* )
			DebugEnterAlt(1);
			// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:183:4: ( mul_expression ) ( '+' ^ mul_expression | '-' ^ mul_expression )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(183, 4);
			// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:183:4: ( mul_expression )
			DebugEnterAlt(1);
			// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:183:5: mul_expression
			{
			DebugLocation(183, 5);
			PushFollow(Follow._mul_expression_in_plus_expression1191);
			mul_expression91=mul_expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, mul_expression91.Tree);

			}

			DebugLocation(183, 21);
			// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:183:21: ( '+' ^ mul_expression | '-' ^ mul_expression )*
			try { DebugEnterSubRule(23);
			while (true)
			{
				int alt23=3;
				try { DebugEnterDecision(23, false);
				int LA23_0 = input.LA(1);

				if ((LA23_0==44))
				{
					alt23 = 1;
				}
				else if ((LA23_0==46))
				{
					alt23 = 2;
				}


				} finally { DebugExitDecision(23); }
				switch ( alt23 )
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:183:22: '+' ^ mul_expression
					{
					DebugLocation(183, 25);
					char_literal92=(IToken)Match(input,44,Follow._44_in_plus_expression1195); if (state.failed) return retval;
					if (state.backtracking == 0) {
					char_literal92_tree = (object)adaptor.Create(char_literal92);
					root_0 = (object)adaptor.BecomeRoot(char_literal92_tree, root_0);
					}
					DebugLocation(183, 27);
					PushFollow(Follow._mul_expression_in_plus_expression1198);
					mul_expression93=mul_expression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, mul_expression93.Tree);

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:183:44: '-' ^ mul_expression
					{
					DebugLocation(183, 47);
					char_literal94=(IToken)Match(input,46,Follow._46_in_plus_expression1202); if (state.failed) return retval;
					if (state.backtracking == 0) {
					char_literal94_tree = (object)adaptor.Create(char_literal94);
					root_0 = (object)adaptor.BecomeRoot(char_literal94_tree, root_0);
					}
					DebugLocation(183, 49);
					PushFollow(Follow._mul_expression_in_plus_expression1205);
					mul_expression95=mul_expression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, mul_expression95.Tree);

					}
					break;

				default:
					goto loop23;
				}
			}

			loop23:
				;

			} finally { DebugExitSubRule(23); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

			catch (RecognitionException e) {
				throw e;
			}

		finally
		{
			TraceOut("plus_expression", 22);
			LeaveRule("plus_expression", 22);
			LeaveRule_plus_expression();
		}
		DebugLocation(184, 1);
		} finally { DebugExitRule(GrammarFileName, "plus_expression"); }
		return retval;

	}
	// $ANTLR end "plus_expression"

	partial void EnterRule_mul_expression();
	partial void LeaveRule_mul_expression();

	// $ANTLR start "mul_expression"
	// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:186:1: mul_expression : ( primary_ar_expression ) ( '/' ^ primary_ar_expression | '%' ^ primary_ar_expression | '*' ^ primary_ar_expression )* ;
	[GrammarRule("mul_expression")]
	private AstParserRuleReturnScope<object, IToken> mul_expression()
	{
		EnterRule_mul_expression();
		EnterRule("mul_expression", 23);
		TraceIn("mul_expression", 23);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken char_literal97 = default(IToken);
		IToken char_literal99 = default(IToken);
		IToken char_literal101 = default(IToken);
		AstParserRuleReturnScope<object, IToken> primary_ar_expression96 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> primary_ar_expression98 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> primary_ar_expression100 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> primary_ar_expression102 = default(AstParserRuleReturnScope<object, IToken>);

		object char_literal97_tree = default(object);
		object char_literal99_tree = default(object);
		object char_literal101_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "mul_expression");
		DebugLocation(186, 1);
		try
		{
			// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:187:2: ( ( primary_ar_expression ) ( '/' ^ primary_ar_expression | '%' ^ primary_ar_expression | '*' ^ primary_ar_expression )* )
			DebugEnterAlt(1);
			// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:187:4: ( primary_ar_expression ) ( '/' ^ primary_ar_expression | '%' ^ primary_ar_expression | '*' ^ primary_ar_expression )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(187, 4);
			// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:187:4: ( primary_ar_expression )
			DebugEnterAlt(1);
			// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:187:5: primary_ar_expression
			{
			DebugLocation(187, 5);
			PushFollow(Follow._primary_ar_expression_in_mul_expression1220);
			primary_ar_expression96=primary_ar_expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, primary_ar_expression96.Tree);

			}

			DebugLocation(187, 28);
			// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:187:28: ( '/' ^ primary_ar_expression | '%' ^ primary_ar_expression | '*' ^ primary_ar_expression )*
			try { DebugEnterSubRule(24);
			while (true)
			{
				int alt24=4;
				try { DebugEnterDecision(24, false);
				switch (input.LA(1))
				{
				case 49:
					{
					alt24 = 1;
					}
					break;
				case 40:
					{
					alt24 = 2;
					}
					break;
				case 43:
					{
					alt24 = 3;
					}
					break;
				}

				} finally { DebugExitDecision(24); }
				switch ( alt24 )
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:187:30: '/' ^ primary_ar_expression
					{
					DebugLocation(187, 33);
					char_literal97=(IToken)Match(input,49,Follow._49_in_mul_expression1225); if (state.failed) return retval;
					if (state.backtracking == 0) {
					char_literal97_tree = (object)adaptor.Create(char_literal97);
					root_0 = (object)adaptor.BecomeRoot(char_literal97_tree, root_0);
					}
					DebugLocation(187, 35);
					PushFollow(Follow._primary_ar_expression_in_mul_expression1228);
					primary_ar_expression98=primary_ar_expression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, primary_ar_expression98.Tree);

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:187:59: '%' ^ primary_ar_expression
					{
					DebugLocation(187, 62);
					char_literal99=(IToken)Match(input,40,Follow._40_in_mul_expression1232); if (state.failed) return retval;
					if (state.backtracking == 0) {
					char_literal99_tree = (object)adaptor.Create(char_literal99);
					root_0 = (object)adaptor.BecomeRoot(char_literal99_tree, root_0);
					}
					DebugLocation(187, 64);
					PushFollow(Follow._primary_ar_expression_in_mul_expression1235);
					primary_ar_expression100=primary_ar_expression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, primary_ar_expression100.Tree);

					}
					break;
				case 3:
					DebugEnterAlt(3);
					// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:187:88: '*' ^ primary_ar_expression
					{
					DebugLocation(187, 91);
					char_literal101=(IToken)Match(input,43,Follow._43_in_mul_expression1239); if (state.failed) return retval;
					if (state.backtracking == 0) {
					char_literal101_tree = (object)adaptor.Create(char_literal101);
					root_0 = (object)adaptor.BecomeRoot(char_literal101_tree, root_0);
					}
					DebugLocation(187, 93);
					PushFollow(Follow._primary_ar_expression_in_mul_expression1242);
					primary_ar_expression102=primary_ar_expression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, primary_ar_expression102.Tree);

					}
					break;

				default:
					goto loop24;
				}
			}

			loop24:
				;

			} finally { DebugExitSubRule(24); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

			catch (RecognitionException e) {
				throw e;
			}

		finally
		{
			TraceOut("mul_expression", 23);
			LeaveRule("mul_expression", 23);
			LeaveRule_mul_expression();
		}
		DebugLocation(188, 1);
		} finally { DebugExitRule(GrammarFileName, "mul_expression"); }
		return retval;

	}
	// $ANTLR end "mul_expression"

	partial void EnterRule_primary_ar_expression();
	partial void LeaveRule_primary_ar_expression();

	// $ANTLR start "primary_ar_expression"
	// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:190:1: primary_ar_expression : ({...}? => function_call | ID | ID '[' index ']' -> ^( INDEX index ) ID | method_call | property_call | constant | parenthesisExpression );
	[GrammarRule("primary_ar_expression")]
	private AstParserRuleReturnScope<object, IToken> primary_ar_expression()
	{
		EnterRule_primary_ar_expression();
		EnterRule("primary_ar_expression", 24);
		TraceIn("primary_ar_expression", 24);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken ID104 = default(IToken);
		IToken ID105 = default(IToken);
		IToken char_literal106 = default(IToken);
		IToken char_literal108 = default(IToken);
		AstParserRuleReturnScope<object, IToken> function_call103 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> index107 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> method_call109 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> property_call110 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> constant111 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> parenthesisExpression112 = default(AstParserRuleReturnScope<object, IToken>);

		object ID104_tree = default(object);
		object ID105_tree = default(object);
		object char_literal106_tree = default(object);
		object char_literal108_tree = default(object);
		RewriteRuleITokenStream stream_57=new RewriteRuleITokenStream(adaptor,"token 57");
		RewriteRuleITokenStream stream_56=new RewriteRuleITokenStream(adaptor,"token 56");
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleSubtreeStream stream_index=new RewriteRuleSubtreeStream(adaptor,"rule index");
		try { DebugEnterRule(GrammarFileName, "primary_ar_expression");
		DebugLocation(190, 1);
		try
		{
			// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:191:2: ({...}? => function_call | ID | ID '[' index ']' -> ^( INDEX index ) ID | method_call | property_call | constant | parenthesisExpression )
			int alt25=7;
			try { DebugEnterDecision(25, false);
			switch (input.LA(1))
			{
			case ID:
				{
				switch (input.LA(2))
				{
				case 41:
					{
					int LA25_4 = input.LA(3);

					if ((((( (!IsDefinedID(input.LT(1).Text)) && input.LT(2).Text =="(" )&&( (!IsDefinedID(input.LT(1).Text)) && input.LT(2).Text =="(" ))&&EvaluatePredicate(synpred44_NPortugol_fragment))))
					{
						alt25 = 1;
					}
					else if ((EvaluatePredicate(synpred45_NPortugol_fragment)))
					{
						alt25 = 2;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 25, 4, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					}
					break;
				case 56:
					{
					alt25 = 3;
					}
					break;
				case 47:
					{
					int LA25_6 = input.LA(3);

					if ((EvaluatePredicate(synpred47_NPortugol_fragment)))
					{
						alt25 = 4;
					}
					else if ((EvaluatePredicate(synpred48_NPortugol_fragment)))
					{
						alt25 = 5;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 25, 6, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					}
					break;
				case EOF:
				case FLOAT:
				case ID:
				case INT:
				case STRING:
				case 38:
				case 39:
				case 40:
				case 42:
				case 43:
				case 44:
				case 45:
				case 46:
				case 49:
				case 50:
				case 51:
				case 53:
				case 54:
				case 55:
				case 58:
				case 60:
				case 61:
				case 62:
				case 63:
				case 65:
				case 66:
				case 67:
				case 68:
				case 69:
				case 70:
				case 71:
					{
					alt25 = 2;
					}
					break;
				default:
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 25, 1, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}

				}
				break;
			case FLOAT:
			case INT:
			case STRING:
				{
				alt25 = 6;
				}
				break;
			case 41:
				{
				alt25 = 7;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 25, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(25); }
			switch (alt25)
			{
			case 1:
				DebugEnterAlt(1);
				// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:191:4: {...}? => function_call
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(191, 4);
				if (!(( (!IsDefinedID(input.LT(1).Text)) && input.LT(2).Text =="(" )))
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					throw new FailedPredicateException(input, "primary_ar_expression", " (!IsDefinedID(input.LT(1).Text)) && input.LT(2).Text ==\"(\" ");
				}
				DebugLocation(191, 71);
				PushFollow(Follow._function_call_in_primary_ar_expression1260);
				function_call103=function_call();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, function_call103.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:192:4: ID
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(192, 4);
				ID104=(IToken)Match(input,ID,Follow._ID_in_primary_ar_expression1265); if (state.failed) return retval;
				if (state.backtracking == 0) {
				ID104_tree = (object)adaptor.Create(ID104);
				adaptor.AddChild(root_0, ID104_tree);
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:193:4: ID '[' index ']'
				{
				DebugLocation(193, 4);
				ID105=(IToken)Match(input,ID,Follow._ID_in_primary_ar_expression1270); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_ID.Add(ID105);

				DebugLocation(193, 7);
				char_literal106=(IToken)Match(input,56,Follow._56_in_primary_ar_expression1272); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_56.Add(char_literal106);

				DebugLocation(193, 11);
				PushFollow(Follow._index_in_primary_ar_expression1274);
				index107=index();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_index.Add(index107.Tree);
				DebugLocation(193, 17);
				char_literal108=(IToken)Match(input,57,Follow._57_in_primary_ar_expression1276); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_57.Add(char_literal108);



				{
				// AST REWRITE
				// elements: ID, index
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 193:21: -> ^( INDEX index ) ID
				{
					DebugLocation(193, 24);
					// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:193:24: ^( INDEX index )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(193, 26);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(INDEX, "INDEX"), root_1);

					DebugLocation(193, 32);
					adaptor.AddChild(root_1, stream_index.NextTree());

					adaptor.AddChild(root_0, root_1);
					}
					DebugLocation(193, 39);
					adaptor.AddChild(root_0, stream_ID.NextNode());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:194:4: method_call
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(194, 4);
				PushFollow(Follow._method_call_in_primary_ar_expression1291);
				method_call109=method_call();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, method_call109.Tree);

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:195:4: property_call
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(195, 4);
				PushFollow(Follow._property_call_in_primary_ar_expression1297);
				property_call110=property_call();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, property_call110.Tree);

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:196:4: constant
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(196, 4);
				PushFollow(Follow._constant_in_primary_ar_expression1302);
				constant111=constant();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, constant111.Tree);

				}
				break;
			case 7:
				DebugEnterAlt(7);
				// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:197:4: parenthesisExpression
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(197, 4);
				PushFollow(Follow._parenthesisExpression_in_primary_ar_expression1307);
				parenthesisExpression112=parenthesisExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, parenthesisExpression112.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

			catch (RecognitionException e) {
				throw e;
			}

		finally
		{
			TraceOut("primary_ar_expression", 24);
			LeaveRule("primary_ar_expression", 24);
			LeaveRule_primary_ar_expression();
		}
		DebugLocation(198, 1);
		} finally { DebugExitRule(GrammarFileName, "primary_ar_expression"); }
		return retval;

	}
	// $ANTLR end "primary_ar_expression"

	partial void EnterRule_parenthesisExpression();
	partial void LeaveRule_parenthesisExpression();

	// $ANTLR start "parenthesisExpression"
	// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:200:1: parenthesisExpression : '(' plus_expression ')' -> plus_expression ;
	[GrammarRule("parenthesisExpression")]
	private AstParserRuleReturnScope<object, IToken> parenthesisExpression()
	{
		EnterRule_parenthesisExpression();
		EnterRule("parenthesisExpression", 25);
		TraceIn("parenthesisExpression", 25);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken char_literal113 = default(IToken);
		IToken char_literal115 = default(IToken);
		AstParserRuleReturnScope<object, IToken> plus_expression114 = default(AstParserRuleReturnScope<object, IToken>);

		object char_literal113_tree = default(object);
		object char_literal115_tree = default(object);
		RewriteRuleITokenStream stream_42=new RewriteRuleITokenStream(adaptor,"token 42");
		RewriteRuleITokenStream stream_41=new RewriteRuleITokenStream(adaptor,"token 41");
		RewriteRuleSubtreeStream stream_plus_expression=new RewriteRuleSubtreeStream(adaptor,"rule plus_expression");
		try { DebugEnterRule(GrammarFileName, "parenthesisExpression");
		DebugLocation(200, 1);
		try
		{
			// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:200:22: ( '(' plus_expression ')' -> plus_expression )
			DebugEnterAlt(1);
			// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:200:24: '(' plus_expression ')'
			{
			DebugLocation(200, 24);
			char_literal113=(IToken)Match(input,41,Follow._41_in_parenthesisExpression1322); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_41.Add(char_literal113);

			DebugLocation(200, 28);
			PushFollow(Follow._plus_expression_in_parenthesisExpression1324);
			plus_expression114=plus_expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_plus_expression.Add(plus_expression114.Tree);
			DebugLocation(200, 44);
			char_literal115=(IToken)Match(input,42,Follow._42_in_parenthesisExpression1326); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_42.Add(char_literal115);



			{
			// AST REWRITE
			// elements: plus_expression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 200:48: -> plus_expression
			{
				DebugLocation(200, 51);
				adaptor.AddChild(root_0, stream_plus_expression.NextTree());

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

			catch (RecognitionException e) {
				throw e;
			}

		finally
		{
			TraceOut("parenthesisExpression", 25);
			LeaveRule("parenthesisExpression", 25);
			LeaveRule_parenthesisExpression();
		}
		DebugLocation(201, 1);
		} finally { DebugExitRule(GrammarFileName, "parenthesisExpression"); }
		return retval;

	}
	// $ANTLR end "parenthesisExpression"

	partial void EnterRule_constant();
	partial void LeaveRule_constant();

	// $ANTLR start "constant"
	// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:203:1: constant : ( INT | FLOAT | STRING );
	[GrammarRule("constant")]
	private AstParserRuleReturnScope<object, IToken> constant()
	{
		EnterRule_constant();
		EnterRule("constant", 26);
		TraceIn("constant", 26);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken set116 = default(IToken);

		object set116_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "constant");
		DebugLocation(203, 30);
		try
		{
			// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:203:9: ( INT | FLOAT | STRING )
			DebugEnterAlt(1);
			// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(203, 9);

			set116=(IToken)input.LT(1);
			if (input.LA(1)==FLOAT||input.LA(1)==INT||input.LA(1)==STRING)
			{
				input.Consume();
				if (state.backtracking == 0) adaptor.AddChild(root_0, (object)adaptor.Create(set116));
				state.errorRecovery=false;state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

			catch (RecognitionException e) {
				throw e;
			}

		finally
		{
			TraceOut("constant", 26);
			LeaveRule("constant", 26);
			LeaveRule_constant();
		}
		DebugLocation(203, 30);
		} finally { DebugExitRule(GrammarFileName, "constant"); }
		return retval;

	}
	// $ANTLR end "constant"

	partial void EnterRule_atom();
	partial void LeaveRule_atom();

	// $ANTLR start "atom"
	// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:205:1: atom : ( constant | ID );
	[GrammarRule("atom")]
	private AstParserRuleReturnScope<object, IToken> atom()
	{
		EnterRule_atom();
		EnterRule("atom", 27);
		TraceIn("atom", 27);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken ID118 = default(IToken);
		AstParserRuleReturnScope<object, IToken> constant117 = default(AstParserRuleReturnScope<object, IToken>);

		object ID118_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "atom");
		DebugLocation(205, 20);
		try
		{
			// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:205:6: ( constant | ID )
			int alt26=2;
			try { DebugEnterDecision(26, false);
			int LA26_0 = input.LA(1);

			if ((LA26_0==FLOAT||LA26_0==INT||LA26_0==STRING))
			{
				alt26 = 1;
			}
			else if ((LA26_0==ID))
			{
				alt26 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 26, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(26); }
			switch (alt26)
			{
			case 1:
				DebugEnterAlt(1);
				// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:205:8: constant
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(205, 8);
				PushFollow(Follow._constant_in_atom1357);
				constant117=constant();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, constant117.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:205:19: ID
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(205, 19);
				ID118=(IToken)Match(input,ID,Follow._ID_in_atom1361); if (state.failed) return retval;
				if (state.backtracking == 0) {
				ID118_tree = (object)adaptor.Create(ID118);
				adaptor.AddChild(root_0, ID118_tree);
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

			catch (RecognitionException e) {
				throw e;
			}

		finally
		{
			TraceOut("atom", 27);
			LeaveRule("atom", 27);
			LeaveRule_atom();
		}
		DebugLocation(205, 20);
		} finally { DebugExitRule(GrammarFileName, "atom"); }
		return retval;

	}
	// $ANTLR end "atom"

	partial void EnterRule_index();
	partial void LeaveRule_index();

	// $ANTLR start "index"
	// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:207:1: index : ( INT | ID );
	[GrammarRule("index")]
	private AstParserRuleReturnScope<object, IToken> index()
	{
		EnterRule_index();
		EnterRule("index", 28);
		TraceIn("index", 28);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken set119 = default(IToken);

		object set119_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "index");
		DebugLocation(207, 16);
		try
		{
			// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:207:7: ( INT | ID )
			DebugEnterAlt(1);
			// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(207, 7);

			set119=(IToken)input.LT(1);
			if (input.LA(1)==ID||input.LA(1)==INT)
			{
				input.Consume();
				if (state.backtracking == 0) adaptor.AddChild(root_0, (object)adaptor.Create(set119));
				state.errorRecovery=false;state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

			catch (RecognitionException e) {
				throw e;
			}

		finally
		{
			TraceOut("index", 28);
			LeaveRule("index", 28);
			LeaveRule_index();
		}
		DebugLocation(207, 16);
		} finally { DebugExitRule(GrammarFileName, "index"); }
		return retval;

	}
	// $ANTLR end "index"

	partial void EnterRule_number();
	partial void LeaveRule_number();

	// $ANTLR start "number"
	// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:209:1: number : ( INT | FLOAT );
	[GrammarRule("number")]
	private AstParserRuleReturnScope<object, IToken> number()
	{
		EnterRule_number();
		EnterRule("number", 29);
		TraceIn("number", 29);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken set120 = default(IToken);

		object set120_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "number");
		DebugLocation(209, 20);
		try
		{
			// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:209:8: ( INT | FLOAT )
			DebugEnterAlt(1);
			// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(209, 8);

			set120=(IToken)input.LT(1);
			if (input.LA(1)==FLOAT||input.LA(1)==INT)
			{
				input.Consume();
				if (state.backtracking == 0) adaptor.AddChild(root_0, (object)adaptor.Create(set120));
				state.errorRecovery=false;state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

			catch (RecognitionException e) {
				throw e;
			}

		finally
		{
			TraceOut("number", 29);
			LeaveRule("number", 29);
			LeaveRule_number();
		}
		DebugLocation(209, 20);
		} finally { DebugExitRule(GrammarFileName, "number"); }
		return retval;

	}
	// $ANTLR end "number"

	partial void EnterRule_synpred23_NPortugol_fragment();
	partial void LeaveRule_synpred23_NPortugol_fragment();

	// $ANTLR start synpred23_NPortugol
	public void synpred23_NPortugol_fragment()
	{
		EnterRule_synpred23_NPortugol_fragment();
		EnterRule("synpred23_NPortugol_fragment", 52);
		TraceIn("synpred23_NPortugol_fragment", 52);
		try
		{
			// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:135:11: ( function_arg_list )
			DebugEnterAlt(1);
			// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:135:11: function_arg_list
			{
			DebugLocation(135, 11);
			PushFollow(Follow._function_arg_list_in_synpred23_NPortugol714);
			function_arg_list();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred23_NPortugol_fragment", 52);
			LeaveRule("synpred23_NPortugol_fragment", 52);
			LeaveRule_synpred23_NPortugol_fragment();
		}
	}
	// $ANTLR end synpred23_NPortugol

	partial void EnterRule_synpred24_NPortugol_fragment();
	partial void LeaveRule_synpred24_NPortugol_fragment();

	// $ANTLR start synpred24_NPortugol
	public void synpred24_NPortugol_fragment()
	{
		EnterRule_synpred24_NPortugol_fragment();
		EnterRule("synpred24_NPortugol_fragment", 53);
		TraceIn("synpred24_NPortugol_fragment", 53);
		try
		{
			// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:143:20: ( function_arg_list )
			DebugEnterAlt(1);
			// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:143:20: function_arg_list
			{
			DebugLocation(143, 20);
			PushFollow(Follow._function_arg_list_in_synpred24_NPortugol814);
			function_arg_list();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred24_NPortugol_fragment", 53);
			LeaveRule("synpred24_NPortugol_fragment", 53);
			LeaveRule_synpred24_NPortugol_fragment();
		}
	}
	// $ANTLR end synpred24_NPortugol

	partial void EnterRule_synpred26_NPortugol_fragment();
	partial void LeaveRule_synpred26_NPortugol_fragment();

	// $ANTLR start synpred26_NPortugol
	public void synpred26_NPortugol_fragment()
	{
		EnterRule_synpred26_NPortugol_fragment();
		EnterRule("synpred26_NPortugol_fragment", 55);
		TraceIn("synpred26_NPortugol_fragment", 55);
		try
		{
			// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:153:9: ( ID '=' '[' INT '..' INT ']' )
			DebugEnterAlt(1);
			// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:153:9: ID '=' '[' INT '..' INT ']'
			{
			DebugLocation(153, 9);
			Match(input,ID,Follow._ID_in_synpred26_NPortugol919); if (state.failed) return;
			DebugLocation(153, 12);
			Match(input,52,Follow._52_in_synpred26_NPortugol921); if (state.failed) return;
			DebugLocation(153, 16);
			Match(input,56,Follow._56_in_synpred26_NPortugol923); if (state.failed) return;
			DebugLocation(153, 20);
			Match(input,INT,Follow._INT_in_synpred26_NPortugol925); if (state.failed) return;
			DebugLocation(153, 24);
			Match(input,48,Follow._48_in_synpred26_NPortugol927); if (state.failed) return;
			DebugLocation(153, 29);
			Match(input,INT,Follow._INT_in_synpred26_NPortugol929); if (state.failed) return;
			DebugLocation(153, 33);
			Match(input,57,Follow._57_in_synpred26_NPortugol931); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred26_NPortugol_fragment", 55);
			LeaveRule("synpred26_NPortugol_fragment", 55);
			LeaveRule_synpred26_NPortugol_fragment();
		}
	}
	// $ANTLR end synpred26_NPortugol

	partial void EnterRule_synpred28_NPortugol_fragment();
	partial void LeaveRule_synpred28_NPortugol_fragment();

	// $ANTLR start synpred28_NPortugol
	public void synpred28_NPortugol_fragment()
	{
		EnterRule_synpred28_NPortugol_fragment();
		EnterRule("synpred28_NPortugol_fragment", 57);
		TraceIn("synpred28_NPortugol_fragment", 57);
		try
		{
			// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:154:10: ( ID '=' '{' INT ( ',' INT )* '}' )
			DebugEnterAlt(1);
			// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:154:10: ID '=' '{' INT ( ',' INT )* '}'
			{
			DebugLocation(154, 10);
			Match(input,ID,Follow._ID_in_synpred28_NPortugol954); if (state.failed) return;
			DebugLocation(154, 13);
			Match(input,52,Follow._52_in_synpred28_NPortugol956); if (state.failed) return;
			DebugLocation(154, 17);
			Match(input,72,Follow._72_in_synpred28_NPortugol958); if (state.failed) return;
			DebugLocation(154, 21);
			Match(input,INT,Follow._INT_in_synpred28_NPortugol960); if (state.failed) return;
			DebugLocation(154, 25);
			// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:154:25: ( ',' INT )*
			try { DebugEnterSubRule(28);
			while (true)
			{
				int alt28=2;
				try { DebugEnterDecision(28, false);
				int LA28_0 = input.LA(1);

				if ((LA28_0==45))
				{
					alt28 = 1;
				}


				} finally { DebugExitDecision(28); }
				switch ( alt28 )
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:154:26: ',' INT
					{
					DebugLocation(154, 26);
					Match(input,45,Follow._45_in_synpred28_NPortugol963); if (state.failed) return;
					DebugLocation(154, 30);
					Match(input,INT,Follow._INT_in_synpred28_NPortugol965); if (state.failed) return;

					}
					break;

				default:
					goto loop28;
				}
			}

			loop28:
				;

			} finally { DebugExitSubRule(28); }

			DebugLocation(154, 36);
			Match(input,73,Follow._73_in_synpred28_NPortugol969); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred28_NPortugol_fragment", 57);
			LeaveRule("synpred28_NPortugol_fragment", 57);
			LeaveRule_synpred28_NPortugol_fragment();
		}
	}
	// $ANTLR end synpred28_NPortugol

	partial void EnterRule_synpred44_NPortugol_fragment();
	partial void LeaveRule_synpred44_NPortugol_fragment();

	// $ANTLR start synpred44_NPortugol
	public void synpred44_NPortugol_fragment()
	{
		EnterRule_synpred44_NPortugol_fragment();
		EnterRule("synpred44_NPortugol_fragment", 73);
		TraceIn("synpred44_NPortugol_fragment", 73);
		try
		{
			// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:191:4: ({...}? => function_call )
			DebugEnterAlt(1);
			// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:191:4: {...}? => function_call
			{
			DebugLocation(191, 4);
			if (!(( (!IsDefinedID(input.LT(1).Text)) && input.LT(2).Text =="(" )))
			{
				if (state.backtracking>0) {state.failed=true; return;}
				throw new FailedPredicateException(input, "synpred44_NPortugol", " (!IsDefinedID(input.LT(1).Text)) && input.LT(2).Text ==\"(\" ");
			}
			DebugLocation(191, 71);
			PushFollow(Follow._function_call_in_synpred44_NPortugol1260);
			function_call();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred44_NPortugol_fragment", 73);
			LeaveRule("synpred44_NPortugol_fragment", 73);
			LeaveRule_synpred44_NPortugol_fragment();
		}
	}
	// $ANTLR end synpred44_NPortugol

	partial void EnterRule_synpred45_NPortugol_fragment();
	partial void LeaveRule_synpred45_NPortugol_fragment();

	// $ANTLR start synpred45_NPortugol
	public void synpred45_NPortugol_fragment()
	{
		EnterRule_synpred45_NPortugol_fragment();
		EnterRule("synpred45_NPortugol_fragment", 74);
		TraceIn("synpred45_NPortugol_fragment", 74);
		try
		{
			// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:192:4: ( ID )
			DebugEnterAlt(1);
			// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:192:4: ID
			{
			DebugLocation(192, 4);
			Match(input,ID,Follow._ID_in_synpred45_NPortugol1265); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred45_NPortugol_fragment", 74);
			LeaveRule("synpred45_NPortugol_fragment", 74);
			LeaveRule_synpred45_NPortugol_fragment();
		}
	}
	// $ANTLR end synpred45_NPortugol

	partial void EnterRule_synpred47_NPortugol_fragment();
	partial void LeaveRule_synpred47_NPortugol_fragment();

	// $ANTLR start synpred47_NPortugol
	public void synpred47_NPortugol_fragment()
	{
		EnterRule_synpred47_NPortugol_fragment();
		EnterRule("synpred47_NPortugol_fragment", 76);
		TraceIn("synpred47_NPortugol_fragment", 76);
		try
		{
			// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:194:4: ( method_call )
			DebugEnterAlt(1);
			// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:194:4: method_call
			{
			DebugLocation(194, 4);
			PushFollow(Follow._method_call_in_synpred47_NPortugol1291);
			method_call();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred47_NPortugol_fragment", 76);
			LeaveRule("synpred47_NPortugol_fragment", 76);
			LeaveRule_synpred47_NPortugol_fragment();
		}
	}
	// $ANTLR end synpred47_NPortugol

	partial void EnterRule_synpred48_NPortugol_fragment();
	partial void LeaveRule_synpred48_NPortugol_fragment();

	// $ANTLR start synpred48_NPortugol
	public void synpred48_NPortugol_fragment()
	{
		EnterRule_synpred48_NPortugol_fragment();
		EnterRule("synpred48_NPortugol_fragment", 77);
		TraceIn("synpred48_NPortugol_fragment", 77);
		try
		{
			// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:195:4: ( property_call )
			DebugEnterAlt(1);
			// E:\\Dev\\Git\\NPortugol2\\src\\NPortugol2\\Compiler\\NPortugol.g:195:4: property_call
			{
			DebugLocation(195, 4);
			PushFollow(Follow._property_call_in_synpred48_NPortugol1297);
			property_call();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred48_NPortugol_fragment", 77);
			LeaveRule("synpred48_NPortugol_fragment", 77);
			LeaveRule_synpred48_NPortugol_fragment();
		}
	}
	// $ANTLR end synpred48_NPortugol
	#endregion Rules

	#region Synpreds
	private bool EvaluatePredicate(System.Action fragment)
	{
		bool success = false;
		state.backtracking++;
		try { DebugBeginBacktrack(state.backtracking);
		int start = input.Mark();
		try
		{
			fragment();
		}
		catch ( RecognitionException re )
		{
			System.Console.Error.WriteLine("impossible: "+re);
		}
		success = !state.failed;
		input.Rewind(start);
		} finally { DebugEndBacktrack(state.backtracking, success); }
		state.backtracking--;
		state.failed=false;
		return success;
	}
	#endregion Synpreds


	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _declare_function_in_script148 = new BitSet(new ulong[]{0x2UL,0x1UL});
		public static readonly BitSet _64_in_declare_function159 = new BitSet(new ulong[]{0x400020000UL});
		public static readonly BitSet _TYPE_in_declare_function163 = new BitSet(new ulong[]{0x20000UL});
		public static readonly BitSet _ID_in_declare_function168 = new BitSet(new ulong[]{0x20000000000UL});
		public static readonly BitSet _41_in_declare_function170 = new BitSet(new ulong[]{0x40400000000UL});
		public static readonly BitSet _function_param_list_in_declare_function172 = new BitSet(new ulong[]{0x40400000000UL});
		public static readonly BitSet _42_in_declare_function175 = new BitSet(new ulong[]{0xA000008000020000UL,0xBCUL});
		public static readonly BitSet _statement_in_declare_function177 = new BitSet(new ulong[]{0xA000008000020000UL,0xBCUL});
		public static readonly BitSet _63_in_declare_function180 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _declare_local_in_statement230 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _if_stat_in_statement236 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _for_stat_in_statement242 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _while_stat_in_statement247 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _repeat_stat_in_statement252 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _function_call_in_statement258 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _assign_var_in_statement264 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _return_stat_in_statement270 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _asm_code_in_statement275 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _param_in_function_param_list303 = new BitSet(new ulong[]{0x200000000002UL});
		public static readonly BitSet _45_in_function_param_list306 = new BitSet(new ulong[]{0x400000000UL});
		public static readonly BitSet _param_in_function_param_list308 = new BitSet(new ulong[]{0x200000000002UL});
		public static readonly BitSet _TYPE_in_param331 = new BitSet(new ulong[]{0x20000UL});
		public static readonly BitSet _ID_in_param333 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _71_in_declare_local373 = new BitSet(new ulong[]{0x20000UL});
		public static readonly BitSet _ID_in_declare_local377 = new BitSet(new ulong[]{0x200000000002UL});
		public static readonly BitSet _45_in_declare_local380 = new BitSet(new ulong[]{0x20000UL});
		public static readonly BitSet _ID_in_declare_local384 = new BitSet(new ulong[]{0x200000000002UL});
		public static readonly BitSet _69_in_if_stat427 = new BitSet(new ulong[]{0x20200224000UL});
		public static readonly BitSet _logic_expression_in_if_stat431 = new BitSet(new ulong[]{0x4000000000000000UL});
		public static readonly BitSet _62_in_if_stat433 = new BitSet(new ulong[]{0xA000008000020000UL,0xFCUL});
		public static readonly BitSet _statement_in_if_stat437 = new BitSet(new ulong[]{0xA000008000020000UL,0xFCUL});
		public static readonly BitSet _senao_stat_in_if_stat445 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _63_in_if_stat473 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _70_in_senao_stat509 = new BitSet(new ulong[]{0xA000008000020000UL,0xBCUL});
		public static readonly BitSet _statement_in_senao_stat513 = new BitSet(new ulong[]{0xA000008000020000UL,0xBCUL});
		public static readonly BitSet _63_in_senao_stat516 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _66_in_for_stat536 = new BitSet(new ulong[]{0x20000UL});
		public static readonly BitSet _assign_var_in_for_stat538 = new BitSet(new ulong[]{0x400000000000000UL});
		public static readonly BitSet _58_in_for_stat540 = new BitSet(new ulong[]{0x220000UL});
		public static readonly BitSet _index_in_for_stat542 = new BitSet(new ulong[]{0xA800008000020000UL,0xBCUL});
		public static readonly BitSet _59_in_for_stat550 = new BitSet(new ulong[]{0xA000008000020000UL,0xBCUL});
		public static readonly BitSet _statement_in_for_stat552 = new BitSet(new ulong[]{0xA000008000020000UL,0xBCUL});
		public static readonly BitSet _63_in_for_stat555 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _statement_in_for_stat580 = new BitSet(new ulong[]{0xA000008000020000UL,0xBCUL});
		public static readonly BitSet _63_in_for_stat583 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _61_in_while_stat616 = new BitSet(new ulong[]{0x20200224000UL});
		public static readonly BitSet _logic_expression_in_while_stat618 = new BitSet(new ulong[]{0xA000008000020000UL,0xBCUL});
		public static readonly BitSet _statement_in_while_stat620 = new BitSet(new ulong[]{0xA000008000020000UL,0xBCUL});
		public static readonly BitSet _63_in_while_stat623 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _67_in_repeat_stat655 = new BitSet(new ulong[]{0x2400008000020000UL,0xBCUL});
		public static readonly BitSet _statement_in_repeat_stat657 = new BitSet(new ulong[]{0x2400008000020000UL,0xBCUL});
		public static readonly BitSet _58_in_repeat_stat660 = new BitSet(new ulong[]{0x20200224000UL});
		public static readonly BitSet _logic_expression_in_repeat_stat662 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_function_call710 = new BitSet(new ulong[]{0x20000000000UL});
		public static readonly BitSet _41_in_function_call712 = new BitSet(new ulong[]{0x60200224000UL});
		public static readonly BitSet _function_arg_list_in_function_call714 = new BitSet(new ulong[]{0x60200224000UL});
		public static readonly BitSet _42_in_function_call717 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_property_call758 = new BitSet(new ulong[]{0x800000000000UL});
		public static readonly BitSet _47_in_property_call759 = new BitSet(new ulong[]{0x20000UL});
		public static readonly BitSet _ID_in_property_call762 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_method_call806 = new BitSet(new ulong[]{0x800000000000UL});
		public static readonly BitSet _47_in_method_call807 = new BitSet(new ulong[]{0x20000UL});
		public static readonly BitSet _ID_in_method_call810 = new BitSet(new ulong[]{0x20000000000UL});
		public static readonly BitSet _41_in_method_call812 = new BitSet(new ulong[]{0x60200224000UL});
		public static readonly BitSet _function_arg_list_in_method_call814 = new BitSet(new ulong[]{0x60200224000UL});
		public static readonly BitSet _42_in_method_call817 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _plus_expression_in_function_arg_list862 = new BitSet(new ulong[]{0x200000000002UL});
		public static readonly BitSet _45_in_function_arg_list865 = new BitSet(new ulong[]{0x20200224000UL});
		public static readonly BitSet _plus_expression_in_function_arg_list867 = new BitSet(new ulong[]{0x200000000002UL});
		public static readonly BitSet _ID_in_assign_var919 = new BitSet(new ulong[]{0x10000000000000UL});
		public static readonly BitSet _52_in_assign_var921 = new BitSet(new ulong[]{0x100000000000000UL});
		public static readonly BitSet _56_in_assign_var923 = new BitSet(new ulong[]{0x200000UL});
		public static readonly BitSet _INT_in_assign_var925 = new BitSet(new ulong[]{0x1000000000000UL});
		public static readonly BitSet _48_in_assign_var927 = new BitSet(new ulong[]{0x200000UL});
		public static readonly BitSet _INT_in_assign_var929 = new BitSet(new ulong[]{0x200000000000000UL});
		public static readonly BitSet _57_in_assign_var931 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_assign_var954 = new BitSet(new ulong[]{0x10000000000000UL});
		public static readonly BitSet _52_in_assign_var956 = new BitSet(new ulong[]{0x0UL,0x100UL});
		public static readonly BitSet _72_in_assign_var958 = new BitSet(new ulong[]{0x200000UL});
		public static readonly BitSet _INT_in_assign_var960 = new BitSet(new ulong[]{0x200000000000UL,0x200UL});
		public static readonly BitSet _45_in_assign_var963 = new BitSet(new ulong[]{0x200000UL});
		public static readonly BitSet _INT_in_assign_var965 = new BitSet(new ulong[]{0x200000000000UL,0x200UL});
		public static readonly BitSet _73_in_assign_var969 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_assign_var989 = new BitSet(new ulong[]{0x100000000000000UL});
		public static readonly BitSet _56_in_assign_var991 = new BitSet(new ulong[]{0x220000UL});
		public static readonly BitSet _index_in_assign_var993 = new BitSet(new ulong[]{0x200000000000000UL});
		public static readonly BitSet _57_in_assign_var995 = new BitSet(new ulong[]{0x10000000000000UL});
		public static readonly BitSet _52_in_assign_var997 = new BitSet(new ulong[]{0x20200224000UL});
		public static readonly BitSet _assign_expression_in_assign_var999 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_assign_var1028 = new BitSet(new ulong[]{0x10000000000000UL});
		public static readonly BitSet _52_in_assign_var1030 = new BitSet(new ulong[]{0x20200224000UL});
		public static readonly BitSet _assign_expression_in_assign_var1032 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _68_in_return_stat1055 = new BitSet(new ulong[]{0x20200224000UL});
		public static readonly BitSet _assign_expression_in_return_stat1057 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _39_in_asm_code1076 = new BitSet(new ulong[]{0x8200000000UL});
		public static readonly BitSet _STRING_in_asm_code1078 = new BitSet(new ulong[]{0x8200000000UL});
		public static readonly BitSet _39_in_asm_code1081 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _plus_expression_in_logic_expression1113 = new BitSet(new ulong[]{0x10EC004000000002UL,0x2UL});
		public static readonly BitSet _binop_in_logic_expression1117 = new BitSet(new ulong[]{0x20200224000UL});
		public static readonly BitSet _plus_expression_in_logic_expression1120 = new BitSet(new ulong[]{0x10EC004000000002UL,0x2UL});
		public static readonly BitSet _plus_expression_in_assign_expression1181 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _mul_expression_in_plus_expression1191 = new BitSet(new ulong[]{0x500000000002UL});
		public static readonly BitSet _44_in_plus_expression1195 = new BitSet(new ulong[]{0x20200224000UL});
		public static readonly BitSet _mul_expression_in_plus_expression1198 = new BitSet(new ulong[]{0x500000000002UL});
		public static readonly BitSet _46_in_plus_expression1202 = new BitSet(new ulong[]{0x20200224000UL});
		public static readonly BitSet _mul_expression_in_plus_expression1205 = new BitSet(new ulong[]{0x500000000002UL});
		public static readonly BitSet _primary_ar_expression_in_mul_expression1220 = new BitSet(new ulong[]{0x2090000000002UL});
		public static readonly BitSet _49_in_mul_expression1225 = new BitSet(new ulong[]{0x20200224000UL});
		public static readonly BitSet _primary_ar_expression_in_mul_expression1228 = new BitSet(new ulong[]{0x2090000000002UL});
		public static readonly BitSet _40_in_mul_expression1232 = new BitSet(new ulong[]{0x20200224000UL});
		public static readonly BitSet _primary_ar_expression_in_mul_expression1235 = new BitSet(new ulong[]{0x2090000000002UL});
		public static readonly BitSet _43_in_mul_expression1239 = new BitSet(new ulong[]{0x20200224000UL});
		public static readonly BitSet _primary_ar_expression_in_mul_expression1242 = new BitSet(new ulong[]{0x2090000000002UL});
		public static readonly BitSet _function_call_in_primary_ar_expression1260 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_primary_ar_expression1265 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_primary_ar_expression1270 = new BitSet(new ulong[]{0x100000000000000UL});
		public static readonly BitSet _56_in_primary_ar_expression1272 = new BitSet(new ulong[]{0x220000UL});
		public static readonly BitSet _index_in_primary_ar_expression1274 = new BitSet(new ulong[]{0x200000000000000UL});
		public static readonly BitSet _57_in_primary_ar_expression1276 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _method_call_in_primary_ar_expression1291 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _property_call_in_primary_ar_expression1297 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _constant_in_primary_ar_expression1302 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _parenthesisExpression_in_primary_ar_expression1307 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _41_in_parenthesisExpression1322 = new BitSet(new ulong[]{0x20200224000UL});
		public static readonly BitSet _plus_expression_in_parenthesisExpression1324 = new BitSet(new ulong[]{0x40000000000UL});
		public static readonly BitSet _42_in_parenthesisExpression1326 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _constant_in_atom1357 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_atom1361 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _function_arg_list_in_synpred23_NPortugol714 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _function_arg_list_in_synpred24_NPortugol814 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_synpred26_NPortugol919 = new BitSet(new ulong[]{0x10000000000000UL});
		public static readonly BitSet _52_in_synpred26_NPortugol921 = new BitSet(new ulong[]{0x100000000000000UL});
		public static readonly BitSet _56_in_synpred26_NPortugol923 = new BitSet(new ulong[]{0x200000UL});
		public static readonly BitSet _INT_in_synpred26_NPortugol925 = new BitSet(new ulong[]{0x1000000000000UL});
		public static readonly BitSet _48_in_synpred26_NPortugol927 = new BitSet(new ulong[]{0x200000UL});
		public static readonly BitSet _INT_in_synpred26_NPortugol929 = new BitSet(new ulong[]{0x200000000000000UL});
		public static readonly BitSet _57_in_synpred26_NPortugol931 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_synpred28_NPortugol954 = new BitSet(new ulong[]{0x10000000000000UL});
		public static readonly BitSet _52_in_synpred28_NPortugol956 = new BitSet(new ulong[]{0x0UL,0x100UL});
		public static readonly BitSet _72_in_synpred28_NPortugol958 = new BitSet(new ulong[]{0x200000UL});
		public static readonly BitSet _INT_in_synpred28_NPortugol960 = new BitSet(new ulong[]{0x200000000000UL,0x200UL});
		public static readonly BitSet _45_in_synpred28_NPortugol963 = new BitSet(new ulong[]{0x200000UL});
		public static readonly BitSet _INT_in_synpred28_NPortugol965 = new BitSet(new ulong[]{0x200000000000UL,0x200UL});
		public static readonly BitSet _73_in_synpred28_NPortugol969 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _function_call_in_synpred44_NPortugol1260 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_synpred45_NPortugol1265 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _method_call_in_synpred47_NPortugol1291 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _property_call_in_synpred48_NPortugol1297 = new BitSet(new ulong[]{0x2UL});
	}
	#endregion Follow sets
}

} // namespace NPortugol2.Compiler
